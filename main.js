/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ProcessorProcessorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// task_definitions.json
var task_definitions_default = [
  {
    name: "Verify Subprocessor List URL",
    description: "Checks if a URL points to a current and valid subprocessor list for a specific company.",
    system_prompt: "You are an expert in data privacy and compliance documentation analysis.",
    user_prompt: `Goal: Your primary goal is to determine if the provided text from {url_content} is a subprocessor list that belongs to the {expected_processor_name} and is the current, active version.

Input Parameters:

{url_content}: The text content from a URL.

{expected_processor_name}: The name of the company for whom you are trying to find the subprocessor list.

CRITICAL RULE: The page must belong to the {expected_processor_name} as the primary company. Do NOT return 'isCorrectProcessor: true' if {expected_processor_name} is only mentioned as a sub-processor of another company. For example, if searching for 'Apple' and you find a list owned by 'Command Alkon' that lists Apple as one of its subprocessors, 'isCorrectProcessor' MUST be false.

Processing Steps:

1. Is it a Subprocessor List?
- Scan for explicit titles (e.g., "Subprocessor List").
- Look for a structured list/table of multiple distinct company names.
- If it is not a subprocessor list, all other checks are irrelevant.

2. Is it for the Correct Company?
- ONLY if it is a subprocessor list, analyze the page title, headings, and legal text to identify the company that OWNS the list.
- Compare the identified owner with the {expected_processor_name}, accounting for variations (e.g., 'AWS' for 'Amazon Web Services').
- If the list does not clearly belong to the {expected_processor_name}, the currency check is irrelevant.

3. Is the List Current?
- ONLY if it is a subprocessor list for the correct company, determine if it's the current version by looking for explicit archival notices or recent update dates (within the last 1-2 years is a good heuristic).`,
    llm_model_id: "01965cb4-73f4-9ec3-6f21-bede0391e2b4",
    output_format: {
      isSubprocessorList: { type: "boolean", description: "True if the content appears to be a list of subprocessors." },
      isCorrectProcessor: { type: "boolean", description: "True if the page content belongs to the 'expected_processor_name'." },
      isCurrentVersion: { type: "boolean", description: "True if the list appears to be the current, active version." },
      reasoning: { type: "string", description: "Briefly state the key evidence for your decision." },
      page_content: { type: "string", description: "The full text content fetched from the input URL." }
    },
    input_processors: [
      { param_name: "url_content", input_processor: "url_fetcher", config: { extract_text: true } }
    ],
    enabled: true
  },
  {
    name: "Extract Entities From Page Content",
    description: "Extracts and categorizes subprocessor and internal affiliate details from text content.",
    system_prompt: "You are an expert data extraction specialist, skilled at identifying and categorizing entities from unstructured text. Focus on accurately discerning third-party subprocessors from internal entities, extracting key details and organizing the information into a structured JSON format.",
    user_prompt: `Goal: Extract detailed information about third-party subprocessors and internal entities from a company's subprocessor information page.

Context: Subprocessor information pages typically list external companies (third-party subprocessors) that process data on behalf of the main company, as well as internal entities or affiliates. This information is often structured in sections with headings and may be formatted as tables using Markdown or HTML elements.

Input Parameters:
{page_text} - The text content from a company's subprocessor information page.

Processing Steps:
1. Analyze the provided text.
2. Identify sections for third-party subprocessors (e.g., "Third Party Sub-processors") and internal entities (e.g., "Our Group Companies").
3. For each third-party subprocessor, extract: name, processing function, and location.
4. For each internal entity, extract: name, role/function, and location.
5. Organize the extracted information into the required JSON structure.

Output Guidance:
Return a JSON object with two top-level keys: 'third_party_subprocessors' and 'own_entities', each a list of objects containing 'name', 'processing_function', and 'location'. If a category is empty, return an empty list. Use null for missing fields. If no distinction is made, classify all as 'third_party_subprocessors'.`,
    llm_model_id: "01965cb4-73f4-9ec3-6f21-bede0391e2b4",
    output_format: {
      third_party_subprocessors: {
        type: "list",
        item_type: "object",
        nested_structure: { name: { type: "string" }, processing_function: { type: "string" }, location: { type: "string" } }
      },
      own_entities: {
        type: "list",
        item_type: "object",
        nested_structure: { name: { type: "string" }, processing_function: { type: "string" }, location: { type: "string" } }
      }
    },
    input_processors: [],
    enabled: true
  },
  {
    name: "Deduplicate Subprocessors",
    description: "Identifies duplicate subprocessor pages in an Obsidian folder for merging.",
    system_prompt: "You are an AI assistant specialized in data organization and deduplication for Obsidian notes. Your task is to analyze a list of 'subprocessor_pages' and identify duplicates based on their name and aliases.",
    user_prompt: "Analyze the following list of subprocessor pages and identify any duplicates. For each set, determine a survivor and list the others to be merged.\n\nInput: {subprocessor_pages} (A list of objects, each with 'file_path', 'page_name', 'aliases').\n\nProcess:\n1. Normalize all names and aliases (lowercase, remove suffixes like 'inc', 'llc', 'corp', and generic terms like 'technologies', 'solutions').\n2. Group pages with identical or highly similar normalized identifiers.\n3. For each group, select one 'survivor' based on the most canonical name, highest alias count, or simplest file path.\n\nOutput: Return a JSON object with a 'deduplication_results' list. Each item should contain 'survivor_file_path', a 'duplicate_file_paths' list, and 'reasoning_for_survivor_choice'.",
    llm_model_id: "01965cb4-73f4-9ec3-6f21-bede0391e2b4",
    output_format: {
      deduplication_results: {
        type: "list",
        item_type: "object",
        nested_structure: {
          survivor_file_path: { type: "string" },
          duplicate_file_paths: { type: "list", item_type: "string" },
          reasoning_for_survivor_choice: { type: "string" }
        }
      }
    },
    input_processors: [],
    enabled: true
  },
  {
    name: "DDG SERP Parser",
    description: "Parses a DuckDuckGo search results page and returns a filtered list of relevant URLs.",
    system_prompt: "You are an AI assistant that functions as an expert web scraper and data extractor. Your primary goal is to analyze the provided HTML content of a search engine results page (SERP) from DuckDuckGo and extract individual organic search results.",
    user_prompt: "The input parameter '{search_url_to_process}' contains the full HTML content of a DuckDuckGo search results page. Your task is to meticulously parse this HTML and extract each organic search result's 'title', 'url', and 'snippet'. Return your findings as a JSON object with a key 'search_results', which holds a list of objects.",
    llm_model_id: "01965cb4-73f4-9ec3-6f21-bede0391e2b4",
    output_format: {
      search_results: {
        type: "list",
        item_type: "object",
        nested_structure: { title: { type: "string" }, url: { type: "string" }, snippet: { type: "string" } }
      }
    },
    input_processors: [
      { param_name: "search_url_to_process", input_processor: "url_fetcher", config: { extract_text: true } }
    ],
    enabled: true
  },
  {
    name: "Find DPA URL",
    description: "Finds the canonical URL for a company's Data Processing Agreement (DPA).",
    system_prompt: "You are a specialized AI assistant proficient in legal document retrieval. Focus on quickly identifying and validating the official DPA URL using efficient search strategies.",
    user_prompt: `Your sole purpose is to find the canonical URL for the Data Processing Agreement (DPA) of the given {company_name}. Formulate precise search queries (e.g., '"{company_name}" data processing agreement'), prioritize links from the company's official domains, and verify the page contains the actual DPA document. Your response MUST be a single, valid JSON object with one key: 'url'. If not found, the value must be null.`,
    llm_model_id: "01965cb4-73f4-9ec3-6f21-bede0391e2b4",
    output_format: { url: "string" },
    input_processors: [],
    enabled: true
  },
  {
    name: "Find ToS URL",
    description: "Finds the canonical URL for a company's Terms of Service (ToS).",
    system_prompt: "You are a highly skilled web researcher, adept at navigating complex websites and legal documents. Focus on identifying the most relevant URL for a company's official Terms of Service.",
    user_prompt: "Your sole purpose is to find the canonical URL for the main customer Terms of Service (ToS) of the given {company_name}. Be aware of alternate names like 'Master Service Agreement' or 'General Terms.' Prioritize official domains and ensure the page contains the actual legal agreement, not a summary. Your response MUST be a single, valid JSON object with one key: 'url'. If not found, the value must be null.",
    llm_model_id: "01965cb4-73f4-9ec3-6f21-bede0391e2b4",
    output_format: { url: "string" },
    input_processors: [],
    enabled: true
  },
  {
    name: "Find Security Page URL",
    description: "Finds the canonical URL for a company's primary Security or Trust page.",
    system_prompt: "You are a world-class cybersecurity researcher, skilled at finding key information. Locate the most authoritative security information source and return the URL.",
    user_prompt: "Find the canonical URL for the primary Security or Trust page of the given {company_name}. These pages serve as central repositories for security practices and certifications. Prioritize official domains (e.g., company.com, trust.company.com) and pages that comprehensively address security. Your response MUST be a single, valid JSON object with one key: 'url'. If not found, the value must be null.",
    llm_model_id: "01965cb4-73f4-9ec3-6f21-bede0391e2b4",
    output_format: { url: "string" },
    input_processors: [],
    enabled: true
  }
];

// main.ts
var SUBPROCESSOR_URL_KEYWORDS = [
  "subprocessor",
  "sub-processor",
  "sub_processor",
  "vendor-list",
  "vendorlist",
  "third-party-list",
  "thirdpartylist",
  "service-providers",
  "serviceproviders",
  "dpa-exhibit",
  "dpa/exhibit",
  "data-processing-addendum/exhibit",
  "trust-center/sub",
  "legal/subprocessors"
];
var DEFAULT_SETTINGS = {
  serpApiKey: "",
  rightbrainClientId: "",
  rightbrainClientSecret: "",
  rightbrainOrgId: "",
  rightbrainProjectId: "",
  rightbrainApiUrl: "https://app.rightbrain.ai/api/v1",
  rightbrainOauth2Url: "https://oauth.rightbrain.ai",
  rightbrainVerifyUrlTaskId: "",
  rightbrainExtractEntitiesTaskId: "",
  rightbrainExtractInputField: "page_text",
  rightbrainExtractOutputThirdPartyField: "third_party_subprocessors",
  rightbrainExtractOutputOwnEntitiesField: "own_entities",
  rightbrainDeduplicateSubprocessorsTaskId: "",
  rightbrainDuckDuckGoSearchTaskId: "",
  createPagesForOwnEntities: false,
  verboseDebug: false,
  maxResultsPerProcessor: 1,
  maxRecursiveDepth: 2,
  discoveryCacheDays: 30,
  processorsFolderPath: "Processors",
  analysisLogsFolderPath: "Analysis Logs",
  rightbrainFindDpaTaskId: "",
  rightbrainFindTosTaskId: "",
  rightbrainFindSecurityTaskId: ""
};
var ProcessorProcessorPlugin = class extends import_obsidian.Plugin {
  async onload() {
    this.processedInCurrentRecursiveSearch = /* @__PURE__ */ new Set();
    await this.loadSettings();
    this.addRibbonIcon("link", "Manually Add Subprocessor List URL", (evt) => {
      new ManualInputModal(this.app, async (processorName, listUrl, isPrimary) => {
        if (processorName && listUrl) {
          new import_obsidian.Notice(`Processing manual URL input for: ${processorName}`);
          const processorFile = await this.ensureProcessorFile(processorName, true, isPrimary);
          if (processorFile) {
            const searchData = await this.fetchDataFromDirectUrl(processorName, listUrl);
            if (searchData) {
              await this.persistSubprocessorInfo(processorName, processorFile, searchData, isPrimary);
              if (searchData.flaggedCandidateUrlCount > 0) {
                new import_obsidian.Notice(`${searchData.flaggedCandidateUrlCount} URL(s) looked promising but couldn't be verified. Check logs.`);
              }
            } else {
              new import_obsidian.Notice(`Could not process data from direct URL for ${processorName}.`);
            }
          } else {
            new import_obsidian.Notice(`Could not create or find file for ${processorName} in ${this.settings.processorsFolderPath}`);
          }
        }
      }).open();
    });
    this.addRibbonIcon("paste", "Input Subprocessor List from Text", (evt) => {
      this.openManualTextEntryModal();
    });
    this.addCommand({
      id: "run-processor-search-global",
      name: "Search for Subprocessors (Discover)",
      callback: () => {
        new SearchModal(this.app, this.settings, async (processorName) => {
          if (processorName) {
            new import_obsidian.Notice(`Starting discovery search for: ${processorName}`);
            const processorFile = await this.ensureProcessorFile(processorName, true);
            if (processorFile) {
              await this.discoverAndProcessProcessorPage(processorName, processorFile);
            } else {
              new import_obsidian.Notice(`Could not create or find file for ${processorName} in ${this.settings.processorsFolderPath}`);
            }
          }
        }).open();
      }
    });
    this.addCommand({
      id: "input-subprocessor-list-from-text",
      name: "Input Subprocessor List from Text",
      callback: () => {
        this.openManualTextEntryModal();
      }
    });
    this.addCommand({
      id: "run-processor-search-recursive",
      // New ID
      name: "Search for Subprocessors (Recursive Discover)",
      callback: () => {
        new SearchModal(this.app, this.settings, async (processorName) => {
          if (processorName) {
            await this.discoverRecursively(processorName, void 0, this.plugin.settings.maxRecursiveDepth);
          }
        }).open();
      }
    });
    this.addCommand({
      id: "force-merge-processors-from-palette",
      name: "Force Merge processor files...",
      callback: () => {
        this.openFileSelectorMergeModal();
      }
    });
    this.addCommand({
      id: "complete-first-time-setup",
      name: "Complete First-Time Setup (Credentials & Tasks)",
      callback: () => {
        new PasteEnvModal(this.app, this).open();
      }
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, fileOrFolder, source) => {
        if (fileOrFolder instanceof import_obsidian.TFolder) {
          const folder = fileOrFolder;
          if (folder.path === this.settings.processorsFolderPath) {
            menu.addItem((item) => {
              item.setTitle("Deduplicate Subprocessor Pages").setIcon("git-pull-request-draft").onClick(async () => {
                if (!this.settings.rightbrainDeduplicateSubprocessorsTaskId) {
                  new import_obsidian.Notice("Deduplication Task ID not set in plugin settings.");
                  return;
                }
                new import_obsidian.Notice(`Starting deduplication for folder: ${folder.path}`);
                await this.runDeduplicationForFolder(folder);
              });
            });
          }
        } else if (fileOrFolder instanceof import_obsidian.TFile && fileOrFolder.extension === "md") {
          const file = fileOrFolder;
          if (file.path.startsWith(this.settings.processorsFolderPath + "/")) {
            const fileCache = this.app.metadataCache.getFileCache(file);
            const frontmatter = fileCache == null ? void 0 : fileCache.frontmatter;
            const originalProcessorName = (frontmatter == null ? void 0 : frontmatter.aliases) && Array.isArray(frontmatter.aliases) && frontmatter.aliases.length > 0 ? frontmatter.aliases[0] : file.basename;
            menu.addItem((item) => {
              item.setTitle("Map Subprocessor Relationships").setIcon("chevrons-down-up").onClick(async () => {
                new import_obsidian.Notice(`Starting recursive discovery from: ${originalProcessorName}`);
                await this.discoverRecursively(originalProcessorName, file, this.settings.maxRecursiveDepth);
              });
            });
            menu.addItem((item) => {
              item.setTitle("Discover Subprocessor List").setIcon("wand").onClick(async () => {
                new import_obsidian.Notice(`Discovering subprocessor list for: ${originalProcessorName}`);
                await this.discoverAndProcessProcessorPage(originalProcessorName, file);
              });
            });
            menu.addItem((item) => {
              item.setTitle("Enrich Processor Documentation").setIcon("book-plus").onClick(async () => {
                new import_obsidian.Notice(`Enriching documentation for: ${originalProcessorName}`);
                await this.enrichProcessorFile(originalProcessorName, file);
              });
            });
            menu.addItem((item) => {
              item.setTitle("Add Subprocessor List URL").setIcon("plus-circle").onClick(async () => {
                new ManualInputModal(this.app, async (pName, listUrl, isPrimary) => {
                  if (listUrl) {
                    new import_obsidian.Notice(`Processing manual URL input for: ${originalProcessorName} using URL: ${listUrl}`);
                    const searchData = await this.fetchDataFromDirectUrl(originalProcessorName, listUrl);
                    if (searchData) {
                      await this.persistSubprocessorInfo(originalProcessorName, file, searchData, isPrimary);
                      if (searchData.flaggedCandidateUrlCount > 0) {
                        new import_obsidian.Notice(`${searchData.flaggedCandidateUrlCount} URL(s) looked promising but couldn't be verified. Check logs.`);
                      }
                    } else {
                      new import_obsidian.Notice(`Could not process data from direct URL for ${originalProcessorName}.`);
                    }
                  }
                }, originalProcessorName).open();
              });
            });
            menu.addItem((item) => {
              item.setTitle("Input Subprocessor List from Text").setIcon("file-input").onClick(async () => {
                this.openManualTextEntryModal(originalProcessorName);
              });
            });
          }
        }
      })
    );
    this.addSettingTab(new ProcessorProcessorSettingTab(this.app, this));
    console.log("Processor Processor plugin loaded.");
  }
  onunload() {
    console.log("Processor Processor plugin unloaded.");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  openManualTextEntryModal(initialProcessorName) {
    if (!this.settings.rightbrainExtractEntitiesTaskId) {
      new import_obsidian.Notice("RightBrain Task ID for entity extraction is not configured. Please set it in plugin settings.");
      return;
    }
    new ManualTextEntryModal(this.app, async (processorName, pastedText, isPrimary) => {
      if (processorName && pastedText) {
        new import_obsidian.Notice(`Processing pasted text for: ${processorName}`);
        const processorFile = await this.ensureProcessorFile(processorName, true, isPrimary);
        if (processorFile) {
          const searchData = await this.fetchDataFromPastedText(processorName, pastedText);
          if (searchData) {
            await this.persistSubprocessorInfo(processorName, processorFile, searchData, isPrimary);
          } else {
            new import_obsidian.Notice(`Could not process data from pasted text for ${processorName}.`);
          }
        } else {
          new import_obsidian.Notice(`Could not create or find file for ${processorName} in ${this.settings.processorsFolderPath}`);
        }
      }
    }, initialProcessorName).open();
  }
  sanitizeNameForFilePathAndAlias(entityName) {
    const originalName = (entityName || "Unknown Entity").trim();
    let baseNameForFile = originalName;
    const dbaRegex = /^(.*?)\s+(?:dba|d\/b\/a|doing business as)\s+(.*)$/i;
    const dbaMatch = originalName.match(dbaRegex);
    if (dbaMatch && dbaMatch[2]) {
      baseNameForFile = dbaMatch[2].trim();
    }
    let filePathName = baseNameForFile.replace(/,/g, "");
    filePathName = filePathName.replace(/[\\/:*?"<>|]/g, "").trim();
    if (!filePathName) {
      filePathName = originalName.replace(/[\\/:*?"<>|,]/g, "").replace(/\s+/g, "_") || "Sanitized_Entity";
    }
    if (!filePathName) {
      filePathName = "Sanitized_Entity_" + Date.now();
    }
    return {
      filePathName,
      originalNameAsAlias: originalName
      // The original full name is always used as an alias
    };
  }
  scrubHyperlinks(text) {
    if (!text) return "N/A";
    let scrubbedText = String(text);
    scrubbedText = scrubbedText.replace(/\[(.*?)\]\((?:.*?)\)/g, "$1");
    scrubbedText = scrubbedText.replace(/<a[^>]*>(.*?)<\/a>/gi, "$1");
    scrubbedText = scrubbedText.replace(/<[^>]+>/g, "");
    scrubbedText = scrubbedText.replace(/\s+/g, " ").trim();
    return scrubbedText || "N/A";
  }
  addRelationship(collectedRelationships, seenRelationships, processorName, entity, type, sourceUrl, verificationReasoning) {
    var _a;
    const originalEntityName = (_a = entity.name) == null ? void 0 : _a.trim();
    if (!originalEntityName) return 0;
    const subprocessorNameToStore = originalEntityName;
    if (processorName.toLowerCase() === "openai" && type === "is_own_entity") {
      const openaiAffiliates = ["openai global", "openai, opco", "openai ireland", "openai uk", "openai japan", "openaiglobal", "openai opco", "openai llc"];
      if (openaiAffiliates.some((aff) => originalEntityName.toLowerCase().includes(aff)) || originalEntityName.toLowerCase() === "openai") {
        return 0;
      }
    }
    const relTuple = `${processorName}|${subprocessorNameToStore}|${type}`;
    if (!seenRelationships.has(relTuple)) {
      collectedRelationships.push({
        PrimaryProcessor: processorName,
        SubprocessorName: subprocessorNameToStore,
        // Store the original name
        ProcessingFunction: this.scrubHyperlinks(entity.processing_function),
        Location: this.scrubHyperlinks(entity.location),
        RelationshipType: type,
        SourceURL: sourceUrl,
        VerificationReasoning: this.scrubHyperlinks(verificationReasoning)
      });
      seenRelationships.add(relTuple);
      return 1;
    }
    return 0;
  }
  async discoverAndProcessProcessorPage(processorName, processorFile) {
    new import_obsidian.Notice(`Processing (discovery): ${processorName}...`);
    const searchData = await this.fetchProcessorSearchDataWithDiscovery(processorName);
    if (searchData) {
      await this.persistSubprocessorInfo(processorName, processorFile, searchData);
      if (searchData.flaggedCandidateUrlCount > 0) {
        new import_obsidian.Notice(`${searchData.flaggedCandidateUrlCount} URL(s) looked promising but couldn't be verified. Check Analysis Log for details and consider using the 'Input from Text' feature.`);
      }
    } else {
      new import_obsidian.Notice(`Failed to fetch data via discovery for ${processorName}.`);
    }
  }
  async enrichProcessorFile(processorName, file) {
    var _a;
    new import_obsidian.Notice(`Fetching compliance documents for ${processorName}...`, 5e3);
    const rbToken = await this.getRightBrainAccessToken();
    if (!rbToken) {
      new import_obsidian.Notice("Failed to get RightBrain token. Aborting enrichment.");
      return;
    }
    const documentTypes = [
      { type: "DPA", taskId: this.settings.rightbrainFindDpaTaskId, title: "Data Processing Agreement" },
      { type: "ToS", taskId: this.settings.rightbrainFindTosTaskId, title: "Terms of Service" },
      { type: "Security", taskId: this.settings.rightbrainFindSecurityTaskId, title: "Security Documentation" }
    ];
    const foundDocuments = [];
    for (const doc of documentTypes) {
      if (!doc.taskId) {
        if (this.settings.verboseDebug) console.log(`Skipping ${doc.type} search for ${processorName}, no Task ID set.`);
        continue;
      }
      const taskInputPayload = { "company_name": processorName };
      const taskResult = await this.callRightBrainTask(doc.taskId, taskInputPayload, rbToken);
      if (((_a = taskResult == null ? void 0 : taskResult.response) == null ? void 0 : _a.url) && this.isValidUrl(taskResult.response.url)) {
        foundDocuments.push({ title: doc.title, url: taskResult.response.url });
        if (this.settings.verboseDebug) console.log(`Found ${doc.type} for ${processorName}: ${taskResult.response.url}`);
      } else {
        if (this.settings.verboseDebug) console.warn(`Could not find valid URL for ${doc.type} for ${processorName}. Result:`, taskResult);
      }
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
    if (foundDocuments.length === 0) {
      new import_obsidian.Notice(`No new compliance documents found for ${processorName}.`);
      return;
    }
    let markdownContent = "\n";
    foundDocuments.forEach((doc) => {
      markdownContent += `- **${doc.title}:** [${doc.url}](${doc.url})
`;
    });
    const heading = "Compliance Documentation";
    await this.app.vault.process(file, (content) => {
      return this.ensureHeadingAndSection(content, heading, markdownContent, null, null, true);
    });
    new import_obsidian.Notice(`Successfully added ${foundDocuments.length} document link(s) to ${processorName}.`);
  }
  async setupRightBrainTasks(creds) {
    new import_obsidian.Notice("Starting RightBrain task setup...", 3e3);
    const rbToken = await this.getRightBrainAccessToken(creds);
    if (!rbToken) {
      new import_obsidian.Notice("Setup failed: Could not get RightBrain Access Token with provided credentials.");
      return;
    }
    const existingTasks = await this.listAllRightBrainTasks(rbToken, creds);
    if (existingTasks === null) {
      new import_obsidian.Notice("Setup failed: Could not retrieve existing tasks from RightBrain.");
      return;
    }
    const existingTaskNames = new Set(existingTasks.map((task) => task.name));
    let tasksCreated = 0;
    let tasksSkipped = 0;
    for (const taskDef of task_definitions_default) {
      if (existingTaskNames.has(taskDef.name)) {
        new import_obsidian.Notice(`Task '${taskDef.name}' already exists. Skipping.`);
        tasksSkipped++;
      } else {
        new import_obsidian.Notice(`Creating task: '${taskDef.name}'...`);
        const createdTask = await this.createRightBrainTask(rbToken, taskDef, creds);
        if (createdTask) {
          tasksCreated++;
        }
      }
    }
    new import_obsidian.Notice(`Setup complete. Created: ${tasksCreated} task(s), Skipped: ${tasksSkipped} existing task(s).`, 1e4);
  }
  /**
   * Fetches a list of all tasks from the configured RightBrain project.
   * @param rbToken The RightBrain access token.
   * @returns An array of task objects or null if an error occurs.
   */
  async listAllRightBrainTasks(rbToken, creds) {
    const tasksUrl = `${creds.apiUrl}/org/${creds.orgId}/project/${creds.projectId}/task`;
    const headers = { "Authorization": `Bearer ${rbToken}` };
    try {
      const response = await (0, import_obsidian.requestUrl)({ url: tasksUrl, method: "GET", headers, throw: false });
      if (response.status === 200) {
        return response.json.tasks || [];
      } else {
        console.error("Failed to list RightBrain tasks:", response.status, response.text);
        return null;
      }
    } catch (error) {
      console.error("Error fetching RightBrain tasks:", error);
      return null;
    }
  }
  /**
   * Creates a single new task in RightBrain using a provided definition.
   * @param rbToken The RightBrain access token.
   * @param taskDefinition An object containing the full configuration for the new task.
   * @returns The created task object or null if an error occurs.
   */
  async createRightBrainTask(rbToken, taskDefinition, creds) {
    const createUrl = `${creds.apiUrl}/org/${creds.orgId}/project/${creds.projectId}/task`;
    const headers = {
      "Authorization": `Bearer ${rbToken}`,
      "Content-Type": "application/json"
    };
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: createUrl,
        method: "POST",
        headers,
        body: JSON.stringify(taskDefinition),
        throw: false
      });
      if (response.status === 201 || response.status === 200) {
        new import_obsidian.Notice(`Successfully created task: '${taskDefinition.name}'`);
        return response.json;
      } else {
        new import_obsidian.Notice(`Failed to create task '${taskDefinition.name}': ${response.status}`, 7e3);
        console.error(`Error creating task '${taskDefinition.name}':`, response.status, response.text);
        return null;
      }
    } catch (error) {
      console.error(`Network error creating task '${taskDefinition.name}':`, error);
      return null;
    }
  }
  async persistSubprocessorInfo(processorName, processorFile, searchData, isTopLevelProcessor = true, mergeDecisions = []) {
    new import_obsidian.Notice(`Persisting info for: ${processorName}...`);
    await this.ensureFolderExists(this.settings.processorsFolderPath);
    await this.ensureFolderExists(this.settings.analysisLogsFolderPath);
    const { collectedRelationships, processedUrlDetails } = searchData;
    await this.updateProcessorFile(processorFile, processorName, collectedRelationships, isTopLevelProcessor);
    const uniqueTargetEntityOriginalNames = Array.from(new Set(collectedRelationships.map((r) => r.SubprocessorName)));
    const createdPagesForThisRun = /* @__PURE__ */ new Set();
    for (const targetEntityOriginalName of uniqueTargetEntityOriginalNames) {
      const { filePathName: targetEntityFilePathName } = this.sanitizeNameForFilePathAndAlias(targetEntityOriginalName);
      if (createdPagesForThisRun.has(targetEntityFilePathName)) {
        continue;
      }
      const relationsWhereThisEntityIsTarget = collectedRelationships.filter((r) => r.SubprocessorName === targetEntityOriginalName);
      if (relationsWhereThisEntityIsTarget.length === 0) {
        continue;
      }
      const isEverUsedAsSubprocessor = relationsWhereThisEntityIsTarget.some((r) => r.RelationshipType === "uses_subprocessor");
      const isOwnEntityOfCurrentPrimaryProcessor = relationsWhereThisEntityIsTarget.some(
        (r) => r.PrimaryProcessor === processorName && r.RelationshipType === "is_own_entity"
      );
      let shouldCreatePage = false;
      if (isEverUsedAsSubprocessor) {
        shouldCreatePage = true;
      } else if (isOwnEntityOfCurrentPrimaryProcessor) {
        if (this.settings.createPagesForOwnEntities) {
          shouldCreatePage = true;
        } else {
        }
      }
      if (shouldCreatePage) {
        const clientRelationshipsForTargetEntityPage = collectedRelationships.filter(
          (r) => r.SubprocessorName === targetEntityOriginalName && r.RelationshipType === "uses_subprocessor"
        );
        await this.createOrUpdateSubprocessorFile(
          targetEntityOriginalName,
          // The name of the subprocessor/own_entity itself
          processorName,
          // The primary processor context (for logging/tracking, not for content of subprocessor's page directly)
          clientRelationshipsForTargetEntityPage
          // Relationships where this entity is the subprocessor
        );
        createdPagesForThisRun.add(targetEntityFilePathName);
      }
    }
    await this.updateAnalysisLogPage(processorName, processedUrlDetails, collectedRelationships, mergeDecisions);
    new import_obsidian.Notice(`Finished persisting info for ${processorName}.`);
  }
  async searchViaRightBrainDuckDuckGo(processorName, rbToken) {
    var _a;
    if (!this.settings.rightbrainDuckDuckGoSearchTaskId) {
      new import_obsidian.Notice("DuckDuckGo Search Task ID is not configured. Please run the setup command or configure it in settings.", 1e4);
      return [];
    }
    const searchTaskId = this.settings.rightbrainDuckDuckGoSearchTaskId;
    const searchQueries = this.generateSearchQueries(processorName);
    const allResults = [];
    const queriesToProcess = searchQueries.slice(0, Math.min(searchQueries.length, 2));
    new import_obsidian.Notice(`Performing up to ${queriesToProcess.length} DuckDuckGo searches for ${processorName}...`, 5e3);
    for (const query of queriesToProcess) {
      const duckDuckGoUrl = `https://duckduckgo.com/?q=${encodeURIComponent(query)}&ia=web&kl=us-en&kp=-2`;
      const taskInputPayload = {
        search_url_to_process: duckDuckGoUrl,
        target_company_name: processorName
      };
      if (this.settings.verboseDebug) {
        console.log(`Calling RightBrain Task ${searchTaskId} for DDG search. URL: ${duckDuckGoUrl}, Target: ${processorName}`);
      }
      const taskRunResult = await this.callRightBrainTask(searchTaskId, taskInputPayload, rbToken);
      if (this.settings.verboseDebug && taskRunResult) {
        console.log(`Full RightBrain Response for DDG search query "${query}":`, JSON.stringify(taskRunResult, null, 2));
      }
      if (((_a = taskRunResult == null ? void 0 : taskRunResult.response) == null ? void 0 : _a.search_results) && Array.isArray(taskRunResult.response.search_results)) {
        const resultsList = taskRunResult.response.search_results;
        for (const result of resultsList) {
          if (result.url && result.title && (String(result.url).startsWith("http://") || String(result.url).startsWith("https://"))) {
            allResults.push({
              processorName,
              searchQuery: query,
              title: String(result.title),
              url: String(result.url),
              snippet: String(result.snippet || ""),
              documentType: "duckduckgo_rb_search_result"
            });
          }
        }
        if (this.settings.verboseDebug) {
          console.log(`Successfully processed ${resultsList.length} search results for query "${query}"`);
        }
      } else {
        new import_obsidian.Notice(`DDG search via RB for "${query.substring(0, 20)}..." yielded no valid results.`, 3e3);
        if (this.settings.verboseDebug) {
          console.warn(`RB Task for DDG Search for query "${query}" did not return expected '{ "search_results": [...] }' array or failed. Full taskRunResult:`, taskRunResult);
        }
      }
      await new Promise((resolve) => setTimeout(resolve, 700 + Math.random() * 500));
    }
    if (this.settings.verboseDebug) console.log(`searchViaRightBrainDuckDuckGo collected ${allResults.length} filtered candidates for ${processorName}`);
    return allResults;
  }
  async fetchProcessorSearchDataWithDiscovery(processorName) {
    const collectedRelationships = [];
    const seenRelationshipsInCurrentSearch = /* @__PURE__ */ new Set();
    const processedUrlDetails = [];
    let candidateUrlsInfo = [];
    let flaggedCandidateUrlCount = 0;
    const rbToken = await this.getRightBrainAccessToken();
    if (!rbToken) {
      new import_obsidian.Notice("Could not get RightBrain Access Token. Aborting discovery.", 7e3);
      return null;
    }
    if (this.settings.serpApiKey) {
      new import_obsidian.Notice(`Using SerpAPI for primary search for: ${processorName}`, 5e3);
      const searchQueries = this.generateSearchQueries(processorName);
      const serpApiResults = await this.searchSerpApiForDpas(processorName, searchQueries, this.settings.maxResultsPerProcessor);
      candidateUrlsInfo.push(...serpApiResults);
    } else if (this.settings.rightbrainOrgId && this.settings.rightbrainProjectId) {
      new import_obsidian.Notice(`SerpAPI key not configured. Using DuckDuckGo (Filtered Extractor Task) via RightBrain for: ${processorName}`, 5e3);
      candidateUrlsInfo = await this.searchViaRightBrainDuckDuckGo(processorName, rbToken);
    } else {
      new import_obsidian.Notice("No search method configured (SerpAPI or RightBrain for DDG). Aborting discovery.", 7e3);
    }
    const hardcodedTestUrls = {
      // "openai": [{ title: "Test OpenAI SubP List", url: "https://example.com/openai-subp", snippet: "", processorName: "openai", documentType: "hardcoded_test" }],
    };
    if (this.settings.verboseDebug && hardcodedTestUrls[processorName.toLowerCase()]) {
      if (this.settings.verboseDebug) console.log(`Adding hardcoded test URLs for ${processorName}`);
      candidateUrlsInfo.push(...hardcodedTestUrls[processorName.toLowerCase()]);
    }
    const additionalUrlsFromCandidatePages = [];
    const pagesToScanForMoreLinks = candidateUrlsInfo.filter(
      (item) => item.documentType === "dpa_or_subprocessor_list" || SUBPROCESSOR_URL_KEYWORDS.some((kw) => item.url.toLowerCase().includes(kw))
    );
    for (const pageItem of pagesToScanForMoreLinks) {
      const extracted = await this.extractUrlsFromDpaPage(pageItem.url, processorName, pageItem.title);
      additionalUrlsFromCandidatePages.push(...extracted);
    }
    candidateUrlsInfo.push(...additionalUrlsFromCandidatePages);
    const uniqueCandidateUrls = /* @__PURE__ */ new Map();
    candidateUrlsInfo.forEach((item) => {
      if (item.url && (item.url.startsWith("http://") || item.url.startsWith("https://")) && !uniqueCandidateUrls.has(item.url.replace(/\/$/, ""))) {
        uniqueCandidateUrls.set(item.url.replace(/\/$/, ""), item);
      }
    });
    const uniqueUrlsToProcess = Array.from(uniqueCandidateUrls.values());
    if (this.settings.verboseDebug) console.log(`Total unique URLs to verify for ${processorName}: ${uniqueUrlsToProcess.length}`);
    if (uniqueUrlsToProcess.length === 0 && candidateUrlsInfo.length > 0) {
      if (this.settings.verboseDebug) console.warn(`All candidate URLs were invalid or duplicates for ${processorName}. Original count: ${candidateUrlsInfo.length}`);
    } else if (uniqueUrlsToProcess.length === 0) {
      new import_obsidian.Notice(`No candidate URLs found to process for ${processorName}.`);
    }
    for (const urlInfo of uniqueUrlsToProcess) {
      if (processedUrlDetails.some((p) => p.url.replace(/\/$/, "") === urlInfo.url.replace(/\/$/, ""))) {
        if (this.settings.verboseDebug) console.log(`URL ${urlInfo.url} already processed in processedUrlDetails, skipping re-verification.`);
        continue;
      }
      let currentUrlExtractedCount = 0;
      let currentProcessedUrlInfo = { ...urlInfo, documentType: urlInfo.documentType || "duckduckgo_rb_search_result" };
      const verificationResult = await this.verifySubprocessorListUrl(urlInfo.url, processorName, rbToken);
      currentProcessedUrlInfo = {
        ...currentProcessedUrlInfo,
        verificationMethod: "rightbrain",
        isList: (verificationResult == null ? void 0 : verificationResult.isList) || false,
        isCurrent: (verificationResult == null ? void 0 : verificationResult.isCurrent) || false,
        verificationReasoning: (verificationResult == null ? void 0 : verificationResult.reasoning) || "N/A"
      };
      if ((verificationResult == null ? void 0 : verificationResult.isList) && verificationResult.isCurrent && verificationResult.isCorrectProcessor) {
        currentProcessedUrlInfo.documentType = "verified_current_subprocessor_list";
        if (verificationResult.pageContent) {
          const extractionResult = await this.extractEntitiesFromPageContent(verificationResult.pageContent, rbToken);
          if (extractionResult) {
            const { thirdPartySubprocessors, ownEntities } = extractionResult;
            thirdPartySubprocessors.forEach((e) => {
              currentUrlExtractedCount += this.addRelationship(collectedRelationships, seenRelationshipsInCurrentSearch, processorName, e, "uses_subprocessor", urlInfo.url, verificationResult.reasoning);
            });
            ownEntities.forEach((e) => {
              currentUrlExtractedCount += this.addRelationship(collectedRelationships, seenRelationshipsInCurrentSearch, processorName, e, "is_own_entity", urlInfo.url, verificationResult.reasoning);
            });
          } else {
            currentProcessedUrlInfo.documentType = "verified_current_subprocessor_list (rb_extraction_failed)";
          }
        } else {
          currentProcessedUrlInfo.documentType = "verified_current_subprocessor_list (no_content_for_extraction)";
        }
        currentProcessedUrlInfo.extractedSubprocessorsCount = currentUrlExtractedCount;
        processedUrlDetails.push(currentProcessedUrlInfo);
        if (currentUrlExtractedCount > 0) {
          if (this.settings.verboseDebug) console.log(`Found and processed a valid subprocessor list at ${urlInfo.url}. Stopping search.`);
          new import_obsidian.Notice(`Found valid list for ${processorName}. Finishing process.`);
          break;
        }
      } else {
        const urlLower = urlInfo.url.toLowerCase();
        const containsKeyword = SUBPROCESSOR_URL_KEYWORDS.some((keyword) => urlLower.includes(keyword));
        if (!(verificationResult == null ? void 0 : verificationResult.isList) && containsKeyword) {
          currentProcessedUrlInfo.documentType = "keyword_match_not_verified_list";
          flaggedCandidateUrlCount++;
        } else if ((verificationResult == null ? void 0 : verificationResult.isList) && !verificationResult.isCorrectProcessor) {
          currentProcessedUrlInfo.documentType = "verified_list_for_wrong_processor";
          flaggedCandidateUrlCount++;
        } else if (verificationResult == null ? void 0 : verificationResult.isList) {
          currentProcessedUrlInfo.documentType = "verified_subprocessor_list (not_current)";
        } else {
          currentProcessedUrlInfo.documentType = "not_a_subprocessor_list";
        }
        currentProcessedUrlInfo.extractedSubprocessorsCount = 0;
        processedUrlDetails.push(currentProcessedUrlInfo);
      }
    }
    return { collectedRelationships, processedUrlDetails, flaggedCandidateUrlCount };
  }
  async fetchDataFromDirectUrl(processorName, listUrl) {
    if (this.settings.verboseDebug) console.log(`Fetching data from direct URL for ${processorName}: ${listUrl}`);
    if (!this.isValidUrl(listUrl, processorName)) {
      new import_obsidian.Notice(`The provided URL for ${processorName} is not valid: ${listUrl}`);
      return null;
    }
    const collectedRelationships = [];
    const seenRelationshipsInCurrentSearch = /* @__PURE__ */ new Set();
    const processedUrlDetails = [];
    let flaggedCandidateUrlCount = 0;
    const directUrlInfoBase = {
      // Base info for this manually provided URL
      title: `Manually Provided List for ${processorName}`,
      url: listUrl,
      snippet: "Manually provided URL",
      processorName,
      documentType: "direct_input_list"
    };
    let currentProcessedUrlInfo = { ...directUrlInfoBase, url: listUrl, documentType: "direct_input_list" };
    const rbToken = await this.getRightBrainAccessToken();
    if (!rbToken) {
      new import_obsidian.Notice("Could not obtain RightBrain token for direct URL processing.");
      currentProcessedUrlInfo.verificationMethod = "N/A (No RB Token)";
      processedUrlDetails.push(currentProcessedUrlInfo);
      return { collectedRelationships, processedUrlDetails, flaggedCandidateUrlCount };
    }
    let currentUrlExtractedCount = 0;
    const verificationResult = await this.verifySubprocessorListUrl(listUrl, processorName, rbToken);
    currentProcessedUrlInfo.verificationMethod = "rightbrain";
    currentProcessedUrlInfo.isList = (verificationResult == null ? void 0 : verificationResult.isList) || false;
    currentProcessedUrlInfo.isCurrent = (verificationResult == null ? void 0 : verificationResult.isCurrent) || false;
    currentProcessedUrlInfo.verificationReasoning = (verificationResult == null ? void 0 : verificationResult.reasoning) || "N/A";
    if (verificationResult && verificationResult.isList && verificationResult.isCurrent) {
      new import_obsidian.Notice(`Verified manual URL: ${listUrl} as current list.`);
      currentProcessedUrlInfo.documentType = "verified_current_subprocessor_list (manual_url_input)";
      if (verificationResult.pageContent) {
        const extractionResult = await this.extractEntitiesFromPageContent(verificationResult.pageContent, rbToken);
        if (extractionResult) {
          const { thirdPartySubprocessors, ownEntities } = extractionResult;
          thirdPartySubprocessors.forEach((e) => {
            currentUrlExtractedCount += this.addRelationship(collectedRelationships, seenRelationshipsInCurrentSearch, processorName, e, "uses_subprocessor", listUrl, verificationResult.reasoning);
          });
          ownEntities.forEach((e) => {
            currentUrlExtractedCount += this.addRelationship(collectedRelationships, seenRelationshipsInCurrentSearch, processorName, e, "is_own_entity", listUrl, verificationResult.reasoning);
          });
        } else {
          currentProcessedUrlInfo.documentType = "verified_current_subprocessor_list (manual_url_input_rb_extraction_failed)";
        }
      } else {
        currentProcessedUrlInfo.documentType = "verified_current_subprocessor_list (manual_url_input_no_content)";
      }
    } else {
      const urlLower = listUrl.toLowerCase();
      const containsKeyword = SUBPROCESSOR_URL_KEYWORDS.some((keyword) => urlLower.includes(keyword));
      if (!(verificationResult == null ? void 0 : verificationResult.isList) && containsKeyword) {
        currentProcessedUrlInfo.documentType = "keyword_match_not_verified_list (manual_url_input)";
        flaggedCandidateUrlCount++;
        new import_obsidian.Notice(`Manual URL ${listUrl} looks like a subprocessor list but couldn't be verified. Reason: ${this.scrubHyperlinks(verificationResult == null ? void 0 : verificationResult.reasoning) || "Details unavailable."}`);
        if (this.settings.verboseDebug) console.log(`Flagged Manual URL (keyword match, not verified): ${listUrl}`);
      } else if (verificationResult == null ? void 0 : verificationResult.isList) {
        currentProcessedUrlInfo.documentType = "verified_subprocessor_list (manual_url_input_not_current)";
        new import_obsidian.Notice(`Manual URL ${listUrl} verified as a list, but not current. Reason: ${this.scrubHyperlinks(verificationResult == null ? void 0 : verificationResult.reasoning) || "Details unavailable."}`);
      } else {
        currentProcessedUrlInfo.documentType = "not_a_subprocessor_list (manual_url_input)";
        new import_obsidian.Notice(`Manual URL ${listUrl} could not be verified as a list. Reason: ${this.scrubHyperlinks(verificationResult == null ? void 0 : verificationResult.reasoning) || "Details unavailable."}`);
      }
    }
    currentProcessedUrlInfo.extractedSubprocessorsCount = currentUrlExtractedCount;
    processedUrlDetails.push(currentProcessedUrlInfo);
    return { collectedRelationships, processedUrlDetails, flaggedCandidateUrlCount };
  }
  async fetchDataFromPastedText(processorName, pastedText) {
    if (this.settings.verboseDebug) console.log(`Fetching data from pasted text for ${processorName}`);
    if (!this.settings.rightbrainExtractEntitiesTaskId) {
      new import_obsidian.Notice("RightBrain Task ID for entity extraction is not configured. Please set it in plugin settings.");
      return null;
    }
    const collectedRelationships = [];
    const seenRelationshipsInCurrentSearch = /* @__PURE__ */ new Set();
    const processedUrlDetails = [];
    const rbToken = await this.getRightBrainAccessToken();
    if (!rbToken) {
      new import_obsidian.Notice("Could not obtain RightBrain token for pasted text processing.");
      processedUrlDetails.push({
        url: `text_input_for_${this.sanitizeNameForFilePathAndAlias(processorName).filePathName}`,
        // Placeholder URL for logging
        title: `Pasted Text for ${processorName}`,
        documentType: "manual_text_submission_failed (no_rb_token)"
        // No verification details applicable here as the process couldn't start
      });
      return { collectedRelationships, processedUrlDetails, flaggedCandidateUrlCount: 0 };
    }
    const taskInput = { [this.settings.rightbrainExtractInputField]: pastedText };
    const extractionResult = await this.callRightBrainTask(this.settings.rightbrainExtractEntitiesTaskId, taskInput, rbToken);
    let currentUrlExtractedCount = 0;
    const sourcePlaceholder = `manual_text_input:${processorName}`;
    if (extractionResult && typeof extractionResult.response === "object" && extractionResult.response !== null) {
      const rbResponse = extractionResult.response;
      const thirdParty = rbResponse[this.settings.rightbrainExtractOutputThirdPartyField] || [];
      const own = rbResponse[this.settings.rightbrainExtractOutputOwnEntitiesField] || [];
      thirdParty.forEach((e) => {
        currentUrlExtractedCount += this.addRelationship(collectedRelationships, seenRelationshipsInCurrentSearch, processorName, e, "uses_subprocessor", sourcePlaceholder, "Processed from manually pasted text.");
      });
      own.forEach((e) => {
        currentUrlExtractedCount += this.addRelationship(collectedRelationships, seenRelationshipsInCurrentSearch, processorName, e, "is_own_entity", sourcePlaceholder, "Processed from manually pasted text.");
      });
      processedUrlDetails.push({
        url: sourcePlaceholder,
        title: `Pasted Text for ${processorName}`,
        documentType: "manual_text_submission_processed",
        verificationMethod: "rightbrain_text_task",
        extractedSubprocessorsCount: currentUrlExtractedCount,
        verificationReasoning: `Extracted ${currentUrlExtractedCount} entities from pasted text.`
      });
    } else {
      new import_obsidian.Notice(`Failed to extract entities from pasted text for ${processorName}. Check console.`);
      console.error(`ProcessorProcessor: RB Extract From Text task did not return expected 'response' object or failed. Full task result:`, JSON.stringify(extractionResult).substring(0, 500));
      processedUrlDetails.push({
        url: sourcePlaceholder,
        title: `Pasted Text for ${processorName}`,
        documentType: "manual_text_submission_failed (rb_task_error)",
        verificationMethod: "rightbrain_text_task",
        verificationReasoning: "RightBrain task for text processing failed or returned an unexpected response."
      });
    }
    return { collectedRelationships, processedUrlDetails, flaggedCandidateUrlCount: 0 };
  }
  async ensureFolderExists(folderPath) {
    try {
      const normalizedPath = folderPath.startsWith("/") ? folderPath.substring(1) : folderPath;
      if (normalizedPath === "") return;
      const abstractFolderPath = this.app.vault.getAbstractFileByPath(normalizedPath);
      if (!abstractFolderPath) {
        await this.app.vault.createFolder(normalizedPath);
        if (this.settings.verboseDebug) console.log(`Folder created: ${normalizedPath}`);
      }
    } catch (e) {
      console.error(`Error ensuring folder ${folderPath} exists:`, e);
      new import_obsidian.Notice(`Error creating folder: ${folderPath}`);
    }
  }
  async ensureProcessorFile(originalProcessorName, addFrontmatter = false, isTopLevelProcessor = true) {
    var _a;
    await this.ensureFolderExists(this.settings.processorsFolderPath);
    const { filePathName, originalNameAsAlias } = this.sanitizeNameForFilePathAndAlias(originalProcessorName);
    const folder = this.settings.processorsFolderPath.startsWith("/") ? this.settings.processorsFolderPath.substring(1) : this.settings.processorsFolderPath;
    const filePath = `${folder}/${filePathName}.md`;
    let file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file) {
      try {
        let initialContent = "";
        if (addFrontmatter) {
          const tag = isTopLevelProcessor ? "processor" : "subprocessor";
          const aliasForFrontmatter = originalNameAsAlias.replace(/[:\[\],"]/g, "");
          initialContent = `---
tags: [${tag}]
aliases: ["${aliasForFrontmatter}"]
---

# ${originalNameAsAlias}

`;
        } else {
          initialContent = `# ${originalNameAsAlias}

`;
        }
        file = await this.app.vault.create(filePath, initialContent);
      } catch (e) {
        if ((_a = e.message) == null ? void 0 : _a.toLowerCase().includes("file already exists")) {
          file = this.app.vault.getAbstractFileByPath(filePath);
          if (!file) {
            console.error(`Failed to get file ${filePath} after 'already exists' error.`);
            return null;
          }
        } else {
          console.error(`Error creating processor file ${filePath}:`, e);
          return null;
        }
      }
    }
    if (file && addFrontmatter) {
      const tag = isTopLevelProcessor ? "processor" : "subprocessor";
      const aliasForFrontmatter = originalNameAsAlias.replace(/[:\[\],"]/g, "");
      await this.app.vault.process(file, (content) => {
        let newContent = this.updateFrontmatter(content, { tags: [tag], aliases: [aliasForFrontmatter] }, originalNameAsAlias);
        if (!newContent.trim().includes(`# ${originalNameAsAlias}`)) {
          const bodyStartIndex = newContent.indexOf("\n---") > 0 ? newContent.indexOf("\n---", newContent.indexOf("\n---") + 3) + 4 : 0;
          const body = newContent.substring(bodyStartIndex);
          const frontmatterPart = newContent.substring(0, bodyStartIndex);
          newContent = frontmatterPart + (frontmatterPart.endsWith("\n") ? "" : "\n") + `# ${originalNameAsAlias}

` + body.trimStart();
        }
        return newContent;
      });
    }
    return file;
  }
  async updateProcessorFile(file, originalProcessorName, relationships, isTopLevelProcessor) {
    const subprocessorsHeading = "Subprocessors";
    let tableMd = `| Subprocessor Entity Name | Processing Function | Location |
`;
    tableMd += `|---|---|---|
`;
    const relevantRelationships = relationships.filter((r) => r.RelationshipType === "uses_subprocessor" && r.PrimaryProcessor === originalProcessorName);
    relevantRelationships.forEach((rel) => {
      const { filePathName: subFilePathName, originalNameAsAlias: subOriginalName } = this.sanitizeNameForFilePathAndAlias(rel.SubprocessorName);
      const markdownAlias = subOriginalName.replace(/\n/g, " ").replace(/[\[\]()|]/g, "");
      const processorsFolder = this.settings.processorsFolderPath;
      const markdownLinkTarget = encodeURI(`${processorsFolder}/${subFilePathName}.md`);
      const subprocessorPageLink = `[${markdownAlias}](${markdownLinkTarget})`;
      const processingFunctionDisplay = (rel.ProcessingFunction || "N/A").replace(/\n/g, "<br>").replace(/\|/g, "\\|");
      const locationDisplay = (rel.Location || "N/A").replace(/\n/g, "<br>").replace(/\|/g, "\\|");
      tableMd += `| ${subprocessorPageLink} | ${processingFunctionDisplay} | ${locationDisplay} |
`;
    });
    const analysisLogsHeading = "Analysis Logs";
    const { filePathName: logFilePathNamePart } = this.sanitizeNameForFilePathAndAlias(originalProcessorName);
    const analysisLogsFolder = this.settings.analysisLogsFolderPath;
    const logFileName = `${logFilePathNamePart} Subprocessor Logs.md`;
    const logFileLinkTarget = encodeURI(`${analysisLogsFolder}/${logFileName}`);
    const logFileLink = `[[${analysisLogsFolder}/${logFileName}|${originalProcessorName} Subprocessor Logs]]`;
    const analysisLogSection = `
- ${logFileLink}
`;
    await this.app.vault.process(file, (content) => {
      const tag = isTopLevelProcessor ? "processor" : "subprocessor";
      let newContent = this.updateFrontmatter(content, { tags: [tag], aliases: [originalProcessorName.replace(/[:\[\],"]/g, "")] }, originalProcessorName);
      if (!newContent.trim().includes(`# ${originalProcessorName}`)) {
        const bodyStartIndex = newContent.indexOf("\n---") > 0 ? newContent.indexOf("\n---", newContent.indexOf("\n---") + 3) + 4 : 0;
        const body = newContent.substring(bodyStartIndex);
        const frontmatterPart = newContent.substring(0, bodyStartIndex);
        newContent = frontmatterPart + (frontmatterPart.endsWith("\n") ? "" : "\n") + `# ${originalProcessorName}

` + body.trimStart();
      }
      newContent = this.ensureHeadingAndSection(newContent, subprocessorsHeading, tableMd, null, null);
      newContent = this.ensureHeadingAndSection(newContent, analysisLogsHeading, analysisLogSection, null, null, true);
      return newContent;
    });
  }
  async createOrUpdateSubprocessorFile(originalSubprocessorName, originalPrimaryProcessorNameForContext, newClientRelationships) {
    var _a;
    await this.ensureFolderExists(this.settings.processorsFolderPath);
    const { filePathName: subFilePathName, originalNameAsAlias: subOriginalNameAsAlias } = this.sanitizeNameForFilePathAndAlias(originalSubprocessorName);
    const folder = this.settings.processorsFolderPath.startsWith("/") ? this.settings.processorsFolderPath.substring(1) : this.settings.processorsFolderPath;
    const subFilePath = `${folder}/${subFilePathName}.md`;
    let file = this.app.vault.getAbstractFileByPath(subFilePath);
    if (!file) {
      const aliasForFrontmatter = subOriginalNameAsAlias.replace(/[:\[\],"]/g, "");
      const initialContent = `---
tags: [subprocessor]
aliases: ["${aliasForFrontmatter}"]
---

# ${subOriginalNameAsAlias}

## Used By

`;
      try {
        file = await this.app.vault.create(subFilePath, initialContent);
      } catch (e) {
        if ((_a = e.message) == null ? void 0 : _a.toLowerCase().includes("file already exists")) {
          file = this.app.vault.getAbstractFileByPath(subFilePath);
          if (!file) {
            console.error(`Failed to get subprocessor file ${subFilePath} after 'already exists' error.`);
            return;
          }
        } else {
          console.error(`Error creating subprocessor file ${subFilePath}:`, e);
          return;
        }
      }
    }
    if (!file) return;
    await this.app.vault.process(file, (content) => {
      let newContent = this.updateFrontmatter(content, { tags: ["subprocessor"], aliases: [subOriginalNameAsAlias.replace(/[:\[\],"]/g, "")] }, subOriginalNameAsAlias);
      if (!newContent.trim().includes(`# ${subOriginalNameAsAlias}`)) {
        const bodyStartIndex = newContent.indexOf("\n---") > 0 ? newContent.indexOf("\n---", newContent.indexOf("\n---") + 3) + 4 : 0;
        const body = newContent.substring(bodyStartIndex);
        const frontmatterPart = newContent.substring(0, bodyStartIndex);
        newContent = frontmatterPart + (frontmatterPart.endsWith("\n") ? "" : "\n") + `# ${subOriginalNameAsAlias}

` + body.trimStart();
      }
      const usedByHeading = "Used By";
      const existingRows = this.extractClientTableRows(content);
      const allRows = new Set(existingRows);
      newClientRelationships.forEach((rel) => {
        const { originalNameAsAlias: primaryOriginalName } = this.sanitizeNameForFilePathAndAlias(rel.PrimaryProcessor);
        const primaryProcessorPlainText = primaryOriginalName.replace(/\|/g, "\\|");
        const processingFunctionDisplay = (rel.ProcessingFunction || "N/A").replace(/\n/g, "<br>").replace(/\|/g, "\\|");
        const locationDisplay = (rel.Location || "N/A").replace(/\n/g, "<br>").replace(/\|/g, "\\|");
        const sourceUrlLink = rel.SourceURL.startsWith("http") ? `[Source](${rel.SourceURL})` : rel.SourceURL;
        const rowContent = ` ${primaryProcessorPlainText} | ${processingFunctionDisplay} | ${locationDisplay} | ${sourceUrlLink} `;
        allRows.add(rowContent);
      });
      let clientTableMd = `| Primary Processor | Processing Function | Location | Source URL |
`;
      clientTableMd += `|---|---|---|---|
`;
      allRows.forEach((row) => {
        clientTableMd += `|${row}|
`;
      });
      newContent = this.ensureHeadingAndSection(newContent, usedByHeading, clientTableMd, null, null);
      return newContent;
    });
  }
  updateFrontmatter(content, updates, pageNameForAlias) {
    let fm = {};
    const fmRegex = /^---\s*\n([\s\S]*?)\n---\s*\n/;
    const match = content.match(fmRegex);
    let body = content;
    if (match && match[1]) {
      try {
        const yamlLines = match[1].split("\n");
        yamlLines.forEach((line) => {
          const parts = line.split(":");
          if (parts.length >= 2) {
            const key = parts[0].trim();
            const value = parts.slice(1).join(":").trim();
            if (key === "tags" || key === "aliases") {
              if (value.startsWith("[") && value.endsWith("]")) {
                fm[key] = value.substring(1, value.length - 1).split(",").map((s) => s.trim().replace(/^["']|["']$/g, ""));
              } else {
                fm[key] = [value.replace(/^["']|["']$/g, "")];
              }
            } else {
              fm[key] = value.replace(/^["']|["']$/g, "");
            }
          }
        });
      } catch (e) {
        console.warn("ProcessorProcessor: Could not parse existing frontmatter, will overwrite relevant keys.", e);
        fm = {};
      }
      body = content.substring(match[0].length);
    }
    if (updates.tags) {
      const currentTags = new Set(Array.isArray(fm.tags) ? fm.tags.map((t) => String(t).toLowerCase()) : []);
      updates.tags.forEach((tag) => currentTags.add(String(tag).toLowerCase()));
      fm.tags = Array.from(currentTags);
    }
    if (updates.aliases) {
      const currentAliases = new Set(Array.isArray(fm.aliases) ? fm.aliases.map((a) => String(a)) : []);
      updates.aliases.forEach((alias) => {
        const sanitizedAlias = String(alias).replace(/[:\[\],"]/g, "");
        if (sanitizedAlias) currentAliases.add(sanitizedAlias);
      });
      const sanitizedPageNameAlias = String(pageNameForAlias).replace(/[:\[\],"]/g, "");
      if (sanitizedPageNameAlias) currentAliases.add(sanitizedPageNameAlias);
      fm.aliases = Array.from(currentAliases);
    }
    let fmString = "---\n";
    for (const key in fm) {
      if (fm.hasOwnProperty(key)) {
        if (Array.isArray(fm[key])) {
          if (fm[key].length > 0) {
            fmString += `${key}: [${fm[key].map((item) => `"${item}"`).join(", ")}]
`;
          }
        } else {
          fmString += `${key}: "${fm[key]}"
`;
        }
      }
    }
    fmString += "---\n";
    if (fmString === "---\n---\n" && !match) {
      return body;
    }
    return fmString + body;
  }
  async updateAnalysisLogPage(processorName, processedUrls, relationships, mergeDecisions) {
    await this.ensureFolderExists(this.settings.analysisLogsFolderPath);
    const { filePathName: sanitizedProcessorNameForLogFile } = this.sanitizeNameForFilePathAndAlias(processorName);
    const logsFolder = this.settings.analysisLogsFolderPath;
    const logFileName = `${sanitizedProcessorNameForLogFile} Subprocessor Logs.md`;
    const logFilePath = `${logsFolder}/${logFileName}`;
    const logEntryContent = this.formatResultsForObsidianLog(processorName, relationships, processedUrls, mergeDecisions);
    await this.writeResultsToObsidianNote(logFilePath, logEntryContent, "ensure_exists_and_append", processorName);
  }
  ensureHeadingAndSection(content, headingText, sectionNewContent, startMarker = null, endMarker = null, appendUnderHeadingIfNoMarkers = false) {
    const headingRegex = new RegExp(`^(#+)\\s*${headingText.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}(\\s*\\n|$)`, "im");
    const headingMatch = content.match(headingRegex);
    const sectionWithHeading = `
## ${headingText}
${sectionNewContent.trim()}
`;
    if (startMarker && endMarker) {
      const startIdx = content.indexOf(startMarker);
      const endIdx = content.indexOf(endMarker);
      if (startIdx !== -1 && endIdx !== -1 && startIdx < endIdx) {
        return content.substring(0, startIdx + startMarker.length) + `
${sectionNewContent.trim()}
` + // Ensure new content is on new lines
        content.substring(endIdx);
      }
    }
    if (headingMatch) {
      const headingLevel = headingMatch[1].length;
      const nextHeadingRegex = new RegExp(`^#{1,${headingLevel}}\\s+.*(\\s*\\n|$)`, "im");
      let startIndexAfterHeading = headingMatch.index + headingMatch[0].length;
      let contentAfterHeading = content.substring(startIndexAfterHeading);
      let endIndex = content.length;
      const nextMatch = contentAfterHeading.match(nextHeadingRegex);
      if (nextMatch) {
        endIndex = startIndexAfterHeading + nextMatch.index;
      }
      if (appendUnderHeadingIfNoMarkers) {
        return content.substring(0, endIndex) + // Content up to where next section would start (or end of doc)
        `
${sectionNewContent.trim()}
` + // Append new stuff
        content.substring(endIndex);
      } else {
        return content.substring(0, startIndexAfterHeading) + `${sectionNewContent.trim()}
` + content.substring(endIndex);
      }
    } else {
      return content.trimEnd() + "\n\n" + sectionWithHeading.trimStart();
    }
  }
  formatResultsForObsidianLog(processorName, relationships, processedUrls, mergeDecisions = []) {
    let logContent = `
---
### Log Entry: ${(/* @__PURE__ */ new Date()).toISOString()} for ${processorName}

`;
    if (mergeDecisions.length > 0) {
      logContent += `#### Proactive Deduplication Decisions (${mergeDecisions.length}):
`;
      mergeDecisions.forEach((decision) => {
        logContent += `- ${decision}
`;
      });
      logContent += "\n";
    }
    logContent += `#### Processed URLs (${processedUrls.length}):
`;
    if (processedUrls.length === 0) {
      logContent += "- No URLs were processed.\n";
    } else {
      logContent += "| URL | Title | Type | Verified List? | Current? | Extracted # | Reasoning |\n";
      logContent += "|---|---|---|---|---|---|---|\n";
      processedUrls.forEach((url) => {
        const titleDisplay = this.scrubHyperlinks(url.title || "N/A").substring(0, 70);
        const urlLink = url.url.startsWith("http") ? `[Link](${url.url})` : url.url;
        const reasoningDisplay = this.scrubHyperlinks(url.verificationReasoning || "N/A").substring(0, 100);
        logContent += `| ${urlLink} | ${titleDisplay}... | ${url.documentType || "N/A"} | ${url.isList ? "Yes" : "No"} | ${url.isCurrent ? "Yes" : "No"} | ${url.extractedSubprocessorsCount || 0} | ${reasoningDisplay}... |
`;
      });
    }
    logContent += "\n";
    logContent += `#### Extracted Relationships (${relationships.length}):
`;
    if (relationships.length === 0) {
      logContent += "- No new relationships were extracted in this run.\n";
    } else {
      logContent += "| Primary Processor | Target Entity | Type | Function | Location | Source URL |\n";
      logContent += "|---|---|---|---|---|---|\n";
      relationships.forEach((rel) => {
        const targetEntityDisplay = this.scrubHyperlinks(rel.SubprocessorName).substring(0, 50);
        const primaryProcDisplay = this.scrubHyperlinks(rel.PrimaryProcessor).substring(0, 50);
        const funcDisplay = this.scrubHyperlinks(rel.ProcessingFunction).substring(0, 70);
        const locDisplay = this.scrubHyperlinks(rel.Location).substring(0, 50);
        const sourceUrlLink = rel.SourceURL.startsWith("http") ? `[Source](${rel.SourceURL})` : rel.SourceURL;
        logContent += `| ${primaryProcDisplay} | ${targetEntityDisplay} | ${rel.RelationshipType} | ${funcDisplay}... | ${locDisplay}... | ${sourceUrlLink} |
`;
      });
    }
    logContent += "\n";
    return logContent;
  }
  async writeResultsToObsidianNote(filePath, contentToAppendOrInitial, mode = "ensure_exists_and_append", processorNameForLogTitle) {
    var _a;
    let file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file && (mode === "ensure_exists_and_append" || mode === "overwrite")) {
      let initialContent = "";
      if (processorNameForLogTitle) {
        initialContent += `# Analysis Log: ${processorNameForLogTitle}

`;
      }
      initialContent += contentToAppendOrInitial;
      try {
        file = await this.app.vault.create(filePath, initialContent);
        if (this.settings.verboseDebug) console.log(`Log file created: ${filePath}`);
      } catch (e) {
        if ((_a = e.message) == null ? void 0 : _a.toLowerCase().includes("file already exists")) {
          file = this.app.vault.getAbstractFileByPath(filePath);
          if (!file) {
            console.error(`Failed to get log file ${filePath} after 'already exists' error.`);
            return;
          }
        } else {
          console.error(`Error creating log file ${filePath}:`, e);
          new import_obsidian.Notice(`Error creating log file: ${filePath}`);
          return;
        }
      }
      if (file && mode === "ensure_exists_and_append") {
        return;
      }
    }
    if (file) {
      if (mode === "overwrite") {
        let newContent = "";
        if (processorNameForLogTitle) {
          newContent += `# Analysis Log: ${processorNameForLogTitle}

`;
        }
        newContent += contentToAppendOrInitial;
        await this.app.vault.modify(file, newContent);
        if (this.settings.verboseDebug) console.log(`Log file overwritten: ${filePath}`);
      } else if (mode === "append" || mode === "ensure_exists_and_append" && file) {
        await this.app.vault.append(file, contentToAppendOrInitial);
        if (this.settings.verboseDebug) console.log(`Content appended to log file: ${filePath}`);
      }
    } else if (mode === "append") {
      new import_obsidian.Notice(`Log file ${filePath} not found. Cannot append.`);
      if (this.settings.verboseDebug) console.log(`Log file not found for append: ${filePath}`);
    }
  }
  async getRightBrainAccessToken(creds) {
    const clientId = (creds == null ? void 0 : creds.clientId) || this.settings.rightbrainClientId;
    const clientSecret = (creds == null ? void 0 : creds.clientSecret) || this.settings.rightbrainClientSecret;
    const oauthUrl = (creds == null ? void 0 : creds.oauthUrl) || this.settings.rightbrainOauth2Url;
    if (!clientId || !clientSecret) {
      new import_obsidian.Notice("RightBrain Client ID or Secret not configured.");
      return null;
    }
    if (this._rbToken && this._rbTokenExpiry > Date.now()) {
      if (this.settings.verboseDebug) console.log("Using cached RightBrain token.");
      return this._rbToken;
    }
    const tokenUrl = `${oauthUrl}/oauth2/token`;
    const bodyParams = new URLSearchParams();
    bodyParams.append("grant_type", "client_credentials");
    const credentials = `${clientId}:${clientSecret}`;
    const encodedCredentials = btoa(credentials);
    const headers = {
      "Authorization": `Basic ${encodedCredentials}`,
      "Content-Type": "application/x-www-form-urlencoded",
      "User-Agent": `ObsidianProcessorProcessorPlugin/${this.manifest.version}`
    };
    try {
      if (this.settings.verboseDebug) console.log("Requesting new RightBrain token.");
      const response = await (0, import_obsidian.requestUrl)({
        url: tokenUrl,
        method: "POST",
        headers,
        body: bodyParams.toString(),
        throw: false
      });
      if (response.status === 200 && response.json && response.json.access_token) {
        if (this.settings.verboseDebug) console.log("Successfully obtained new RightBrain token.");
        this._rbToken = response.json.access_token;
        this._rbTokenExpiry = Date.now() + (response.json.expires_in || 3600) * 1e3 - 6e5;
        return response.json.access_token;
      } else {
        console.error("ProcessorProcessor: Failed to get RightBrain token.", response.status, response.text);
        new import_obsidian.Notice(`Failed to get RightBrain token: ${response.status}.`);
        this._rbToken = null;
        this._rbTokenExpiry = 0;
        return null;
      }
    } catch (error) {
      console.error("ProcessorProcessor: Network error fetching RightBrain token:", error);
      new import_obsidian.Notice("Network error fetching RightBrain token.");
      this._rbToken = null;
      this._rbTokenExpiry = 0;
      return null;
    }
  }
  generateSearchQueries(processorName) {
    const cleanedName = processorName.replace(/\b(?:inc\.?|llc\.?|ltd\.?|corp\.?|gmbh\.?|incorporated|limited|corporation)\b/gi, "").replace(/[,.]/g, "").trim();
    return [
      `"${cleanedName}" sub-processor list`,
      `"${cleanedName}" subprocessors`,
      `"${cleanedName}" data processing addendum exhibit`,
      `"${cleanedName}" DPA subprocessors`,
      `"${cleanedName}" third-party vendors`,
      `"${cleanedName}" service providers list`,
      // More generic but sometimes useful for finding portals
      `"${cleanedName}" trust center subprocessors`,
      `"${cleanedName}" legal subprocessors`
      // If the name is short, broad searches might be too noisy.
      // Consider adding quotes around cleanedName if it contains spaces.
    ];
  }
  async searchSerpApiForDpas(processorName, queries, maxResultsSetting) {
    var _a, _b, _c;
    if (!this.settings.serpApiKey) {
      new import_obsidian.Notice("SerpAPI key not set. Cannot perform SerpAPI search.");
      return [];
    }
    const allResults = [];
    const processedUrls = /* @__PURE__ */ new Set();
    const queriesToRun = queries.slice(0, Math.min(queries.length, 3));
    new import_obsidian.Notice(`Searching SerpAPI for ${processorName} using ${queriesToRun.length} queries...`, 3e3);
    for (const query of queriesToRun) {
      if (allResults.length >= maxResultsSetting && maxResultsSetting > 0) {
        break;
      }
      const params = new URLSearchParams({
        api_key: this.settings.serpApiKey,
        q: query,
        engine: "google",
        // Or other engines like 'bing'
        num: "10"
        // Number of results per query (max 100 for Google, usually 10-20 is fine)
        // You can add other params like 'location', 'gl' (country), 'hl' (language) if needed
      });
      const serpApiUrl = `https://serpapi.com/search?${params.toString()}`;
      try {
        const response = await (0, import_obsidian.requestUrl)({ url: serpApiUrl, method: "GET", throw: false });
        if (response.status === 200 && response.json && response.json.organic_results) {
          const organicResults = response.json.organic_results;
          for (const result of organicResults) {
            if (result.link && !processedUrls.has(result.link)) {
              const urlLower = result.link.toLowerCase();
              const titleLower = ((_a = result.title) == null ? void 0 : _a.toLowerCase()) || "";
              const snippetLower = ((_b = result.snippet) == null ? void 0 : _b.toLowerCase()) || "";
              const isRelevant = SUBPROCESSOR_URL_KEYWORDS.some(
                (keyword) => urlLower.includes(keyword) || titleLower.includes(keyword) || snippetLower.includes(keyword)
              );
              if (isRelevant) {
                allResults.push({
                  processorName,
                  title: result.title || "No Title",
                  url: result.link,
                  snippet: result.snippet || "No Snippet",
                  searchQuery: query,
                  documentType: "serpapi_dpa_or_subprocessor_list_candidate"
                  // Mark as potential candidate
                });
                processedUrls.add(result.link);
                if (allResults.length >= maxResultsSetting && maxResultsSetting > 0) break;
              }
            }
          }
        } else {
          console.error(`SerpAPI error for query "${query}": ${response.status}`, (_c = response.text) == null ? void 0 : _c.substring(0, 200));
          new import_obsidian.Notice(`SerpAPI query failed for "${query.substring(0, 20)}...". Status: ${response.status}`);
        }
      } catch (error) {
        console.error(`Network error during SerpAPI search for query "${query}":`, error);
        new import_obsidian.Notice(`Network error during SerpAPI search for "${query.substring(0, 20)}...".`);
      }
      await new Promise((resolve) => setTimeout(resolve, 500 + Math.random() * 300));
    }
    if (this.settings.verboseDebug) console.log(`SerpAPI search for ${processorName} found ${allResults.length} relevant candidates.`);
    return allResults;
  }
  getCompanyDomain(processorName) {
    let name = processorName.toLowerCase();
    name = name.replace(/\b(?:inc\.?|llc\.?|ltd\.?|corp\.?|gmbh\.?)\b/g, "").trim();
    name = name.replace(/[,.]/g, "");
    try {
      if (name.includes(".") && !name.includes(" ")) {
        const url = new URL(name.startsWith("http") ? name : `http://${name}`);
        return url.hostname.replace(/^www\./, "");
      }
    } catch (e) {
    }
    const parts = name.split(/\s+/);
    if (parts.length > 1) {
      return "";
    }
    return name;
  }
  isValidUrl(url, processorNameContext = "") {
    if (!url || typeof url !== "string") return false;
    try {
      const parsedUrl = new URL(url);
      if (!["http:", "https:"].includes(parsedUrl.protocol)) {
        return false;
      }
      if (processorNameContext) {
        const processorDomain = this.getCompanyDomain(processorNameContext);
        if (processorDomain && !parsedUrl.hostname.toLowerCase().includes(processorDomain.replace(/^www\./, ""))) {
        }
      }
      return true;
    } catch (e) {
      return false;
    }
  }
  async extractUrlsFromDpaPage(pageUrl, processorNameContext, sourcePageTitle) {
    var _a;
    if (!this.settings.rightbrainVerifyUrlTaskId) {
      return [];
    }
    const rbToken = await this.getRightBrainAccessToken();
    if (!rbToken) return [];
    const extractedLinks = [];
    let pageContent = "";
    try {
      const response = await (0, import_obsidian.requestUrl)({ url: pageUrl, method: "GET", throw: false });
      if (response.status === 200) {
        pageContent = response.text;
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
    if (!pageContent) return [];
    const linkRegex = /<a\s+(?:[^>]*?\s+)?href="([^"]*)"/gi;
    let match;
    while ((match = linkRegex.exec(pageContent)) !== null) {
      let href = match[1].trim();
      if (href && !href.startsWith("#") && !href.startsWith("mailto:") && !href.startsWith("javascript:")) {
        try {
          const absoluteUrl = new URL(href, pageUrl).toString();
          if (this.isValidUrl(absoluteUrl, processorNameContext)) {
            const urlLower = absoluteUrl.toLowerCase();
            const titleOrTextLower = (((_a = match[0].match(/>(.*?)</)) == null ? void 0 : _a[1]) || "").toLowerCase();
            const isPotentialSubprocessorList = SUBPROCESSOR_URL_KEYWORDS.some(
              (keyword) => urlLower.includes(keyword) || titleOrTextLower.includes(keyword)
            );
            if (isPotentialSubprocessorList) {
              extractedLinks.push({
                processorName: processorNameContext,
                title: `Linked from: ${sourcePageTitle || pageUrl}`,
                url: absoluteUrl,
                snippet: `Found on page: ${pageUrl}`,
                documentType: "linked_subprocessor_list_candidate",
                sourceDpaUrl: pageUrl
              });
            }
          }
        } catch (e) {
        }
      }
    }
    return extractedLinks;
  }
  async callRightBrainTask(taskId, taskVariables, rbToken) {
    if (!taskId) {
      new import_obsidian.Notice("RightBrain Task ID is missing for the call.");
      console.error("ProcessorProcessor: Attempted to call RightBrain task with no Task ID.");
      return null;
    }
    if (!this.settings.rightbrainOrgId || !this.settings.rightbrainProjectId) {
      new import_obsidian.Notice("RightBrain Org ID or Project ID not set. Cannot call task.");
      console.error("ProcessorProcessor: RB OrgID or ProjectID missing for task call.");
      return null;
    }
    const taskRunUrl = `${this.settings.rightbrainApiUrl}/org/${this.settings.rightbrainOrgId}/project/${this.settings.rightbrainProjectId}/task/${taskId}/run`;
    const headers = {
      "Authorization": `Bearer ${rbToken}`,
      "Content-Type": "application/json",
      "User-Agent": `ObsidianProcessorProcessorPlugin/${this.manifest.version}`
    };
    const payload = {
      task_input: taskVariables
    };
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: taskRunUrl,
        method: "POST",
        headers,
        body: JSON.stringify(payload),
        // Send the newly constructed payload
        throw: false
      });
      if (response.json && (response.status === 200 || response.status === 201)) {
        return response.json;
      } else {
        new import_obsidian.Notice(`RightBrain Task ${taskId.substring(0, 8)}... failed: ${response.status}. Check console.`, 7e3);
        console.error(`RB Task Call [${taskId}] Error: ${response.status}`, response.text ? response.text.substring(0, 1e3) : "No body", "Payload Sent:", payload);
        return null;
      }
    } catch (error) {
      new import_obsidian.Notice(`Network error calling RightBrain Task ${taskId.substring(0, 8)}.... Check console.`, 7e3);
      console.error(`RB Task Call [${taskId}] Network Error:`, error, "Payload Sent:", payload);
      return null;
    }
  }
  async verifySubprocessorListUrl(urlToVerify, processorName, rbToken) {
    if (!this.settings.rightbrainVerifyUrlTaskId) {
      new import_obsidian.Notice("RightBrain Verify URL Task ID is not configured. Cannot verify URL.");
      return null;
    }
    const taskInput = {
      "url_content": urlToVerify,
      "expected_processor_name": processorName
    };
    if (this.settings.verboseDebug) console.log(`Verifying URL ${urlToVerify} with RB Task ${this.settings.rightbrainVerifyUrlTaskId}. Input:`, JSON.stringify(taskInput));
    const taskResult = await this.callRightBrainTask(this.settings.rightbrainVerifyUrlTaskId, taskInput, rbToken);
    if (this.settings.verboseDebug) {
      console.log(`RB Verify Task [${this.settings.rightbrainVerifyUrlTaskId}] Full Result for URL ${urlToVerify}:`, JSON.stringify(taskResult, null, 2));
    }
    if (taskResult && typeof taskResult.response === "object" && taskResult.response !== null) {
      const rbResponse = taskResult.response;
      const isList = String(rbResponse.isSubprocessorList).toLowerCase() === "true";
      const isCorrectProcessor = String(rbResponse.isCorrectProcessor).toLowerCase() === "true";
      const isCurrent = String(rbResponse.isCurrentVersion).toLowerCase() === "true";
      const reasoning = rbResponse.reasoning || "N/A";
      let pageContent = void 0;
      if (taskResult.run_data && taskResult.run_data.submitted && typeof taskResult.run_data.submitted.url_content === "string" && taskResult.run_data.submitted.url_content.toLowerCase().includes("<html")) {
        pageContent = taskResult.run_data.submitted.url_content;
        if (this.settings.verboseDebug) console.log("Retrieved pageContent from run_data.submitted.url_content for verify task");
      } else if (typeof rbResponse.fetched_page_html === "string") {
        pageContent = rbResponse.fetched_page_html;
        if (this.settings.verboseDebug) console.log("Retrieved pageContent from rbResponse.fetched_page_html for verify task");
      } else if (typeof rbResponse.page_content === "string") {
        pageContent = rbResponse.page_content;
        if (this.settings.verboseDebug) console.log("Retrieved pageContent from rbResponse.page_content (fallback) for verify task");
      }
      if (this.settings.verboseDebug) {
        console.log(`RB Verify for ${urlToVerify}: List=${isList}, Current=${isCurrent}, Content available: ${!!pageContent}, Content snippet: ${pageContent ? pageContent.substring(0, 100) + "..." : "N/A"}`);
      }
      return { isList, isCurrent: isList && isCurrent, isCorrectProcessor, reasoning, pageContent };
    }
    if (this.settings.verboseDebug) {
      console.warn(`RB Verify task for ${urlToVerify} failed or returned unexpected response format. TaskResult:`, taskResult);
    }
    return null;
  }
  async extractEntitiesFromPageContent(pageContent, rbToken) {
    if (!this.settings.rightbrainExtractEntitiesTaskId) {
      new import_obsidian.Notice("RB Extract Entities Task ID missing. Cannot extract from content.");
      return null;
    }
    if (!pageContent.trim()) {
      return { thirdPartySubprocessors: [], ownEntities: [] };
    }
    const taskInput = { [this.settings.rightbrainExtractInputField]: pageContent };
    const taskResult = await this.callRightBrainTask(this.settings.rightbrainExtractEntitiesTaskId, taskInput, rbToken);
    if (taskResult && typeof taskResult.response === "object" && taskResult.response !== null) {
      const rbResponse = taskResult.response;
      const thirdPartySubprocessors = rbResponse[this.settings.rightbrainExtractOutputThirdPartyField] || [];
      const ownEntities = rbResponse[this.settings.rightbrainExtractOutputOwnEntitiesField] || [];
      return {
        thirdPartySubprocessors: Array.isArray(thirdPartySubprocessors) ? thirdPartySubprocessors : [],
        ownEntities: Array.isArray(ownEntities) ? ownEntities : []
      };
    }
    return null;
  }
  async updateDiscoveryStatus(file, status) {
    if (!file) return;
    await this.app.vault.process(file, (content) => {
      const updates = {
        "discovery-status": status
      };
      if (status === "complete") {
        updates["last-discovered"] = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      }
      return this.updateFrontmatter(content, updates, file.basename);
    });
  }
  async buildAliasMap() {
    var _a;
    const aliasMap = /* @__PURE__ */ new Map();
    const processorsFolder = this.app.vault.getAbstractFileByPath(this.settings.processorsFolderPath);
    if (!(processorsFolder == null ? void 0 : processorsFolder.children)) return aliasMap;
    for (const file of processorsFolder.children) {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        const cache = this.app.metadataCache.getFileCache(file);
        const frontmatter = (cache == null ? void 0 : cache.frontmatter) || {};
        const canonicalName = ((_a = frontmatter.aliases) == null ? void 0 : _a[0]) || file.basename;
        const aliases = (frontmatter.aliases || []).map((a) => String(a).toLowerCase());
        aliases.push(file.basename.toLowerCase());
        for (const alias of new Set(aliases)) {
          if (alias) {
            aliasMap.set(alias, { path: file.path, canonicalName });
          }
        }
      }
    }
    return aliasMap;
  }
  async runDeduplicationForFolder(folder) {
    new import_obsidian.Notice(`Preparing to deduplicate pages in ${folder.path}...`);
    if (!this.settings.rightbrainDeduplicateSubprocessorsTaskId) {
      new import_obsidian.Notice("Deduplication Task ID not set. Cannot proceed.");
      return;
    }
    const rbToken = await this.getRightBrainAccessToken();
    if (!rbToken) {
      new import_obsidian.Notice("Could not get RightBrain token for deduplication.");
      return;
    }
    const files = folder.children.filter((f) => f instanceof import_obsidian.TFile && f.extension === "md");
    if (files.length < 2) {
      new import_obsidian.Notice("Not enough Markdown files in the folder to perform deduplication.");
      return;
    }
    const subprocessorPagesInfo = [];
    for (const file of files) {
      const fileCache = this.app.metadataCache.getFileCache(file);
      const frontmatter = fileCache == null ? void 0 : fileCache.frontmatter;
      const aliases = (frontmatter == null ? void 0 : frontmatter.aliases) && Array.isArray(frontmatter.aliases) ? frontmatter.aliases.map(String) : [];
      if (frontmatter == null ? void 0 : frontmatter.company_name) aliases.push(String(frontmatter.company_name));
      aliases.push(file.basename);
      subprocessorPagesInfo.push({
        file_path: file.path,
        page_name: file.basename,
        // Or a more canonical name from frontmatter if available
        aliases: Array.from(new Set(aliases.filter((a) => a)))
        // Unique, non-empty aliases
      });
    }
    if (subprocessorPagesInfo.length < 2) {
      new import_obsidian.Notice("Not enough processable pages with aliases found for deduplication.");
      return;
    }
    const taskInputPayload = {
      subprocessor_pages: subprocessorPagesInfo
      // Optional: Add a threshold or other parameters if your RB task supports them
      // "similarity_threshold": 0.8 
    };
    new import_obsidian.Notice(`Sending ${subprocessorPagesInfo.length} pages to RightBrain for deduplication analysis... This may take a while.`);
    const taskResult = await this.callRightBrainTask(this.settings.rightbrainDeduplicateSubprocessorsTaskId, taskInputPayload, rbToken);
    if (taskResult && taskResult.response && Array.isArray(taskResult.response.deduplication_results)) {
      const deduplicationResults = taskResult.response.deduplication_results;
      if (deduplicationResults.length === 0) {
        new import_obsidian.Notice("No duplicates found by RightBrain task.");
        return;
      }
      new import_obsidian.Notice(`Deduplication analysis complete. Found ${deduplicationResults.length} potential duplicate sets. Processing merges...`);
      await this.processDeduplicationResults(deduplicationResults);
    } else {
      new import_obsidian.Notice("Deduplication task failed or returned an unexpected response. Check console.");
      console.error("Deduplication task error. Response:", taskResult);
    }
  }
  async processDeduplicationResults(results) {
    var _a, _b, _c;
    let mergeCount = 0;
    for (const resultSet of results) {
      if (!resultSet.survivor_file_path || resultSet.duplicate_file_paths.length === 0) {
        if (this.settings.verboseDebug) console.warn("Skipping invalid deduplication result set:", resultSet);
        continue;
      }
      const survivorFile = this.app.vault.getAbstractFileByPath(resultSet.survivor_file_path);
      if (!survivorFile) {
        if (this.settings.verboseDebug) console.warn(`Survivor file not found: ${resultSet.survivor_file_path}`);
        continue;
      }
      const originalSurvivorContent = await this.app.vault.read(survivorFile);
      const survivorCache = this.app.metadataCache.getFileCache(survivorFile);
      const allAliases = new Set((((_a = survivorCache == null ? void 0 : survivorCache.frontmatter) == null ? void 0 : _a.aliases) || []).map(String));
      allAliases.add(survivorFile.basename);
      const allRows = new Set(this.extractClientTableRows(originalSurvivorContent));
      for (const dupFilePath of resultSet.duplicate_file_paths) {
        if (dupFilePath === survivorFile.path) continue;
        const dupFile = this.app.vault.getAbstractFileByPath(dupFilePath);
        if (dupFile) {
          const dupContent = await this.app.vault.read(dupFile);
          const dupCache = this.app.metadataCache.getFileCache(dupFile);
          (((_b = dupCache == null ? void 0 : dupCache.frontmatter) == null ? void 0 : _b.aliases) || []).map(String).forEach((alias) => allAliases.add(alias));
          allAliases.add(dupFile.basename);
          this.extractClientTableRows(dupContent).forEach((row) => allRows.add(row));
          try {
            await this.app.vault.delete(dupFile);
          } catch (e) {
            console.error(`Failed to delete duplicate file ${dupFilePath}:`, e);
          }
        }
      }
      const fmRegex = /^---\s*\n([\s\S]*?)\n---\s*\n/;
      const match = originalSurvivorContent.match(fmRegex);
      let survivorBody = match ? originalSurvivorContent.substring(match[0].length) : originalSurvivorContent;
      const existingTags = new Set((((_c = survivorCache == null ? void 0 : survivorCache.frontmatter) == null ? void 0 : _c.tags) || []).map(String));
      let newFmString = "---\n";
      newFmString += `aliases: [${Array.from(allAliases).map((a) => `"${a.replace(/"/g, '\\"')}"`).join(", ")}]
`;
      if (existingTags.size > 0) {
        newFmString += `tags: [${Array.from(existingTags).map((t) => `"${t}"`).join(", ")}]
`;
      }
      newFmString += "---\n";
      let clientTableMd = "";
      if (allRows.size > 0) {
        clientTableMd += `| Primary Processor | Processing Function | Location | Source URL |
`;
        clientTableMd += `|---|---|---|---|
`;
        allRows.forEach((row) => {
          clientTableMd += `|${row}|
`;
        });
      }
      const finalBody = this.ensureHeadingAndSection(survivorBody, "Used By", clientTableMd, null, null);
      const finalContent = newFmString + finalBody;
      await this.app.vault.modify(survivorFile, finalContent);
      mergeCount++;
      new import_obsidian.Notice(`Merged ${resultSet.duplicate_file_paths.length} duplicate(s) into ${survivorFile.basename}.`);
    }
    if (mergeCount > 0) {
      new import_obsidian.Notice(`Deduplication finished. ${mergeCount} merge operations performed.`);
    } else {
      new import_obsidian.Notice("Deduplication process finished, but no actionable merges were made.");
    }
  }
  async processManualMerge(survivorFile, duplicateFiles) {
    var _a, _b, _c;
    if (!survivorFile || duplicateFiles.length === 0) {
      new import_obsidian.Notice("Merge cancelled: No survivor or duplicates selected.");
      return;
    }
    new import_obsidian.Notice(`Merging ${duplicateFiles.length} file(s) into ${survivorFile.basename}...`, 6e3);
    try {
      const originalSurvivorContent = await this.app.vault.read(survivorFile);
      const survivorCache = this.app.metadataCache.getFileCache(survivorFile);
      const allAliases = new Set((((_a = survivorCache == null ? void 0 : survivorCache.frontmatter) == null ? void 0 : _a.aliases) || []).map(String));
      allAliases.add(survivorFile.basename);
      const allRows = new Set(this.extractClientTableRows(originalSurvivorContent));
      for (const dupFile of duplicateFiles) {
        const dupContent = await this.app.vault.read(dupFile);
        const dupCache = this.app.metadataCache.getFileCache(dupFile);
        (((_b = dupCache == null ? void 0 : dupCache.frontmatter) == null ? void 0 : _b.aliases) || []).map(String).forEach((alias) => allAliases.add(alias));
        allAliases.add(dupFile.basename);
        this.extractClientTableRows(dupContent).forEach((row) => allRows.add(row));
      }
      const fmRegex = /^---\s*\n([\s\S]*?)\n---\s*\n/;
      const match = originalSurvivorContent.match(fmRegex);
      let survivorBody = match ? originalSurvivorContent.substring(match[0].length) : originalSurvivorContent;
      const existingTags = new Set((((_c = survivorCache == null ? void 0 : survivorCache.frontmatter) == null ? void 0 : _c.tags) || []).map(String));
      let newFmString = "---\n";
      newFmString += `aliases: [${Array.from(allAliases).map((a) => `"${a.replace(/"/g, '\\"')}"`).join(", ")}]
`;
      if (existingTags.size > 0) {
        newFmString += `tags: [${Array.from(existingTags).map((t) => `"${t}"`).join(", ")}]
`;
      }
      newFmString += "---\n";
      let clientTableMd = "";
      if (allRows.size > 0) {
        clientTableMd += `| Primary Processor | Processing Function | Location | Source URL |
`;
        clientTableMd += `|---|---|---|---|
`;
        allRows.forEach((row) => {
          clientTableMd += `|${row}|
`;
        });
      }
      const finalBody = this.ensureHeadingAndSection(survivorBody, "Used By", clientTableMd, null, null);
      const finalContent = newFmString + finalBody;
      await this.app.vault.modify(survivorFile, finalContent);
      for (const dupFile of duplicateFiles) {
        await this.app.vault.delete(dupFile);
      }
      new import_obsidian.Notice(`Successfully merged ${duplicateFiles.length} file(s) into ${survivorFile.basename}.`);
    } catch (error) {
      console.error("Error during manual merge:", error);
      new import_obsidian.Notice("An error occurred during the merge. Check the developer console.");
    }
  }
  extractClientTableRows(content) {
    const rows = [];
    const lines = content.split("\n");
    let inUsedBySection = false;
    let tableHasStarted = false;
    for (const line of lines) {
      if (line.match(/^##+\s*Used By\s*$/i)) {
        inUsedBySection = true;
        tableHasStarted = false;
        continue;
      }
      if (inUsedBySection) {
        const trimmedLine = line.trim();
        if (trimmedLine.startsWith("##")) {
          inUsedBySection = false;
          break;
        }
        if (trimmedLine.match(/^\|---\|/)) {
          tableHasStarted = true;
          continue;
        }
        if (tableHasStarted && trimmedLine.startsWith("|") && trimmedLine.endsWith("|")) {
          const match = trimmedLine.match(/^\|(.*)\|$/);
          if (match && match[1]) {
            if (!match[1].match(/^---\|/)) {
              rows.push(match[1]);
            }
          }
        } else if (tableHasStarted && trimmedLine !== "") {
          break;
        }
      }
    }
    return rows;
  }
  async discoverRecursively(initialProcessorName, initialProcessorFile, maxDepth = 3) {
    var _a, _b;
    new import_obsidian.Notice(`Starting smart recursive discovery for: ${initialProcessorName}. Max depth: ${maxDepth}`, 1e4);
    const aliasMap = await this.buildAliasMap();
    this.processedInCurrentRecursiveSearch = /* @__PURE__ */ new Set();
    const queue = [{ processorName: initialProcessorName, depth: 0 }];
    let discoveredCount = 0;
    let skippedCount = 0;
    while (queue.length > 0) {
      const current = queue.shift();
      if (!current) continue;
      let { processorName, depth } = current;
      const existingEntity = aliasMap.get(processorName.toLowerCase());
      let currentProcessorFile = existingEntity ? this.app.vault.getAbstractFileByPath(existingEntity.path) : null;
      if (currentProcessorFile) {
        const cache = this.app.metadataCache.getFileCache(currentProcessorFile);
        if (((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a["discovery-status"]) === "complete" && ((_b = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _b["last-discovered"])) {
          const lastRun = new Date(cache.frontmatter["last-discovered"]);
          const expiryDate = /* @__PURE__ */ new Date();
          expiryDate.setDate(expiryDate.getDate() - this.settings.discoveryCacheDays);
          if (lastRun > expiryDate) {
            if (this.settings.verboseDebug) console.log(`Skipping recently processed: ${processorName}`);
            skippedCount++;
            continue;
          }
        }
      }
      new import_obsidian.Notice(`Recursive (depth ${depth}): Processing ${processorName}...`);
      const { filePathName: sanitizedNameForTracking } = this.sanitizeNameForFilePathAndAlias(processorName);
      if (this.processedInCurrentRecursiveSearch.has(sanitizedNameForTracking)) continue;
      this.processedInCurrentRecursiveSearch.add(sanitizedNameForTracking);
      const isTopLevel = depth === 0;
      if (!currentProcessorFile) {
        currentProcessorFile = await this.ensureProcessorFile(processorName, true, isTopLevel);
      }
      if (!currentProcessorFile) continue;
      discoveredCount++;
      const searchData = await this.fetchProcessorSearchDataWithDiscovery(processorName);
      if (searchData == null ? void 0 : searchData.collectedRelationships) {
        const directSubNames = Array.from(new Set(searchData.collectedRelationships.filter((rel) => rel.PrimaryProcessor === processorName && rel.RelationshipType === "uses_subprocessor").map((rel) => rel.SubprocessorName.trim()).filter((name) => name)));
        const mergeDecisionsLog = [];
        if (depth < maxDepth - 1) {
          for (const subName of directSubNames) {
            const sanitizedSubNameForTracking = this.sanitizeNameForFilePathAndAlias(subName).filePathName;
            if (this.processedInCurrentRecursiveSearch.has(sanitizedSubNameForTracking)) continue;
            const existingMapping = aliasMap.get(subName.toLowerCase());
            let nameToQueue = subName;
            if (existingMapping) {
              nameToQueue = existingMapping.canonicalName;
              if (subName !== nameToQueue) {
                const decision = `Mapped discovered name "${subName}" to existing processor "${nameToQueue}".`;
                mergeDecisionsLog.push(decision);
              }
            } else {
              const { filePathName, originalNameAsAlias } = this.sanitizeNameForFilePathAndAlias(subName);
              const newPath = `${this.settings.processorsFolderPath}/${filePathName}.md`;
              aliasMap.set(subName.toLowerCase(), { path: newPath, canonicalName: originalNameAsAlias });
            }
            if (!queue.some((q) => q.processorName === nameToQueue)) {
              queue.push({ processorName: nameToQueue, depth: depth + 1 });
            }
          }
        }
        await this.persistSubprocessorInfo(processorName, currentProcessorFile, searchData, isTopLevel, mergeDecisionsLog);
        await this.updateDiscoveryStatus(currentProcessorFile, "complete");
      } else {
        await this.updateDiscoveryStatus(currentProcessorFile, "incomplete");
      }
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
    new import_obsidian.Notice(`Recursive discovery complete. Processed ${discoveredCount} entities, skipped ${skippedCount} recent ones.`, 1e4);
    this.processedInCurrentRecursiveSearch.clear();
  }
  openFileSelectorMergeModal() {
    const files = this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(this.settings.processorsFolderPath + "/"));
    if (files.length < 2) {
      new import_obsidian.Notice("There are not enough processor files to perform a merge.");
      return;
    }
    new FileSelectorMergeModal(this.app, files, (selectedFiles) => {
      new ForceMergeModal(this.app, selectedFiles, (survivor, duplicates) => {
        this.processManualMerge(survivor, duplicates);
      }).open();
    }).open();
  }
};
var ManualInputModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit, initialProcessorName) {
    super(app);
    this.processorName = "";
    this.listUrl = "";
    this.isPrimaryProcessor = true;
    this.onSubmit = onSubmit;
    this.initialProcessorName = initialProcessorName;
    if (this.initialProcessorName) {
      this.processorName = this.initialProcessorName;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Manually Add Subprocessor List URL" });
    new import_obsidian.Setting(contentEl).setName("Processor Name").setDesc("Enter the name of the primary processor (e.g., OpenAI).").addText((text) => {
      text.setPlaceholder("Enter processor name").setValue(this.processorName).onChange((value) => this.processorName = value).inputEl.setAttr("required", "true");
      if (this.initialProcessorName) {
        text.setDisabled(true);
      }
    });
    new import_obsidian.Setting(contentEl).setName("Subprocessor List URL").setDesc("Enter the direct URL to the subprocessor list or DPA page.").addText((text) => text.setPlaceholder("https://example.com/subprocessors").setValue(this.listUrl).onChange((value) => this.listUrl = value).inputEl.setAttr("required", "true"));
    new import_obsidian.Setting(contentEl).setName("Is a primary processor?").setDesc("Enable this if you are initiating a search on this processor. Disable if you are adding a subprocessor of another entity.").addToggle((toggle) => toggle.setValue(this.isPrimaryProcessor).onChange((value) => this.isPrimaryProcessor = value));
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Process URL").setCta().onClick(() => {
      this.close();
      this.onSubmit(this.processorName, this.listUrl, this.isPrimaryProcessor);
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var SearchModal = class extends import_obsidian.Modal {
  constructor(app, settings, onSubmit) {
    super(app);
    this.processorName = "";
    this.settings = settings;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Discover Subprocessors" });
    let searchMethodNote = "Search will be performed using available configured methods.";
    if (this.settings.serpApiKey) {
      searchMethodNote = "Search will primarily use SerpAPI.";
    } else if (this.settings.rightbrainOrgId && this.settings.rightbrainProjectId && this.settings.rightbrainDuckDuckGoSearchTaskId) {
      searchMethodNote = "SerpAPI key not found. Search will use DuckDuckGo via RightBrain.";
    } else {
      searchMethodNote = "Neither SerpAPI nor RightBrain DuckDuckGo search is fully configured. Discovery might be limited.";
    }
    contentEl.createEl("p", { text: searchMethodNote });
    new import_obsidian.Setting(contentEl).setName("Processor Name").setDesc("Enter the name of the processor to search for (e.g., Stripe).").addText((text) => text.setPlaceholder("Enter processor name").setValue(this.processorName).onChange((value) => this.processorName = value).inputEl.setAttr("required", "true"));
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Start Discovery").setCta().onClick(() => {
      if (!this.processorName.trim()) {
        new import_obsidian.Notice("Processor Name is required.");
        return;
      }
      this.close();
      this.onSubmit(this.processorName);
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var ManualTextEntryModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit, initialProcessorName) {
    super(app);
    this.processorName = "";
    this.pastedText = "";
    this.isPrimaryProcessor = true;
    this.onSubmit = onSubmit;
    this.initialProcessorName = initialProcessorName;
    if (this.initialProcessorName) {
      this.processorName = this.initialProcessorName;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Input Subprocessor List from Text" });
    new import_obsidian.Setting(contentEl).setName("Processor Name").setDesc("Enter the name of the primary processor this text belongs to.").addText((text) => {
      text.setPlaceholder("Enter processor name").setValue(this.processorName).onChange((value) => this.processorName = value).inputEl.setAttr("required", "true");
      if (this.initialProcessorName) {
        text.setDisabled(true);
      }
    });
    new import_obsidian.Setting(contentEl).setName("Is a primary processor?").setDesc("Enable this if you are initiating a search on this processor. Disable if you are adding a subprocessor of another entity.").addToggle((toggle) => toggle.setValue(this.isPrimaryProcessor).onChange((value) => this.isPrimaryProcessor = value));
    contentEl.createEl("p", { text: "Paste the subprocessor list text below:" });
    const textArea = new import_obsidian.TextAreaComponent(contentEl).setPlaceholder("Paste text here...").setValue(this.pastedText).onChange((value) => this.pastedText = value);
    textArea.inputEl.rows = 10;
    textArea.inputEl.style.width = "100%";
    textArea.inputEl.setAttr("required", "true");
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Process Text").setCta().onClick(() => {
      this.close();
      this.onSubmit(this.processorName, this.pastedText, this.isPrimaryProcessor);
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var ForceMergeModal = class extends import_obsidian.Modal {
  constructor(app, files, onSubmit) {
    super(app);
    this.survivor = null;
    this.files = files.sort((a, b) => a.basename.localeCompare(b.basename));
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Force Merge Processors" });
    contentEl.createEl("p", { text: 'Select the file to keep (the "survivor"). All other selected files will be merged into it and then deleted.' });
    let mergeButton;
    const radioGroup = contentEl.createDiv();
    this.files.forEach((file) => {
      const setting = new import_obsidian.Setting(radioGroup).setName(file.basename).setDesc(file.path);
      const radio = createEl("input", {
        type: "radio",
        cls: "force-merge-radio"
      });
      radio.name = "survivor-selection";
      radio.value = file.path;
      radio.onchange = () => {
        this.survivor = file;
        mergeButton.setDisabled(false).setCta(true);
      };
      setting.controlEl.appendChild(radio);
    });
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close())).addButton((btn) => {
      mergeButton = btn;
      btn.setButtonText("Merge").setDisabled(true).onClick(() => {
        if (this.survivor) {
          const duplicates = this.files.filter((f) => f.path !== this.survivor.path);
          this.close();
          this.onSubmit(this.survivor, duplicates);
        }
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};
var FileSelectorMergeModal = class extends import_obsidian.Modal {
  constructor(app, files, onSubmit) {
    super(app);
    this.selectedFilePaths = /* @__PURE__ */ new Set();
    this.files = files.sort((a, b) => a.basename.localeCompare(b.basename));
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Select Files to Merge" });
    contentEl.createEl("p", { text: "Choose two or more processor files from the list below." });
    let nextButton;
    const checkboxGroup = contentEl.createDiv();
    checkboxGroup.addClass("processor-file-selector-list");
    this.files.forEach((file) => {
      const setting = new import_obsidian.Setting(checkboxGroup).setName(file.basename).setDesc(file.path);
      setting.addToggle((toggle) => {
        toggle.onChange((value) => {
          if (value) {
            this.selectedFilePaths.add(file.path);
          } else {
            this.selectedFilePaths.delete(file.path);
          }
          nextButton.setDisabled(this.selectedFilePaths.size < 2);
        });
      });
    });
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close())).addButton((btn) => {
      nextButton = btn;
      btn.setButtonText("Next: Select Survivor").setCta().setDisabled(true).onClick(() => {
        const selectedFiles = this.files.filter((f) => this.selectedFilePaths.has(f.path));
        this.close();
        this.onSubmit(selectedFiles);
      });
    });
  }
};
var PasteEnvModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.pastedText = "";
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Complete Plugin Setup" });
    contentEl.createEl("p", { text: "Paste the entire block of environment variables from your RightBrain dashboard below. This will save your credentials and then automatically create the necessary AI tasks in your project." });
    const textArea = new import_obsidian.TextAreaComponent(contentEl).setPlaceholder('RB_ORG_ID="..."\nRB_PROJECT_ID="..."').onChange((value) => this.pastedText = value);
    textArea.inputEl.rows = 12;
    textArea.inputEl.style.width = "100%";
    textArea.inputEl.style.fontFamily = "monospace";
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Begin Setup").setCta().onClick(() => {
      if (this.pastedText.trim()) {
        this.runFullSetup();
        this.close();
      } else {
        new import_obsidian.Notice("Text area is empty.");
      }
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
  /**
   * Parses the pasted text, saves credentials, then proceeds to set up tasks.
   */
  async runFullSetup() {
    const lines = this.pastedText.trim().split("\n");
    const settingsToUpdate = {};
    const keyMap = {
      "RB_ORG_ID": "rightbrainOrgId",
      "RB_PROJECT_ID": "rightbrainProjectId",
      "RB_CLIENT_ID": "rightbrainClientId",
      "RB_CLIENT_SECRET": "rightbrainClientSecret",
      "RB_API_URL": "rightbrainApiUrl",
      "RB_OAUTH2_URL": "rightbrainOauth2Url"
    };
    for (const line of lines) {
      const parts = line.split("=");
      if (parts.length < 2) continue;
      const key = parts[0].trim();
      let value = parts.slice(1).join("=").trim().replace(/["']/g, "");
      if (key in keyMap && value) {
        const settingKey = keyMap[key];
        settingsToUpdate[settingKey] = value;
      }
    }
    if (!settingsToUpdate.rightbrainOrgId || !settingsToUpdate.rightbrainProjectId || !settingsToUpdate.rightbrainClientId || !settingsToUpdate.rightbrainClientSecret || !settingsToUpdate.rightbrainApiUrl || !settingsToUpdate.rightbrainOauth2Url) {
      new import_obsidian.Notice("Setup failed. Pasted text is missing one or more required values.", 7e3);
      return;
    }
    this.plugin.settings = Object.assign(this.plugin.settings, settingsToUpdate);
    await this.plugin.saveSettings();
    new import_obsidian.Notice(`Successfully updated credentials.`);
    await new Promise((resolve) => setTimeout(resolve, 1e3));
    await this.plugin.setupRightBrainTasks({
      apiUrl: settingsToUpdate.rightbrainApiUrl,
      oauthUrl: settingsToUpdate.rightbrainOauth2Url,
      clientId: settingsToUpdate.rightbrainClientId,
      clientSecret: settingsToUpdate.rightbrainClientSecret,
      orgId: settingsToUpdate.rightbrainOrgId,
      projectId: settingsToUpdate.rightbrainProjectId
    });
  }
};
var ProcessorProcessorSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Processor Processor Settings" });
    containerEl.createEl("h3", { text: "API Keys & Credentials" });
    new import_obsidian.Setting(containerEl).setName("SerpAPI Key").setDesc("Your SerpAPI Key for Google search functionality.").addText((text) => text.setPlaceholder("Enter your SerpAPI key").setValue(this.plugin.settings.serpApiKey).onChange(async (value) => {
      this.plugin.settings.serpApiKey = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "RightBrain Task Configuration" });
    new import_obsidian.Setting(containerEl).setName("RB Extract Entities: Input Field Name").setDesc('The parameter name your RB Extract Entities task expects for the input text (e.g., "page_text", "document_content").').addText((text) => text.setValue(this.plugin.settings.rightbrainExtractInputField).setPlaceholder("e.g., page_text").onChange(async (value) => {
      this.plugin.settings.rightbrainExtractInputField = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("RB Extract Entities: Output Field (Third-Party)").setDesc(`The field name in your RB Extract Entities task's JSON output for the list of third-party subprocessors (e.g., "third_party_subprocessors").`).addText((text) => text.setValue(this.plugin.settings.rightbrainExtractOutputThirdPartyField).setPlaceholder("e.g., third_party_subprocessors").onChange(async (value) => {
      this.plugin.settings.rightbrainExtractOutputThirdPartyField = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("RB Extract Entities: Output Field (Own Entities)").setDesc(`The field name in your RB Extract Entities task's JSON output for the list of own/affiliated entities (e.g., "own_entities").`).addText((text) => text.setValue(this.plugin.settings.rightbrainExtractOutputOwnEntitiesField).setPlaceholder("e.g., own_entities").onChange(async (value) => {
      this.plugin.settings.rightbrainExtractOutputOwnEntitiesField = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "General Settings" });
    new import_obsidian.Setting(containerEl).setName("Create Pages for Own Entities").setDesc('If enabled, separate Markdown pages will also be created for "own entities" identified during processing, not just third-party subprocessors.').addToggle((toggle) => toggle.setValue(this.plugin.settings.createPagesForOwnEntities).onChange(async (value) => {
      this.plugin.settings.createPagesForOwnEntities = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Verbose Debug Logging").setDesc("Enable detailed logging to the developer console for debugging purposes.").addToggle((toggle) => toggle.setValue(this.plugin.settings.verboseDebug).onChange(async (value) => {
      this.plugin.settings.verboseDebug = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Max Results Per Processor (Discovery)").setDesc("Maximum search results to process for each processor during initial discovery. Currently, the logic stops on the first verified list, effectively making this 1.").addText((text) => text.setValue(this.plugin.settings.maxResultsPerProcessor.toString()).setDisabled(true).onChange(async (value) => {
    }));
    new import_obsidian.Setting(containerEl).setName("Mapping Depth").setDesc("Set the maximum depth for the Map Subprocessor Relationships function (e.g., 2-5). Higher numbers will take much longer and use more API calls.").addText((text) => text.setPlaceholder("e.g., 3").setValue(this.plugin.settings.maxRecursiveDepth.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.maxRecursiveDepth = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Discovery Cache Duration (Days)").setDesc(`How many days to consider a processor's data "fresh". A processor with a "complete" status discovered within this period will be skipped during recursive runs.`).addText((text) => text.setPlaceholder("e.g., 30").setValue(this.plugin.settings.discoveryCacheDays.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 0) {
        this.plugin.settings.discoveryCacheDays = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Processors Folder Path").setDesc('Path to the folder where processor and subprocessor notes will be stored (e.g., "Third Parties/Processors").').addText((text) => text.setPlaceholder("e.g., Processors").setValue(this.plugin.settings.processorsFolderPath).onChange(async (value) => {
      this.plugin.settings.processorsFolderPath = value || DEFAULT_SETTINGS.processorsFolderPath;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Analysis Logs Folder Path").setDesc('Path to the folder where analysis log notes for each processor will be stored (e.g., "Compliance/Logs").').addText((text) => text.setPlaceholder("e.g., Analysis Logs").setValue(this.plugin.settings.analysisLogsFolderPath).onChange(async (value) => {
      this.plugin.settings.analysisLogsFolderPath = value || DEFAULT_SETTINGS.analysisLogsFolderPath;
      await this.plugin.saveSettings();
    }));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJ0YXNrX2RlZmluaXRpb25zLmpzb24iXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IEFwcCwgTW9kYWwsIE5vdGljZSwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCByZXF1ZXN0VXJsLCBURmlsZSwgTWVudSwgTWVudUl0ZW0sIEZyb250TWF0dGVyQ2FjaGUsIFRGb2xkZXIsIFRleHRDb21wb25lbnQsIFRleHRBcmVhQ29tcG9uZW50LCBCdXR0b25Db21wb25lbnQgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdGFza0RlZmluaXRpb25zIGZyb20gJy4vdGFza19kZWZpbml0aW9ucy5qc29uJztcblxuLy8gLS0tLS0gQ09OU1RBTlRTIC0tLS0tXG5jb25zdCBTVUJQUk9DRVNTT1JfVVJMX0tFWVdPUkRTID0gW1xuICAgICdzdWJwcm9jZXNzb3InLCAnc3ViLXByb2Nlc3NvcicsICdzdWJfcHJvY2Vzc29yJyxcbiAgICAndmVuZG9yLWxpc3QnLCAndmVuZG9ybGlzdCcsICd0aGlyZC1wYXJ0eS1saXN0JywgJ3RoaXJkcGFydHlsaXN0JyxcbiAgICAnc2VydmljZS1wcm92aWRlcnMnLCAnc2VydmljZXByb3ZpZGVycycsXG4gICAgJ2RwYS1leGhpYml0JywgJ2RwYS9leGhpYml0JywgJ2RhdGEtcHJvY2Vzc2luZy1hZGRlbmR1bS9leGhpYml0JyxcbiAgICAndHJ1c3QtY2VudGVyL3N1YicsICdsZWdhbC9zdWJwcm9jZXNzb3JzJ1xuXTtcblxuXG4vLyAtLS0tLSBTRVRUSU5HUyBJTlRFUkZBQ0UgQU5EIERFRkFVTFRTIC0tLS0tXG5pbnRlcmZhY2UgUHJvY2Vzc29yUHJvY2Vzc29yU2V0dGluZ3Mge1xuICAgIHNlcnBBcGlLZXk6IHN0cmluZztcbiAgICByaWdodGJyYWluQ2xpZW50SWQ6IHN0cmluZztcbiAgICByaWdodGJyYWluQ2xpZW50U2VjcmV0OiBzdHJpbmc7XG4gICAgcmlnaHRicmFpbk9yZ0lkOiBzdHJpbmc7XG4gICAgcmlnaHRicmFpblByb2plY3RJZDogc3RyaW5nO1xuICAgIHJpZ2h0YnJhaW5BcGlVcmw6IHN0cmluZztcbiAgICByaWdodGJyYWluT2F1dGgyVXJsOiBzdHJpbmc7XG4gICAgcmlnaHRicmFpblZlcmlmeVVybFRhc2tJZDogc3RyaW5nO1xuICAgIHJpZ2h0YnJhaW5FeHRyYWN0RW50aXRpZXNUYXNrSWQ6IHN0cmluZztcbiAgICByaWdodGJyYWluRXh0cmFjdElucHV0RmllbGQ6IHN0cmluZztcbiAgICByaWdodGJyYWluRXh0cmFjdE91dHB1dFRoaXJkUGFydHlGaWVsZDogc3RyaW5nO1xuICAgIHJpZ2h0YnJhaW5FeHRyYWN0T3V0cHV0T3duRW50aXRpZXNGaWVsZDogc3RyaW5nO1xuICAgIHJpZ2h0YnJhaW5EZWR1cGxpY2F0ZVN1YnByb2Nlc3NvcnNUYXNrSWQ6IHN0cmluZztcbiAgICByaWdodGJyYWluRHVja0R1Y2tHb1NlYXJjaFRhc2tJZDogc3RyaW5nO1xuICAgIGNyZWF0ZVBhZ2VzRm9yT3duRW50aXRpZXM6IGJvb2xlYW47XG4gICAgdmVyYm9zZURlYnVnOiBib29sZWFuO1xuICAgIG1heFJlc3VsdHNQZXJQcm9jZXNzb3I6IG51bWJlcjtcbiAgICBtYXhSZWN1cnNpdmVEZXB0aDogbnVtYmVyO1xuICAgIGRpc2NvdmVyeUNhY2hlRGF5czogbnVtYmVyO1xuICAgIHByb2Nlc3NvcnNGb2xkZXJQYXRoOiBzdHJpbmc7XG4gICAgYW5hbHlzaXNMb2dzRm9sZGVyUGF0aDogc3RyaW5nO1xuICAgIHJpZ2h0YnJhaW5GaW5kRHBhVGFza0lkOiBzdHJpbmc7XG4gICAgcmlnaHRicmFpbkZpbmRUb3NUYXNrSWQ6IHN0cmluZzsgXG4gICAgcmlnaHRicmFpbkZpbmRTZWN1cml0eVRhc2tJZDogc3RyaW5nO1xufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBQcm9jZXNzb3JQcm9jZXNzb3JTZXR0aW5ncyA9IHtcbiAgICBzZXJwQXBpS2V5OiAnJyxcbiAgICByaWdodGJyYWluQ2xpZW50SWQ6ICcnLFxuICAgIHJpZ2h0YnJhaW5DbGllbnRTZWNyZXQ6ICcnLFxuICAgIHJpZ2h0YnJhaW5PcmdJZDogJycsXG4gICAgcmlnaHRicmFpblByb2plY3RJZDogJycsXG4gICAgcmlnaHRicmFpbkFwaVVybDogJ2h0dHBzOi8vYXBwLnJpZ2h0YnJhaW4uYWkvYXBpL3YxJyxcbiAgICByaWdodGJyYWluT2F1dGgyVXJsOiAnaHR0cHM6Ly9vYXV0aC5yaWdodGJyYWluLmFpJyxcbiAgICByaWdodGJyYWluVmVyaWZ5VXJsVGFza0lkOiAnJyxcbiAgICByaWdodGJyYWluRXh0cmFjdEVudGl0aWVzVGFza0lkOiAnJyxcbiAgICByaWdodGJyYWluRXh0cmFjdElucHV0RmllbGQ6ICdwYWdlX3RleHQnLFxuICAgIHJpZ2h0YnJhaW5FeHRyYWN0T3V0cHV0VGhpcmRQYXJ0eUZpZWxkOiAndGhpcmRfcGFydHlfc3VicHJvY2Vzc29ycycsXG4gICAgcmlnaHRicmFpbkV4dHJhY3RPdXRwdXRPd25FbnRpdGllc0ZpZWxkOiAnb3duX2VudGl0aWVzJyxcbiAgICByaWdodGJyYWluRGVkdXBsaWNhdGVTdWJwcm9jZXNzb3JzVGFza0lkOiAnJyxcbiAgICByaWdodGJyYWluRHVja0R1Y2tHb1NlYXJjaFRhc2tJZDogJycsXG4gICAgY3JlYXRlUGFnZXNGb3JPd25FbnRpdGllczogZmFsc2UsXG4gICAgdmVyYm9zZURlYnVnOiBmYWxzZSxcbiAgICBtYXhSZXN1bHRzUGVyUHJvY2Vzc29yOiAxLFxuICAgIG1heFJlY3Vyc2l2ZURlcHRoOiAyLFxuICAgIGRpc2NvdmVyeUNhY2hlRGF5czogMzAsXG4gICAgcHJvY2Vzc29yc0ZvbGRlclBhdGg6ICdQcm9jZXNzb3JzJyxcbiAgICBhbmFseXNpc0xvZ3NGb2xkZXJQYXRoOiAnQW5hbHlzaXMgTG9ncycsXG4gICAgcmlnaHRicmFpbkZpbmREcGFUYXNrSWQ6ICcnLCBcbiAgICByaWdodGJyYWluRmluZFRvc1Rhc2tJZDogJycsIFxuICAgIHJpZ2h0YnJhaW5GaW5kU2VjdXJpdHlUYXNrSWQ6ICcnLFxufVxuXG4vLyAtLS0tLSBEQVRBIFNUUlVDVFVSRVMgLS0tLS1cbmludGVyZmFjZSBTZXJwQXBpUmVzdWx0IHtcbiAgICB0aXRsZTogc3RyaW5nOyB1cmw6IHN0cmluZzsgc25pcHBldDogc3RyaW5nOyBzZWFyY2hRdWVyeT86IHN0cmluZztcbiAgICBwcm9jZXNzb3JOYW1lOiBzdHJpbmc7IGRvY3VtZW50VHlwZTogc3RyaW5nO1xuICAgIHNvdXJjZURwYVVybD86IHN0cmluZztcbn1cbmludGVyZmFjZSBFeHRyYWN0ZWRSZWxhdGlvbnNoaXAge1xuICAgIFByaW1hcnlQcm9jZXNzb3I6IHN0cmluZzsgU3VicHJvY2Vzc29yTmFtZTogc3RyaW5nOyBQcm9jZXNzaW5nRnVuY3Rpb246IHN0cmluZztcbiAgICBMb2NhdGlvbjogc3RyaW5nOyBSZWxhdGlvbnNoaXBUeXBlOiAndXNlc19zdWJwcm9jZXNzb3InIHwgJ2lzX293bl9lbnRpdHknO1xuICAgIFNvdXJjZVVSTDogc3RyaW5nOyBWZXJpZmljYXRpb25SZWFzb25pbmc6IHN0cmluZztcbn1cbmludGVyZmFjZSBQcm9jZXNzZWRVcmxJbmZvIGV4dGVuZHMgUGFydGlhbDxTZXJwQXBpUmVzdWx0PiB7XG4gICAgdXJsOiBzdHJpbmc7IHRpdGxlPzogc3RyaW5nOyB2ZXJpZmljYXRpb25NZXRob2Q/OiBzdHJpbmc7IHZlcmlmaWNhdGlvblJlYXNvbmluZz86IHN0cmluZztcbiAgICBpc0xpc3Q/OiBib29sZWFuOyBpc0N1cnJlbnQ/OiBib29sZWFuOyBleHRyYWN0ZWRTdWJwcm9jZXNzb3JzQ291bnQ/OiBudW1iZXI7IGRvY3VtZW50VHlwZTogc3RyaW5nO1xufVxuaW50ZXJmYWNlIFNlYXJjaERhdGEge1xuICAgIGNvbGxlY3RlZFJlbGF0aW9uc2hpcHM6IEV4dHJhY3RlZFJlbGF0aW9uc2hpcFtdO1xuICAgIHByb2Nlc3NlZFVybERldGFpbHM6IFByb2Nlc3NlZFVybEluZm9bXTtcbiAgICBmbGFnZ2VkQ2FuZGlkYXRlVXJsQ291bnQ6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFN1YnByb2Nlc3NvclBhZ2VJbmZvIHtcbiAgICBmaWxlX3BhdGg6IHN0cmluZztcbiAgICBwYWdlX25hbWU6IHN0cmluZztcbiAgICBhbGlhc2VzOiBzdHJpbmdbXTtcbn1cblxuaW50ZXJmYWNlIERlZHVwbGljYXRpb25SZXN1bHRJdGVtIHtcbiAgICBzdXJ2aXZvcl9maWxlX3BhdGg6IHN0cmluZztcbiAgICBkdXBsaWNhdGVfZmlsZV9wYXRoczogc3RyaW5nW107XG4gICAgcmVhc29uaW5nPzogc3RyaW5nO1xufVxuXG5cbi8vIC0tLS0tIE1BSU4gUExVR0lOIENMQVNTIC0tLS0tXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9jZXNzb3JQcm9jZXNzb3JQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICAgIHNldHRpbmdzOiBQcm9jZXNzb3JQcm9jZXNzb3JTZXR0aW5ncztcbiAgICBwcml2YXRlIHByb2Nlc3NlZEluQ3VycmVudFJlY3Vyc2l2ZVNlYXJjaDogU2V0PHN0cmluZz47XG5cbiAgICBhc3luYyBvbmxvYWQoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkSW5DdXJyZW50UmVjdXJzaXZlU2VhcmNoID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cbiAgICAgICAgdGhpcy5hZGRSaWJib25JY29uKCdsaW5rJywgJ01hbnVhbGx5IEFkZCBTdWJwcm9jZXNzb3IgTGlzdCBVUkwnLCAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBuZXcgTWFudWFsSW5wdXRNb2RhbCh0aGlzLmFwcCwgYXN5bmMgKHByb2Nlc3Nvck5hbWUsIGxpc3RVcmwsIGlzUHJpbWFyeSkgPT4geyAvLyA8LS0gVXBkYXRlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc29yTmFtZSAmJiBsaXN0VXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYFByb2Nlc3NpbmcgbWFudWFsIFVSTCBpbnB1dCBmb3I6ICR7cHJvY2Vzc29yTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29yRmlsZSA9IGF3YWl0IHRoaXMuZW5zdXJlUHJvY2Vzc29yRmlsZShwcm9jZXNzb3JOYW1lLCB0cnVlLCBpc1ByaW1hcnkpOyAvLyA8LS0gUGFzcyBmbGFnXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzb3JGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2hEYXRhID0gYXdhaXQgdGhpcy5mZXRjaERhdGFGcm9tRGlyZWN0VXJsKHByb2Nlc3Nvck5hbWUsIGxpc3RVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RTdWJwcm9jZXNzb3JJbmZvKHByb2Nlc3Nvck5hbWUsIHByb2Nlc3NvckZpbGUsIHNlYXJjaERhdGEsIGlzUHJpbWFyeSk7IC8vIDwtLSBQYXNzIGZsYWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoRGF0YS5mbGFnZ2VkQ2FuZGlkYXRlVXJsQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYCR7c2VhcmNoRGF0YS5mbGFnZ2VkQ2FuZGlkYXRlVXJsQ291bnR9IFVSTChzKSBsb29rZWQgcHJvbWlzaW5nIGJ1dCBjb3VsZG4ndCBiZSB2ZXJpZmllZC4gQ2hlY2sgbG9ncy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYENvdWxkIG5vdCBwcm9jZXNzIGRhdGEgZnJvbSBkaXJlY3QgVVJMIGZvciAke3Byb2Nlc3Nvck5hbWV9LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgQ291bGQgbm90IGNyZWF0ZSBvciBmaW5kIGZpbGUgZm9yICR7cHJvY2Vzc29yTmFtZX0gaW4gJHt0aGlzLnNldHRpbmdzLnByb2Nlc3NvcnNGb2xkZXJQYXRofWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkub3BlbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZFJpYmJvbkljb24oJ3Bhc3RlJywgJ0lucHV0IFN1YnByb2Nlc3NvciBMaXN0IGZyb20gVGV4dCcsIChldnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMub3Blbk1hbnVhbFRleHRFbnRyeU1vZGFsKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ3J1bi1wcm9jZXNzb3Itc2VhcmNoLWdsb2JhbCcsXG4gICAgICAgICAgICBuYW1lOiAnU2VhcmNoIGZvciBTdWJwcm9jZXNzb3JzIChEaXNjb3ZlciknLFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBuZXcgU2VhcmNoTW9kYWwodGhpcy5hcHAsIHRoaXMuc2V0dGluZ3MsIGFzeW5jIChwcm9jZXNzb3JOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzb3JOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBTdGFydGluZyBkaXNjb3Zlcnkgc2VhcmNoIGZvcjogJHtwcm9jZXNzb3JOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29yRmlsZSA9IGF3YWl0IHRoaXMuZW5zdXJlUHJvY2Vzc29yRmlsZShwcm9jZXNzb3JOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzb3JGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXNjb3ZlckFuZFByb2Nlc3NQcm9jZXNzb3JQYWdlKHByb2Nlc3Nvck5hbWUsIHByb2Nlc3NvckZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBDb3VsZCBub3QgY3JlYXRlIG9yIGZpbmQgZmlsZSBmb3IgJHtwcm9jZXNzb3JOYW1lfSBpbiAke3RoaXMuc2V0dGluZ3MucHJvY2Vzc29yc0ZvbGRlclBhdGh9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5vcGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ2lucHV0LXN1YnByb2Nlc3Nvci1saXN0LWZyb20tdGV4dCcsXG4gICAgICAgICAgICBuYW1lOiAnSW5wdXQgU3VicHJvY2Vzc29yIExpc3QgZnJvbSBUZXh0JyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuTWFudWFsVGV4dEVudHJ5TW9kYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAncnVuLXByb2Nlc3Nvci1zZWFyY2gtcmVjdXJzaXZlJywgLy8gTmV3IElEXG4gICAgICAgICAgICBuYW1lOiAnU2VhcmNoIGZvciBTdWJwcm9jZXNzb3JzIChSZWN1cnNpdmUgRGlzY292ZXIpJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbmV3IFNlYXJjaE1vZGFsKHRoaXMuYXBwLCB0aGlzLnNldHRpbmdzLCBhc3luYyAocHJvY2Vzc29yTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc29yTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9uYWw6IEFkZCBhIHdheSBmb3IgdGhlIHVzZXIgdG8gc2V0IG1heERlcHRoLCBvciB1c2UgYSBkZWZhdWx0L3NldHRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzY292ZXJSZWN1cnNpdmVseShwcm9jZXNzb3JOYW1lLCB1bmRlZmluZWQsIHRoaXMucGx1Z2luLnNldHRpbmdzLm1heFJlY3Vyc2l2ZURlcHRoKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdmb3JjZS1tZXJnZS1wcm9jZXNzb3JzLWZyb20tcGFsZXR0ZScsXG4gICAgICAgICAgICBuYW1lOiAnRm9yY2UgTWVyZ2UgcHJvY2Vzc29yIGZpbGVzLi4uJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuRmlsZVNlbGVjdG9yTWVyZ2VNb2RhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdjb21wbGV0ZS1maXJzdC10aW1lLXNldHVwJyxcbiAgICAgICAgICAgIG5hbWU6ICdDb21wbGV0ZSBGaXJzdC1UaW1lIFNldHVwIChDcmVkZW50aWFscyAmIFRhc2tzKScsXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIG5ldyBQYXN0ZUVudk1vZGFsKHRoaXMuYXBwLCB0aGlzKS5vcGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5vbignZmlsZS1tZW51JywgKG1lbnU6IE1lbnUsIGZpbGVPckZvbGRlcjogVEZpbGUgfCBURm9sZGVyLCBzb3VyY2U6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIExvZ2ljIGZvciBzaW5nbGUgZm9sZGVyc1xuICAgICAgICAgICAgICAgIGlmIChmaWxlT3JGb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvbGRlciA9IGZpbGVPckZvbGRlciBhcyBURm9sZGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9sZGVyLnBhdGggPT09IHRoaXMuc2V0dGluZ3MucHJvY2Vzc29yc0ZvbGRlclBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbnUuYWRkSXRlbSgoaXRlbTogTWVudUl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFRpdGxlKCdEZWR1cGxpY2F0ZSBTdWJwcm9jZXNzb3IgUGFnZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbignZ2l0LXB1bGwtcmVxdWVzdC1kcmFmdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluRGVkdXBsaWNhdGVTdWJwcm9jZXNzb3JzVGFza0lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIkRlZHVwbGljYXRpb24gVGFzayBJRCBub3Qgc2V0IGluIHBsdWdpbiBzZXR0aW5ncy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgU3RhcnRpbmcgZGVkdXBsaWNhdGlvbiBmb3IgZm9sZGVyOiAke2ZvbGRlci5wYXRofWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5EZWR1cGxpY2F0aW9uRm9yRm9sZGVyKGZvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIC8vIExvZ2ljIGZvciBzaW5nbGUgZmlsZXNcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWxlT3JGb2xkZXIgaW5zdGFuY2VvZiBURmlsZSAmJiBmaWxlT3JGb2xkZXIuZXh0ZW5zaW9uID09PSAnbWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlT3JGb2xkZXIgYXMgVEZpbGU7XG4gICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS5wYXRoLnN0YXJ0c1dpdGgodGhpcy5zZXR0aW5ncy5wcm9jZXNzb3JzRm9sZGVyUGF0aCArIFwiL1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZUNhY2hlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9udG1hdHRlciA9IGZpbGVDYWNoZT8uZnJvbnRtYXR0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFByb2Nlc3Nvck5hbWUgPSAoZnJvbnRtYXR0ZXI/LmFsaWFzZXMgJiYgQXJyYXkuaXNBcnJheShmcm9udG1hdHRlci5hbGlhc2VzKSAmJiBmcm9udG1hdHRlci5hbGlhc2VzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmcm9udG1hdHRlci5hbGlhc2VzWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmaWxlLmJhc2VuYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW51LmFkZEl0ZW0oKGl0ZW06IE1lbnVJdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRUaXRsZSgnTWFwIFN1YnByb2Nlc3NvciBSZWxhdGlvbnNoaXBzJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldEljb24oJ2NoZXZyb25zLWRvd24tdXAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBTdGFydGluZyByZWN1cnNpdmUgZGlzY292ZXJ5IGZyb206ICR7b3JpZ2luYWxQcm9jZXNzb3JOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXNjb3ZlclJlY3Vyc2l2ZWx5KG9yaWdpbmFsUHJvY2Vzc29yTmFtZSwgZmlsZSwgdGhpcy5zZXR0aW5ncy5tYXhSZWN1cnNpdmVEZXB0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbnUuYWRkSXRlbSgoaXRlbTogTWVudUl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFRpdGxlKCdEaXNjb3ZlciBTdWJwcm9jZXNzb3IgTGlzdCcpLnNldEljb24oJ3dhbmQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBEaXNjb3ZlcmluZyBzdWJwcm9jZXNzb3IgbGlzdCBmb3I6ICR7b3JpZ2luYWxQcm9jZXNzb3JOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXNjb3ZlckFuZFByb2Nlc3NQcm9jZXNzb3JQYWdlKG9yaWdpbmFsUHJvY2Vzc29yTmFtZSwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbnUuYWRkSXRlbSgoaXRlbTogTWVudUl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFRpdGxlKCdFbnJpY2ggUHJvY2Vzc29yIERvY3VtZW50YXRpb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbignYm9vay1wbHVzJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgRW5yaWNoaW5nIGRvY3VtZW50YXRpb24gZm9yOiAke29yaWdpbmFsUHJvY2Vzc29yTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5yaWNoUHJvY2Vzc29yRmlsZShvcmlnaW5hbFByb2Nlc3Nvck5hbWUsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW51LmFkZEl0ZW0oKGl0ZW06IE1lbnVJdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRUaXRsZSgnQWRkIFN1YnByb2Nlc3NvciBMaXN0IFVSTCcpLnNldEljb24oJ3BsdXMtY2lyY2xlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE1hbnVhbElucHV0TW9kYWwodGhpcy5hcHAsIGFzeW5jIChwTmFtZSwgbGlzdFVybCwgaXNQcmltYXJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgUHJvY2Vzc2luZyBtYW51YWwgVVJMIGlucHV0IGZvcjogJHtvcmlnaW5hbFByb2Nlc3Nvck5hbWV9IHVzaW5nIFVSTDogJHtsaXN0VXJsfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2hEYXRhID0gYXdhaXQgdGhpcy5mZXRjaERhdGFGcm9tRGlyZWN0VXJsKG9yaWdpbmFsUHJvY2Vzc29yTmFtZSwgbGlzdFVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2hEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RTdWJwcm9jZXNzb3JJbmZvKG9yaWdpbmFsUHJvY2Vzc29yTmFtZSwgZmlsZSwgc2VhcmNoRGF0YSwgaXNQcmltYXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoRGF0YS5mbGFnZ2VkQ2FuZGlkYXRlVXJsQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgJHtzZWFyY2hEYXRhLmZsYWdnZWRDYW5kaWRhdGVVcmxDb3VudH0gVVJMKHMpIGxvb2tlZCBwcm9taXNpbmcgYnV0IGNvdWxkbid0IGJlIHZlcmlmaWVkLiBDaGVjayBsb2dzLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgQ291bGQgbm90IHByb2Nlc3MgZGF0YSBmcm9tIGRpcmVjdCBVUkwgZm9yICR7b3JpZ2luYWxQcm9jZXNzb3JOYW1lfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9yaWdpbmFsUHJvY2Vzc29yTmFtZSkub3BlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW51LmFkZEl0ZW0oKGl0ZW06IE1lbnVJdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRUaXRsZSgnSW5wdXQgU3VicHJvY2Vzc29yIExpc3QgZnJvbSBUZXh0Jykuc2V0SWNvbignZmlsZS1pbnB1dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3Blbk1hbnVhbFRleHRFbnRyeU1vZGFsKG9yaWdpbmFsUHJvY2Vzc29yTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgUHJvY2Vzc29yUHJvY2Vzc29yU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuICAgICAgICBjb25zb2xlLmxvZygnUHJvY2Vzc29yIFByb2Nlc3NvciBwbHVnaW4gbG9hZGVkLicpO1xuICAgIH1cblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICBjb25zb2xlLmxvZygnUHJvY2Vzc29yIFByb2Nlc3NvciBwbHVnaW4gdW5sb2FkZWQuJyk7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcbiAgICB9XG5cbiAgICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvcGVuTWFudWFsVGV4dEVudHJ5TW9kYWwoaW5pdGlhbFByb2Nlc3Nvck5hbWU/OiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5FeHRyYWN0RW50aXRpZXNUYXNrSWQpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJSaWdodEJyYWluIFRhc2sgSUQgZm9yIGVudGl0eSBleHRyYWN0aW9uIGlzIG5vdCBjb25maWd1cmVkLiBQbGVhc2Ugc2V0IGl0IGluIHBsdWdpbiBzZXR0aW5ncy5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV3IE1hbnVhbFRleHRFbnRyeU1vZGFsKHRoaXMuYXBwLCBhc3luYyAocHJvY2Vzc29yTmFtZSwgcGFzdGVkVGV4dCwgaXNQcmltYXJ5KSA9PiB7IFxuICAgICAgICAgICAgaWYgKHByb2Nlc3Nvck5hbWUgJiYgcGFzdGVkVGV4dCkge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYFByb2Nlc3NpbmcgcGFzdGVkIHRleHQgZm9yOiAke3Byb2Nlc3Nvck5hbWV9YCk7XG4gICAgICAgICAgICAgICAgLy8gUGFzcyB0aGUgJ2lzUHJpbWFyeScgZmxhZyB0byBlbnN1cmUgdGhlIGNvcnJlY3QgdGFnIGlzIGFwcGxpZWRcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzb3JGaWxlID0gYXdhaXQgdGhpcy5lbnN1cmVQcm9jZXNzb3JGaWxlKHByb2Nlc3Nvck5hbWUsIHRydWUsIGlzUHJpbWFyeSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NvckZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoRGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2hEYXRhRnJvbVBhc3RlZFRleHQocHJvY2Vzc29yTmFtZSwgcGFzdGVkVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2hEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIHRoZSAnaXNQcmltYXJ5JyBmbGFnIGhlcmUgYXMgd2VsbCBmb3IgY29uc2lzdGVuY3lcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdFN1YnByb2Nlc3NvckluZm8ocHJvY2Vzc29yTmFtZSwgcHJvY2Vzc29yRmlsZSwgc2VhcmNoRGF0YSwgaXNQcmltYXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYENvdWxkIG5vdCBwcm9jZXNzIGRhdGEgZnJvbSBwYXN0ZWQgdGV4dCBmb3IgJHtwcm9jZXNzb3JOYW1lfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYENvdWxkIG5vdCBjcmVhdGUgb3IgZmluZCBmaWxlIGZvciAke3Byb2Nlc3Nvck5hbWV9IGluICR7dGhpcy5zZXR0aW5ncy5wcm9jZXNzb3JzRm9sZGVyUGF0aH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGluaXRpYWxQcm9jZXNzb3JOYW1lKS5vcGVuKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzYW5pdGl6ZU5hbWVGb3JGaWxlUGF0aEFuZEFsaWFzKGVudGl0eU5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwpOiB7IGZpbGVQYXRoTmFtZTogc3RyaW5nLCBvcmlnaW5hbE5hbWVBc0FsaWFzOiBzdHJpbmcgfSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTmFtZSA9IChlbnRpdHlOYW1lIHx8IFwiVW5rbm93biBFbnRpdHlcIikudHJpbSgpO1xuICAgICAgICBsZXQgYmFzZU5hbWVGb3JGaWxlID0gb3JpZ2luYWxOYW1lO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBcImRiYVwiIHBhdHRlcm5zIHRvIHByaW9yaXRpemUgdGhlIFwiZG9pbmcgYnVzaW5lc3MgYXNcIiBuYW1lIGZvciB0aGUgZmlsZVxuICAgICAgICBjb25zdCBkYmFSZWdleCA9IC9eKC4qPylcXHMrKD86ZGJhfGRcXC9iXFwvYXxkb2luZyBidXNpbmVzcyBhcylcXHMrKC4qKSQvaTtcbiAgICAgICAgY29uc3QgZGJhTWF0Y2ggPSBvcmlnaW5hbE5hbWUubWF0Y2goZGJhUmVnZXgpO1xuICAgICAgICBpZiAoZGJhTWF0Y2ggJiYgZGJhTWF0Y2hbMl0pIHsgLy8gZGJhTWF0Y2hbMl0gaXMgdGhlIG5hbWUgYWZ0ZXIgJ2RiYSdcbiAgICAgICAgICAgIGJhc2VOYW1lRm9yRmlsZSA9IGRiYU1hdGNoWzJdLnRyaW0oKTsgLy8gVXNlIHRoaXMgYXMgdGhlIGJhc2UgZm9yIHRoZSBmaWxlbmFtZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIGNvbW1hcyBmcm9tIHRoZSBiYXNlIG5hbWUgZm9yIHRoZSBmaWxlLCBhcyB0aGV5IGNhbiBiZSBwcm9ibGVtYXRpYyBpbiBsaW5rcy90YWdzXG4gICAgICAgIGxldCBmaWxlUGF0aE5hbWUgPSBiYXNlTmFtZUZvckZpbGUucmVwbGFjZSgvLC9nLCAnJyk7XG4gICAgICAgIC8vIFJlcGxhY2UgY2hhcmFjdGVycyBmb3JiaWRkZW4gaW4gZmlsZSBwYXRoc1xuICAgICAgICBmaWxlUGF0aE5hbWUgPSBmaWxlUGF0aE5hbWUucmVwbGFjZSgvW1xcXFwvOio/XCI8PnxdL2csICcnKS50cmltKCk7XG5cbiAgICAgICAgLy8gSWYgZmlsZVBhdGhOYW1lIGJlY29tZXMgZW1wdHkgYWZ0ZXIgc2FuaXRpemF0aW9uIChlLmcuLCBuYW1lIHdhcyBqdXN0IFwiLy8vXCIpLFxuICAgICAgICAvLyB1c2UgYSBzYW5pdGl6ZWQgdmVyc2lvbiBvZiB0aGUgb3JpZ2luYWwgZnVsbCBuYW1lIG9yIGEgZmFsbGJhY2suXG4gICAgICAgIGlmICghZmlsZVBhdGhOYW1lKSB7XG4gICAgICAgICAgICBmaWxlUGF0aE5hbWUgPSBvcmlnaW5hbE5hbWUucmVwbGFjZSgvW1xcXFwvOio/XCI8PnwsXS9nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnXycpIHx8IFwiU2FuaXRpemVkX0VudGl0eVwiO1xuICAgICAgICB9XG4gICAgICAgICBpZiAoIWZpbGVQYXRoTmFtZSkgeyAvLyBGaW5hbCBmYWxsYmFjayBpZiBpdCdzIHN0aWxsIHNvbWVob3cgZW1wdHlcbiAgICAgICAgICAgIGZpbGVQYXRoTmFtZSA9IFwiU2FuaXRpemVkX0VudGl0eV9cIiArIERhdGUubm93KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsZVBhdGhOYW1lOiBmaWxlUGF0aE5hbWUsXG4gICAgICAgICAgICBvcmlnaW5hbE5hbWVBc0FsaWFzOiBvcmlnaW5hbE5hbWUgLy8gVGhlIG9yaWdpbmFsIGZ1bGwgbmFtZSBpcyBhbHdheXMgdXNlZCBhcyBhbiBhbGlhc1xuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBzY3J1Ykh5cGVybGlua3ModGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCk6IHN0cmluZyB7XG4gICAgICAgIGlmICghdGV4dCkgcmV0dXJuIFwiTi9BXCI7IC8vIFJldHVybiBcIk4vQVwiIGlmIGlucHV0IGlzIG51bGwsIHVuZGVmaW5lZCwgb3IgZW1wdHlcbiAgICAgICAgbGV0IHNjcnViYmVkVGV4dCA9IFN0cmluZyh0ZXh0KTsgLy8gRW5zdXJlIGl0J3MgYSBzdHJpbmdcblxuICAgICAgICAvLyBSZW1vdmUgTWFya2Rvd24gbGlua3M6IFtsaW5rIHRleHRdKHVybCkgLT4gbGluayB0ZXh0XG4gICAgICAgIHNjcnViYmVkVGV4dCA9IHNjcnViYmVkVGV4dC5yZXBsYWNlKC9cXFsoLio/KVxcXVxcKCg/Oi4qPylcXCkvZywgJyQxJyk7XG4gICAgICAgIC8vIFJlbW92ZSBIVE1MIGxpbmtzOiA8YSBocmVmPVwiLi4uXCI+bGluayB0ZXh0PC9hPiAtPiBsaW5rIHRleHRcbiAgICAgICAgc2NydWJiZWRUZXh0ID0gc2NydWJiZWRUZXh0LnJlcGxhY2UoLzxhW14+XSo+KC4qPyk8XFwvYT4vZ2ksICckMScpO1xuICAgICAgICAvLyBTdHJpcCBhbnkgcmVtYWluaW5nIEhUTUwgdGFnc1xuICAgICAgICBzY3J1YmJlZFRleHQgPSBzY3J1YmJlZFRleHQucmVwbGFjZSgvPFtePl0rPi9nLCAnJyk7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB3aGl0ZXNwYWNlIChtdWx0aXBsZSBzcGFjZXMvbmV3bGluZXMgdG8gc2luZ2xlIHNwYWNlKVxuICAgICAgICBzY3J1YmJlZFRleHQgPSBzY3J1YmJlZFRleHQucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcblxuICAgICAgICByZXR1cm4gc2NydWJiZWRUZXh0IHx8IFwiTi9BXCI7IC8vIFJldHVybiBcIk4vQVwiIGlmIHRoZSByZXN1bHQgaXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGFkZFJlbGF0aW9uc2hpcChcbiAgICAgICAgY29sbGVjdGVkUmVsYXRpb25zaGlwczogRXh0cmFjdGVkUmVsYXRpb25zaGlwW10sXG4gICAgICAgIHNlZW5SZWxhdGlvbnNoaXBzOiBTZXQ8c3RyaW5nPiwgLy8gVG8gdHJhY2sgdW5pcXVlIChQcmltYXJ5UHJvY2Vzc29yLCBTdWJwcm9jZXNzb3JOYW1lLCBUeXBlKSB0dXBsZXNcbiAgICAgICAgcHJvY2Vzc29yTmFtZTogc3RyaW5nLCAgICAgICAgICAvLyBUaGUgbmFtZSBvZiB0aGUgcHJpbWFyeSBwcm9jZXNzb3IgdGhpcyByZWxhdGlvbnNoaXAgcGVydGFpbnMgdG9cbiAgICAgICAgZW50aXR5OiBhbnksICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmF3IGVudGl0eSBvYmplY3QgKGUuZy4sIGZyb20gUmlnaHRCcmFpbilcbiAgICAgICAgdHlwZTogRXh0cmFjdGVkUmVsYXRpb25zaGlwWydSZWxhdGlvbnNoaXBUeXBlJ10sIC8vICd1c2VzX3N1YnByb2Nlc3Nvcicgb3IgJ2lzX293bl9lbnRpdHknXG4gICAgICAgIHNvdXJjZVVybDogc3RyaW5nLCAgICAgICAgICAgICAgLy8gVGhlIFVSTCB3aGVyZSB0aGlzIGluZm9ybWF0aW9uIHdhcyBmb3VuZC92ZXJpZmllZFxuICAgICAgICB2ZXJpZmljYXRpb25SZWFzb25pbmc6IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwgLy8gUmVhc29uaW5nIGZyb20gdmVyaWZpY2F0aW9uLCBpZiBhbnlcbiAgICApOiBudW1iZXIgeyAvLyBSZXR1cm5zIDEgaWYgYSBuZXcgcmVsYXRpb25zaGlwIHdhcyBhZGRlZCwgMCBvdGhlcndpc2VcblxuICAgICAgICBjb25zdCBvcmlnaW5hbEVudGl0eU5hbWUgPSBlbnRpdHkubmFtZT8udHJpbSgpO1xuICAgICAgICBpZiAoIW9yaWdpbmFsRW50aXR5TmFtZSkgcmV0dXJuIDA7IC8vIFNraXAgaWYgbm8gbmFtZVxuXG4gICAgICAgIC8vIFVzZSB0aGUgb3JpZ2luYWwsIHVuYWx0ZXJlZCBlbnRpdHkgbmFtZSBmb3Igc3RvcmFnZSBhbmQgY29tcGFyaXNvblxuICAgICAgICAvLyBUaGUgc2FuaXRpemF0aW9uIGZvciBmaWxlIHBhdGhzIHdpbGwgaGFwcGVuIGxhdGVyIHdoZW4gY3JlYXRpbmcgZmlsZXMuXG4gICAgICAgIGNvbnN0IHN1YnByb2Nlc3Nvck5hbWVUb1N0b3JlID0gb3JpZ2luYWxFbnRpdHlOYW1lO1xuXG4gICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIE9wZW5BSSAtIHNraXAgaWYgaXQncyBpZGVudGlmeWluZyBpdHMgb3duIGtub3duIGFmZmlsaWF0ZXMgYXMgXCJvd25fZW50aXR5XCJcbiAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBPcGVuQUkgZnJvbSBsaXN0aW5nIGl0c2VsZiBvciBpdHMgY29yZSBjb21wb25lbnRzIGFzIGlmIHRoZXkgd2VyZSBkaXN0aW5jdCBzdWJwcm9jZXNzb3JzICpvZiBpdHNlbGYqLlxuICAgICAgICBpZiAocHJvY2Vzc29yTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcIm9wZW5haVwiICYmIHR5cGUgPT09IFwiaXNfb3duX2VudGl0eVwiKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVuYWlBZmZpbGlhdGVzID0gW1wib3BlbmFpIGdsb2JhbFwiLCBcIm9wZW5haSwgb3Bjb1wiLCBcIm9wZW5haSBpcmVsYW5kXCIsIFwib3BlbmFpIHVrXCIsIFwib3BlbmFpIGphcGFuXCIsIFwib3BlbmFpZ2xvYmFsXCIsIFwib3BlbmFpIG9wY29cIiwgXCJvcGVuYWkgbGxjXCJdO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGVudGl0eSBuYW1lIGxvb2tzIGxpa2Ugb25lIG9mIE9wZW5BSSdzIG93biBjb21tb24gbmFtZXMvYWZmaWxpYXRlcywgZG9uJ3QgYWRkIGl0IGFzIGFuIFwib3duX2VudGl0eVwiIHJlbGF0aW9uc2hpcCBmb3IgT3BlbkFJLlxuICAgICAgICAgICAgaWYgKG9wZW5haUFmZmlsaWF0ZXMuc29tZShhZmYgPT4gb3JpZ2luYWxFbnRpdHlOYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoYWZmKSkgfHwgb3JpZ2luYWxFbnRpdHlOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwib3BlbmFpXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBTa2lwcGluZyBhZGRpbmcgJyR7b3JpZ2luYWxFbnRpdHlOYW1lfScgYXMgb3duX2VudGl0eSBmb3IgT3BlbkFJIGR1ZSB0byBzZWxmLXJlZmVyZW5jZS9hZmZpbGlhdGUgcnVsZS5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgdW5pcXVlIHR1cGxlIGZvciB0aGlzIHJlbGF0aW9uc2hpcCB0byBhdm9pZCBkdXBsaWNhdGVzICp3aXRoaW4gdGhlIGN1cnJlbnQgcHJvY2Vzc2luZyBydW4qXG4gICAgICAgIGNvbnN0IHJlbFR1cGxlID0gYCR7cHJvY2Vzc29yTmFtZX18JHtzdWJwcm9jZXNzb3JOYW1lVG9TdG9yZX18JHt0eXBlfWA7XG5cbiAgICAgICAgaWYgKCFzZWVuUmVsYXRpb25zaGlwcy5oYXMocmVsVHVwbGUpKSB7XG4gICAgICAgICAgICBjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzLnB1c2goe1xuICAgICAgICAgICAgICAgIFByaW1hcnlQcm9jZXNzb3I6IHByb2Nlc3Nvck5hbWUsXG4gICAgICAgICAgICAgICAgU3VicHJvY2Vzc29yTmFtZTogc3VicHJvY2Vzc29yTmFtZVRvU3RvcmUsIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBuYW1lXG4gICAgICAgICAgICAgICAgUHJvY2Vzc2luZ0Z1bmN0aW9uOiB0aGlzLnNjcnViSHlwZXJsaW5rcyhlbnRpdHkucHJvY2Vzc2luZ19mdW5jdGlvbiksXG4gICAgICAgICAgICAgICAgTG9jYXRpb246IHRoaXMuc2NydWJIeXBlcmxpbmtzKGVudGl0eS5sb2NhdGlvbiksXG4gICAgICAgICAgICAgICAgUmVsYXRpb25zaGlwVHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBTb3VyY2VVUkw6IHNvdXJjZVVybCxcbiAgICAgICAgICAgICAgICBWZXJpZmljYXRpb25SZWFzb25pbmc6IHRoaXMuc2NydWJIeXBlcmxpbmtzKHZlcmlmaWNhdGlvblJlYXNvbmluZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VlblJlbGF0aW9uc2hpcHMuYWRkKHJlbFR1cGxlKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuXG4gICAgYXN5bmMgZGlzY292ZXJBbmRQcm9jZXNzUHJvY2Vzc29yUGFnZShwcm9jZXNzb3JOYW1lOiBzdHJpbmcsIHByb2Nlc3NvckZpbGU6IFRGaWxlKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYFByb2Nlc3NpbmcgKGRpc2NvdmVyeSk6ICR7cHJvY2Vzc29yTmFtZX0uLi5gKTtcbiAgICAgICAgY29uc3Qgc2VhcmNoRGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2hQcm9jZXNzb3JTZWFyY2hEYXRhV2l0aERpc2NvdmVyeShwcm9jZXNzb3JOYW1lKTtcblxuICAgICAgICBpZiAoc2VhcmNoRGF0YSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0U3VicHJvY2Vzc29ySW5mbyhwcm9jZXNzb3JOYW1lLCBwcm9jZXNzb3JGaWxlLCBzZWFyY2hEYXRhKTtcbiAgICAgICAgICAgIGlmIChzZWFyY2hEYXRhLmZsYWdnZWRDYW5kaWRhdGVVcmxDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGAke3NlYXJjaERhdGEuZmxhZ2dlZENhbmRpZGF0ZVVybENvdW50fSBVUkwocykgbG9va2VkIHByb21pc2luZyBidXQgY291bGRuJ3QgYmUgdmVyaWZpZWQuIENoZWNrIEFuYWx5c2lzIExvZyBmb3IgZGV0YWlscyBhbmQgY29uc2lkZXIgdXNpbmcgdGhlICdJbnB1dCBmcm9tIFRleHQnIGZlYXR1cmUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBGYWlsZWQgdG8gZmV0Y2ggZGF0YSB2aWEgZGlzY292ZXJ5IGZvciAke3Byb2Nlc3Nvck5hbWV9LmApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZW5yaWNoUHJvY2Vzc29yRmlsZShwcm9jZXNzb3JOYW1lOiBzdHJpbmcsIGZpbGU6IFRGaWxlKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYEZldGNoaW5nIGNvbXBsaWFuY2UgZG9jdW1lbnRzIGZvciAke3Byb2Nlc3Nvck5hbWV9Li4uYCwgNTAwMCk7XG4gICAgICAgIGNvbnN0IHJiVG9rZW4gPSBhd2FpdCB0aGlzLmdldFJpZ2h0QnJhaW5BY2Nlc3NUb2tlbigpO1xuICAgICAgICBpZiAoIXJiVG9rZW4pIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJGYWlsZWQgdG8gZ2V0IFJpZ2h0QnJhaW4gdG9rZW4uIEFib3J0aW5nIGVucmljaG1lbnQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZG9jdW1lbnRUeXBlcyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogJ0RQQScsIHRhc2tJZDogdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluRmluZERwYVRhc2tJZCwgdGl0bGU6IFwiRGF0YSBQcm9jZXNzaW5nIEFncmVlbWVudFwiIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdUb1MnLCB0YXNrSWQ6IHRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkZpbmRUb3NUYXNrSWQsIHRpdGxlOiBcIlRlcm1zIG9mIFNlcnZpY2VcIiB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnU2VjdXJpdHknLCB0YXNrSWQ6IHRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkZpbmRTZWN1cml0eVRhc2tJZCwgdGl0bGU6IFwiU2VjdXJpdHkgRG9jdW1lbnRhdGlvblwiIH1cbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBmb3VuZERvY3VtZW50czogeyB0aXRsZTogc3RyaW5nLCB1cmw6IHN0cmluZyB9W10gPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiBkb2N1bWVudFR5cGVzKSB7XG4gICAgICAgICAgICBpZiAoIWRvYy50YXNrSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBTa2lwcGluZyAke2RvYy50eXBlfSBzZWFyY2ggZm9yICR7cHJvY2Vzc29yTmFtZX0sIG5vIFRhc2sgSUQgc2V0LmApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0YXNrSW5wdXRQYXlsb2FkID0geyBcImNvbXBhbnlfbmFtZVwiOiBwcm9jZXNzb3JOYW1lIH07XG4gICAgICAgICAgICBjb25zdCB0YXNrUmVzdWx0ID0gYXdhaXQgdGhpcy5jYWxsUmlnaHRCcmFpblRhc2soZG9jLnRhc2tJZCwgdGFza0lucHV0UGF5bG9hZCwgcmJUb2tlbik7XG5cbiAgICAgICAgICAgIC8vIEFzc3VtaW5nIHRoZSBSaWdodEJyYWluIHRhc2sgcmV0dXJucyBhIHNpbXBsZSB7IFwidXJsXCI6IFwiLi4uXCIgfSBvYmplY3RcbiAgICAgICAgICAgIGlmICh0YXNrUmVzdWx0Py5yZXNwb25zZT8udXJsICYmIHRoaXMuaXNWYWxpZFVybCh0YXNrUmVzdWx0LnJlc3BvbnNlLnVybCkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZERvY3VtZW50cy5wdXNoKHsgdGl0bGU6IGRvYy50aXRsZSwgdXJsOiB0YXNrUmVzdWx0LnJlc3BvbnNlLnVybCB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBGb3VuZCAke2RvYy50eXBlfSBmb3IgJHtwcm9jZXNzb3JOYW1lfTogJHt0YXNrUmVzdWx0LnJlc3BvbnNlLnVybH1gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIHZhbGlkIFVSTCBmb3IgJHtkb2MudHlwZX0gZm9yICR7cHJvY2Vzc29yTmFtZX0uIFJlc3VsdDpgLCB0YXNrUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTsgLy8gU21hbGwgZGVsYXkgYmV0d2VlbiB0YXNrc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvdW5kRG9jdW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbmV3IE5vdGljZShgTm8gbmV3IGNvbXBsaWFuY2UgZG9jdW1lbnRzIGZvdW5kIGZvciAke3Byb2Nlc3Nvck5hbWV9LmApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9ybWF0IHRoZSByZXN1bHRzIGludG8gYSBtYXJrZG93biBsaXN0XG4gICAgICAgIGxldCBtYXJrZG93bkNvbnRlbnQgPSBcIlxcblwiOyAvLyBTdGFydCB3aXRoIGEgbmV3bGluZSB0byBlbnN1cmUgc2VwYXJhdGlvblxuICAgICAgICBmb3VuZERvY3VtZW50cy5mb3JFYWNoKGRvYyA9PiB7XG4gICAgICAgICAgICBtYXJrZG93bkNvbnRlbnQgKz0gYC0gKioke2RvYy50aXRsZX06KiogWyR7ZG9jLnVybH1dKCR7ZG9jLnVybH0pXFxuYDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXNlIGVuc3VyZUhlYWRpbmdBbmRTZWN0aW9uIHRvIGFwcGVuZCB0byB0aGUgZmlsZVxuICAgICAgICBjb25zdCBoZWFkaW5nID0gXCJDb21wbGlhbmNlIERvY3VtZW50YXRpb25cIjtcbiAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQucHJvY2VzcyhmaWxlLCAoY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAvLyBUaGUgJ3RydWUnIGF0IHRoZSBlbmQgdGVsbHMgdGhlIGZ1bmN0aW9uIHRvIGFwcGVuZCB1bmRlciB0aGUgaGVhZGluZyBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgY3JlYXRpbmcgZHVwbGljYXRlIHNlY3Rpb25zIGlmIHlvdSBydW4gZW5yaWNobWVudCBtdWx0aXBsZSB0aW1lcy5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUhlYWRpbmdBbmRTZWN0aW9uKGNvbnRlbnQsIGhlYWRpbmcsIG1hcmtkb3duQ29udGVudCwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBOb3RpY2UoYFN1Y2Nlc3NmdWxseSBhZGRlZCAke2ZvdW5kRG9jdW1lbnRzLmxlbmd0aH0gZG9jdW1lbnQgbGluayhzKSB0byAke3Byb2Nlc3Nvck5hbWV9LmApO1xuICAgIH1cblxuICAgIGFzeW5jIHNldHVwUmlnaHRCcmFpblRhc2tzKGNyZWRzOiB7IGFwaVVybDogc3RyaW5nLCBvYXV0aFVybDogc3RyaW5nLCBjbGllbnRJZDogc3RyaW5nLCBjbGllbnRTZWNyZXQ6IHN0cmluZywgb3JnSWQ6IHN0cmluZywgcHJvamVjdElkOiBzdHJpbmcgfSkge1xuICAgICAgICBuZXcgTm90aWNlKFwiU3RhcnRpbmcgUmlnaHRCcmFpbiB0YXNrIHNldHVwLi4uXCIsIDMwMDApO1xuICAgIFxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbm93IHVzZSB0aGUgY3JlZGVudGlhbHMgcGFzc2VkIGRpcmVjdGx5IHRvIGl0XG4gICAgICAgIGNvbnN0IHJiVG9rZW4gPSBhd2FpdCB0aGlzLmdldFJpZ2h0QnJhaW5BY2Nlc3NUb2tlbihjcmVkcyk7XG4gICAgICAgIGlmICghcmJUb2tlbikge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIlNldHVwIGZhaWxlZDogQ291bGQgbm90IGdldCBSaWdodEJyYWluIEFjY2VzcyBUb2tlbiB3aXRoIHByb3ZpZGVkIGNyZWRlbnRpYWxzLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBjb25zdCBleGlzdGluZ1Rhc2tzID0gYXdhaXQgdGhpcy5saXN0QWxsUmlnaHRCcmFpblRhc2tzKHJiVG9rZW4sIGNyZWRzKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nVGFza3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJTZXR1cCBmYWlsZWQ6IENvdWxkIG5vdCByZXRyaWV2ZSBleGlzdGluZyB0YXNrcyBmcm9tIFJpZ2h0QnJhaW4uXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVGFza05hbWVzID0gbmV3IFNldChleGlzdGluZ1Rhc2tzLm1hcCh0YXNrID0+IHRhc2submFtZSkpO1xuICAgICAgICBsZXQgdGFza3NDcmVhdGVkID0gMDtcbiAgICAgICAgbGV0IHRhc2tzU2tpcHBlZCA9IDA7XG4gICAgXG4gICAgICAgIGZvciAoY29uc3QgdGFza0RlZiBvZiB0YXNrRGVmaW5pdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1Rhc2tOYW1lcy5oYXModGFza0RlZi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYFRhc2sgJyR7dGFza0RlZi5uYW1lfScgYWxyZWFkeSBleGlzdHMuIFNraXBwaW5nLmApO1xuICAgICAgICAgICAgICAgIHRhc2tzU2tpcHBlZCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBDcmVhdGluZyB0YXNrOiAnJHt0YXNrRGVmLm5hbWV9Jy4uLmApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRUYXNrID0gYXdhaXQgdGhpcy5jcmVhdGVSaWdodEJyYWluVGFzayhyYlRva2VuLCB0YXNrRGVmLCBjcmVkcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0ZWRUYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzQ3JlYXRlZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICBuZXcgTm90aWNlKGBTZXR1cCBjb21wbGV0ZS4gQ3JlYXRlZDogJHt0YXNrc0NyZWF0ZWR9IHRhc2socyksIFNraXBwZWQ6ICR7dGFza3NTa2lwcGVkfSBleGlzdGluZyB0YXNrKHMpLmAsIDEwMDAwKTtcbiAgICB9XG4gICAgXG4gICAgXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIGxpc3Qgb2YgYWxsIHRhc2tzIGZyb20gdGhlIGNvbmZpZ3VyZWQgUmlnaHRCcmFpbiBwcm9qZWN0LlxuICAgICAqIEBwYXJhbSByYlRva2VuIFRoZSBSaWdodEJyYWluIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0YXNrIG9iamVjdHMgb3IgbnVsbCBpZiBhbiBlcnJvciBvY2N1cnMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBsaXN0QWxsUmlnaHRCcmFpblRhc2tzKHJiVG9rZW46IHN0cmluZywgY3JlZHM6IHsgYXBpVXJsOiBzdHJpbmcsIG9yZ0lkOiBzdHJpbmcsIHByb2plY3RJZDogc3RyaW5nIH0pOiBQcm9taXNlPGFueVtdIHwgbnVsbD4ge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIG5vdyB1c2VzIHRoZSAnY3JlZHMnIG9iamVjdCB0byBidWlsZCB0aGUgVVJMXG4gICAgICAgIGNvbnN0IHRhc2tzVXJsID0gYCR7Y3JlZHMuYXBpVXJsfS9vcmcvJHtjcmVkcy5vcmdJZH0vcHJvamVjdC8ke2NyZWRzLnByb2plY3RJZH0vdGFza2A7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7ICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3JiVG9rZW59YCB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoeyB1cmw6IHRhc2tzVXJsLCBtZXRob2Q6ICdHRVQnLCBoZWFkZXJzOiBoZWFkZXJzLCB0aHJvdzogZmFsc2UgfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbi50YXNrcyB8fCBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBsaXN0IFJpZ2h0QnJhaW4gdGFza3M6XCIsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UudGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgUmlnaHRCcmFpbiB0YXNrczpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNpbmdsZSBuZXcgdGFzayBpbiBSaWdodEJyYWluIHVzaW5nIGEgcHJvdmlkZWQgZGVmaW5pdGlvbi5cbiAgICAgKiBAcGFyYW0gcmJUb2tlbiBUaGUgUmlnaHRCcmFpbiBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHRhc2tEZWZpbml0aW9uIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmdWxsIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBuZXcgdGFzay5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB0YXNrIG9iamVjdCBvciBudWxsIGlmIGFuIGVycm9yIG9jY3Vycy5cbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIGNyZWF0ZVJpZ2h0QnJhaW5UYXNrKHJiVG9rZW46IHN0cmluZywgdGFza0RlZmluaXRpb246IGFueSwgY3JlZHM6IHsgYXBpVXJsOiBzdHJpbmcsIG9yZ0lkOiBzdHJpbmcsIHByb2plY3RJZDogc3RyaW5nIH0pOiBQcm9taXNlPGFueSB8IG51bGw+IHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBhbHNvIHVzZXMgdGhlICdjcmVkcycgb2JqZWN0IG5vd1xuICAgICAgICBjb25zdCBjcmVhdGVVcmwgPSBgJHtjcmVkcy5hcGlVcmx9L29yZy8ke2NyZWRzLm9yZ0lkfS9wcm9qZWN0LyR7Y3JlZHMucHJvamVjdElkfS90YXNrYDtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3JiVG9rZW59YCxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0VXJsKHtcbiAgICAgICAgICAgICAgICB1cmw6IGNyZWF0ZVVybCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRhc2tEZWZpbml0aW9uKSxcbiAgICAgICAgICAgICAgICB0aHJvdzogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDEgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBTdWNjZXNzZnVsbHkgY3JlYXRlZCB0YXNrOiAnJHt0YXNrRGVmaW5pdGlvbi5uYW1lfSdgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShgRmFpbGVkIHRvIGNyZWF0ZSB0YXNrICcke3Rhc2tEZWZpbml0aW9uLm5hbWV9JzogJHtyZXNwb25zZS5zdGF0dXN9YCwgNzAwMCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY3JlYXRpbmcgdGFzayAnJHt0YXNrRGVmaW5pdGlvbi5uYW1lfSc6YCwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS50ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYE5ldHdvcmsgZXJyb3IgY3JlYXRpbmcgdGFzayAnJHt0YXNrRGVmaW5pdGlvbi5uYW1lfSc6YCwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBwZXJzaXN0U3VicHJvY2Vzc29ySW5mbyhwcm9jZXNzb3JOYW1lOiBzdHJpbmcsIHByb2Nlc3NvckZpbGU6IFRGaWxlLCBzZWFyY2hEYXRhOiBTZWFyY2hEYXRhLCBpc1RvcExldmVsUHJvY2Vzc29yOiBib29sZWFuID0gdHJ1ZSwgbWVyZ2VEZWNpc2lvbnM6IHN0cmluZ1tdID0gW10pIHtcbiAgICAgICAgbmV3IE5vdGljZShgUGVyc2lzdGluZyBpbmZvIGZvcjogJHtwcm9jZXNzb3JOYW1lfS4uLmApO1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUZvbGRlckV4aXN0cyh0aGlzLnNldHRpbmdzLnByb2Nlc3NvcnNGb2xkZXJQYXRoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVGb2xkZXJFeGlzdHModGhpcy5zZXR0aW5ncy5hbmFseXNpc0xvZ3NGb2xkZXJQYXRoKTtcblxuICAgICAgICBjb25zdCB7IGNvbGxlY3RlZFJlbGF0aW9uc2hpcHMsIHByb2Nlc3NlZFVybERldGFpbHMgfSA9IHNlYXJjaERhdGE7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBtYWluIHByb2Nlc3NvciBmaWxlIChlLmcuLCBcIk9wZW5BSS5tZFwiKVxuICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZVByb2Nlc3NvckZpbGUocHJvY2Vzc29yRmlsZSwgcHJvY2Vzc29yTmFtZSwgY29sbGVjdGVkUmVsYXRpb25zaGlwcywgaXNUb3BMZXZlbFByb2Nlc3Nvcik7XG5cbiAgICAgICAgLy8gR2V0IHVuaXF1ZSB0YXJnZXQgZW50aXR5IG5hbWVzIChzdWJwcm9jZXNzb3JzIG9yIG93bl9lbnRpdGllcylcbiAgICAgICAgY29uc3QgdW5pcXVlVGFyZ2V0RW50aXR5T3JpZ2luYWxOYW1lcyA9IEFycmF5LmZyb20obmV3IFNldChjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzLm1hcChyID0+IHIuU3VicHJvY2Vzc29yTmFtZSkpKTtcbiAgICAgICAgY29uc3QgY3JlYXRlZFBhZ2VzRm9yVGhpc1J1biA9IG5ldyBTZXQ8c3RyaW5nPigpOyAvLyBUcmFjayBmaWxlIHBhdGhzIGNyZWF0ZWQvdXBkYXRlZCBpbiB0aGlzIHJ1biB0byBhdm9pZCByZWR1bmRhbnQgb3BzXG5cbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXRFbnRpdHlPcmlnaW5hbE5hbWUgb2YgdW5pcXVlVGFyZ2V0RW50aXR5T3JpZ2luYWxOYW1lcykge1xuICAgICAgICAgICAgY29uc3QgeyBmaWxlUGF0aE5hbWU6IHRhcmdldEVudGl0eUZpbGVQYXRoTmFtZSB9ID0gdGhpcy5zYW5pdGl6ZU5hbWVGb3JGaWxlUGF0aEFuZEFsaWFzKHRhcmdldEVudGl0eU9yaWdpbmFsTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChjcmVhdGVkUGFnZXNGb3JUaGlzUnVuLmhhcyh0YXJnZXRFbnRpdHlGaWxlUGF0aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgQWxyZWFkeSBwcm9jZXNzZWQgcGFnZSBmb3IgJHt0YXJnZXRFbnRpdHlGaWxlUGF0aE5hbWV9IGluIHRoaXMgcnVuLCBza2lwcGluZy5gKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0IGFsbCByZWxhdGlvbnNoaXBzIHdoZXJlIHRoaXMgZW50aXR5IGlzIHRoZSB0YXJnZXQgKFN1YnByb2Nlc3Nvck5hbWUpXG4gICAgICAgICAgICBjb25zdCByZWxhdGlvbnNXaGVyZVRoaXNFbnRpdHlJc1RhcmdldCA9IGNvbGxlY3RlZFJlbGF0aW9uc2hpcHMuZmlsdGVyKHIgPT4gci5TdWJwcm9jZXNzb3JOYW1lID09PSB0YXJnZXRFbnRpdHlPcmlnaW5hbE5hbWUpO1xuXG4gICAgICAgICAgICBpZiAocmVsYXRpb25zV2hlcmVUaGlzRW50aXR5SXNUYXJnZXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgTm8gcmVsYXRpb25zaGlwcyBmb3VuZCBmb3IgdGFyZ2V0ICR7dGFyZ2V0RW50aXR5T3JpZ2luYWxOYW1lfSwgc2tpcHBpbmcgcGFnZSBjcmVhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2hvdWxkIG5vdCBoYXBwZW4gaWYgaXQncyBpbiB1bmlxdWVUYXJnZXRFbnRpdHlPcmlnaW5hbE5hbWVzIGZyb20gY29sbGVjdGVkUmVsYXRpb25zaGlwc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhpcyBlbnRpdHkgaXMgZXZlciB1c2VkIGFzIGEgc3VicHJvY2Vzc29yIGJ5ICphbnkqIHByaW1hcnkgcHJvY2Vzc29yIGluIHRoZSBjdXJyZW50IGJhdGNoXG4gICAgICAgICAgICBjb25zdCBpc0V2ZXJVc2VkQXNTdWJwcm9jZXNzb3IgPSByZWxhdGlvbnNXaGVyZVRoaXNFbnRpdHlJc1RhcmdldC5zb21lKHIgPT4gci5SZWxhdGlvbnNoaXBUeXBlID09PSAndXNlc19zdWJwcm9jZXNzb3InKTtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgZW50aXR5IGlzIGFuIFwib3duX2VudGl0eVwiIG9mIHRoZSAqY3VycmVudCogcHJpbWFyeSBwcm9jZXNzb3IgYmVpbmcgcHJvY2Vzc2VkIChwcm9jZXNzb3JOYW1lKVxuICAgICAgICAgICAgY29uc3QgaXNPd25FbnRpdHlPZkN1cnJlbnRQcmltYXJ5UHJvY2Vzc29yID0gcmVsYXRpb25zV2hlcmVUaGlzRW50aXR5SXNUYXJnZXQuc29tZShcbiAgICAgICAgICAgICAgICByID0+IHIuUHJpbWFyeVByb2Nlc3NvciA9PT0gcHJvY2Vzc29yTmFtZSAmJiByLlJlbGF0aW9uc2hpcFR5cGUgPT09ICdpc19vd25fZW50aXR5J1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGV0IHNob3VsZENyZWF0ZVBhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpc0V2ZXJVc2VkQXNTdWJwcm9jZXNzb3IpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRDcmVhdGVQYWdlID0gdHJ1ZTsgLy8gQWx3YXlzIGNyZWF0ZS91cGRhdGUgcGFnZSBpZiBpdCdzIGEgc3VicHJvY2Vzc29yXG4gICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgUGFnZSBmb3IgJyR7dGFyZ2V0RW50aXR5T3JpZ2luYWxOYW1lfScgd2lsbCBiZSBjcmVhdGVkL3VwZGF0ZWQgYmVjYXVzZSBpdCdzIHVzZWQgYXMgYSBzdWJwcm9jZXNzb3IuYCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzT3duRW50aXR5T2ZDdXJyZW50UHJpbWFyeVByb2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYW4gb3duX2VudGl0eSBvZiB0aGUgY3VycmVudCBwcm9jZXNzb3IsIGNyZWF0ZSBwYWdlIG9ubHkgaWYgc2V0dGluZyBpcyBlbmFibGVkXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3JlYXRlUGFnZXNGb3JPd25FbnRpdGllcykge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRDcmVhdGVQYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgUGFnZSBmb3Igb3duX2VudGl0eSAnJHt0YXJnZXRFbnRpdHlPcmlnaW5hbE5hbWV9JyAob2YgJyR7cHJvY2Vzc29yTmFtZX0nKSB3aWxsIGJlIGNyZWF0ZWQvdXBkYXRlZCBkdWUgdG8gc2V0dGluZy5gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBTa2lwcGluZyBwYWdlIGNyZWF0aW9uIGZvciBvd25fZW50aXR5ICcke3RhcmdldEVudGl0eU9yaWdpbmFsTmFtZX0nIChvZiAnJHtwcm9jZXNzb3JOYW1lfScpIGR1ZSB0byBzZXR0aW5nLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAoc2hvdWxkQ3JlYXRlUGFnZSkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gY3JlYXRpbmcvdXBkYXRpbmcgYSBzdWJwcm9jZXNzb3IncyBwYWdlIChlLmcuLCBcIkFXUy5tZFwiKSxcbiAgICAgICAgICAgICAgICAvLyB3ZSBsaXN0IGFsbCBwcmltYXJ5IHByb2Nlc3NvcnMgdGhhdCB1c2UgaXQgYXMgYSBzdWJwcm9jZXNzb3IuXG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50UmVsYXRpb25zaGlwc0ZvclRhcmdldEVudGl0eVBhZ2UgPSBjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgciA9PiByLlN1YnByb2Nlc3Nvck5hbWUgPT09IHRhcmdldEVudGl0eU9yaWdpbmFsTmFtZSAmJiByLlJlbGF0aW9uc2hpcFR5cGUgPT09ICd1c2VzX3N1YnByb2Nlc3NvcidcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVPclVwZGF0ZVN1YnByb2Nlc3NvckZpbGUoXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEVudGl0eU9yaWdpbmFsTmFtZSwgICAgICAgIC8vIFRoZSBuYW1lIG9mIHRoZSBzdWJwcm9jZXNzb3Ivb3duX2VudGl0eSBpdHNlbGZcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc29yTmFtZSwgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByaW1hcnkgcHJvY2Vzc29yIGNvbnRleHQgKGZvciBsb2dnaW5nL3RyYWNraW5nLCBub3QgZm9yIGNvbnRlbnQgb2Ygc3VicHJvY2Vzc29yJ3MgcGFnZSBkaXJlY3RseSlcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50UmVsYXRpb25zaGlwc0ZvclRhcmdldEVudGl0eVBhZ2UgLy8gUmVsYXRpb25zaGlwcyB3aGVyZSB0aGlzIGVudGl0eSBpcyB0aGUgc3VicHJvY2Vzc29yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjcmVhdGVkUGFnZXNGb3JUaGlzUnVuLmFkZCh0YXJnZXRFbnRpdHlGaWxlUGF0aE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBhbmFseXNpcyBsb2cgZm9yIHRoZSBwcmltYXJ5IHByb2Nlc3NvclxuICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZUFuYWx5c2lzTG9nUGFnZShwcm9jZXNzb3JOYW1lLCBwcm9jZXNzZWRVcmxEZXRhaWxzLCBjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzLCBtZXJnZURlY2lzaW9ucyk7XG4gICAgICAgIG5ldyBOb3RpY2UoYEZpbmlzaGVkIHBlcnNpc3RpbmcgaW5mbyBmb3IgJHtwcm9jZXNzb3JOYW1lfS5gKTtcbiAgICB9XG5cbiAgICBhc3luYyBzZWFyY2hWaWFSaWdodEJyYWluRHVja0R1Y2tHbyhwcm9jZXNzb3JOYW1lOiBzdHJpbmcsIHJiVG9rZW46IHN0cmluZyk6IFByb21pc2U8U2VycEFwaVJlc3VsdFtdPiB7XG4gICAgICAgIC8vIFRoZSBsb2dpYyB0byBjcmVhdGUgdGhlIHRhc2sgb24gdGhlIGZseSBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAgICAvLyBXZSBub3cganVzdCBjaGVjayBpZiB0aGUgc2V0dGluZyBpcyBwcmVzZW50LlxuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkR1Y2tEdWNrR29TZWFyY2hUYXNrSWQpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJEdWNrRHVja0dvIFNlYXJjaCBUYXNrIElEIGlzIG5vdCBjb25maWd1cmVkLiBQbGVhc2UgcnVuIHRoZSBzZXR1cCBjb21tYW5kIG9yIGNvbmZpZ3VyZSBpdCBpbiBzZXR0aW5ncy5cIiwgMTAwMDApO1xuICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBGYWlsIGdyYWNlZnVsbHkgaWYgdGhlIHRhc2sgSUQgaXMgbm90IHNldFxuICAgICAgICB9XG4gICAgXG4gICAgICAgIGNvbnN0IHNlYXJjaFRhc2tJZCA9IHRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkR1Y2tEdWNrR29TZWFyY2hUYXNrSWQ7XG4gICAgXG4gICAgICAgIGNvbnN0IHNlYXJjaFF1ZXJpZXMgPSB0aGlzLmdlbmVyYXRlU2VhcmNoUXVlcmllcyhwcm9jZXNzb3JOYW1lKTtcbiAgICAgICAgY29uc3QgYWxsUmVzdWx0czogU2VycEFwaVJlc3VsdFtdID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJpZXNUb1Byb2Nlc3MgPSBzZWFyY2hRdWVyaWVzLnNsaWNlKDAsIE1hdGgubWluKHNlYXJjaFF1ZXJpZXMubGVuZ3RoLCAyKSk7XG4gICAgXG4gICAgICAgIG5ldyBOb3RpY2UoYFBlcmZvcm1pbmcgdXAgdG8gJHtxdWVyaWVzVG9Qcm9jZXNzLmxlbmd0aH0gRHVja0R1Y2tHbyBzZWFyY2hlcyBmb3IgJHtwcm9jZXNzb3JOYW1lfS4uLmAsIDUwMDApO1xuICAgIFxuICAgICAgICBmb3IgKGNvbnN0IHF1ZXJ5IG9mIHF1ZXJpZXNUb1Byb2Nlc3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGR1Y2tEdWNrR29VcmwgPSBgaHR0cHM6Ly9kdWNrZHVja2dvLmNvbS8/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9JmlhPXdlYiZrbD11cy1lbiZrcD0tMmA7XG4gICAgXG4gICAgICAgICAgICBjb25zdCB0YXNrSW5wdXRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHNlYXJjaF91cmxfdG9fcHJvY2VzczogZHVja0R1Y2tHb1VybCxcbiAgICAgICAgICAgICAgICB0YXJnZXRfY29tcGFueV9uYW1lOiBwcm9jZXNzb3JOYW1lXG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENhbGxpbmcgUmlnaHRCcmFpbiBUYXNrICR7c2VhcmNoVGFza0lkfSBmb3IgRERHIHNlYXJjaC4gVVJMOiAke2R1Y2tEdWNrR29Vcmx9LCBUYXJnZXQ6ICR7cHJvY2Vzc29yTmFtZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGNvbnN0IHRhc2tSdW5SZXN1bHQgPSBhd2FpdCB0aGlzLmNhbGxSaWdodEJyYWluVGFzayhzZWFyY2hUYXNrSWQsIHRhc2tJbnB1dFBheWxvYWQsIHJiVG9rZW4pO1xuICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnICYmIHRhc2tSdW5SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRnVsbCBSaWdodEJyYWluIFJlc3BvbnNlIGZvciBEREcgc2VhcmNoIHF1ZXJ5IFwiJHtxdWVyeX1cIjpgLCBKU09OLnN0cmluZ2lmeSh0YXNrUnVuUmVzdWx0LCBudWxsLCAyKSk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAodGFza1J1blJlc3VsdD8ucmVzcG9uc2U/LnNlYXJjaF9yZXN1bHRzICYmIEFycmF5LmlzQXJyYXkodGFza1J1blJlc3VsdC5yZXNwb25zZS5zZWFyY2hfcmVzdWx0cykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzTGlzdDogYW55W10gPSB0YXNrUnVuUmVzdWx0LnJlc3BvbnNlLnNlYXJjaF9yZXN1bHRzO1xuICAgIFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHNMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudXJsICYmIHJlc3VsdC50aXRsZSAmJiAoU3RyaW5nKHJlc3VsdC51cmwpLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IFN0cmluZyhyZXN1bHQudXJsKS5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxSZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Nvck5hbWU6IHByb2Nlc3Nvck5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoUXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBTdHJpbmcocmVzdWx0LnRpdGxlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFN0cmluZyhyZXN1bHQudXJsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbmlwcGV0OiBTdHJpbmcocmVzdWx0LnNuaXBwZXQgfHwgJycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50VHlwZTogJ2R1Y2tkdWNrZ29fcmJfc2VhcmNoX3Jlc3VsdCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IHByb2Nlc3NlZCAke3Jlc3VsdHNMaXN0Lmxlbmd0aH0gc2VhcmNoIHJlc3VsdHMgZm9yIHF1ZXJ5IFwiJHtxdWVyeX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShgRERHIHNlYXJjaCB2aWEgUkIgZm9yIFwiJHtxdWVyeS5zdWJzdHJpbmcoMCwgMjApfS4uLlwiIHlpZWxkZWQgbm8gdmFsaWQgcmVzdWx0cy5gLCAzMDAwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBSQiBUYXNrIGZvciBEREcgU2VhcmNoIGZvciBxdWVyeSBcIiR7cXVlcnl9XCIgZGlkIG5vdCByZXR1cm4gZXhwZWN0ZWQgJ3sgXCJzZWFyY2hfcmVzdWx0c1wiOiBbLi4uXSB9JyBhcnJheSBvciBmYWlsZWQuIEZ1bGwgdGFza1J1blJlc3VsdDpgLCB0YXNrUnVuUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNzAwICsgTWF0aC5yYW5kb20oKSAqIDUwMCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coYHNlYXJjaFZpYVJpZ2h0QnJhaW5EdWNrRHVja0dvIGNvbGxlY3RlZCAke2FsbFJlc3VsdHMubGVuZ3RofSBmaWx0ZXJlZCBjYW5kaWRhdGVzIGZvciAke3Byb2Nlc3Nvck5hbWV9YCk7XG4gICAgICAgIHJldHVybiBhbGxSZXN1bHRzO1xuICAgIH1cblxuXG4gICAgYXN5bmMgZmV0Y2hQcm9jZXNzb3JTZWFyY2hEYXRhV2l0aERpc2NvdmVyeShwcm9jZXNzb3JOYW1lOiBzdHJpbmcpOiBQcm9taXNlPFNlYXJjaERhdGEgfCBudWxsPiB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3RlZFJlbGF0aW9uc2hpcHM6IEV4dHJhY3RlZFJlbGF0aW9uc2hpcFtdID0gW107XG4gICAgICAgIGNvbnN0IHNlZW5SZWxhdGlvbnNoaXBzSW5DdXJyZW50U2VhcmNoID0gbmV3IFNldDxzdHJpbmc+KCk7IC8vIFRyYWNrcyAoUHJpbWFyeSwgU3ViLCBUeXBlKVxuICAgICAgICBjb25zdCBwcm9jZXNzZWRVcmxEZXRhaWxzOiBQcm9jZXNzZWRVcmxJbmZvW10gPSBbXTsgLy8gTG9nIG9mIGFsbCBVUkxzIHByb2Nlc3NlZFxuICAgICAgICBsZXQgY2FuZGlkYXRlVXJsc0luZm86IFNlcnBBcGlSZXN1bHRbXSA9IFtdO1xuICAgICAgICBsZXQgZmxhZ2dlZENhbmRpZGF0ZVVybENvdW50ID0gMDtcblxuICAgICAgICBjb25zdCByYlRva2VuID0gYXdhaXQgdGhpcy5nZXRSaWdodEJyYWluQWNjZXNzVG9rZW4oKTtcbiAgICAgICAgaWYgKCFyYlRva2VuKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiQ291bGQgbm90IGdldCBSaWdodEJyYWluIEFjY2VzcyBUb2tlbi4gQWJvcnRpbmcgZGlzY292ZXJ5LlwiLCA3MDAwKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RlcCAxOiBJbml0aWFsIFNlYXJjaCAoU2VycEFQSSBvciBSaWdodEJyYWluL0RERylcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2VycEFwaUtleSkge1xuICAgICAgICAgICAgbmV3IE5vdGljZShgVXNpbmcgU2VycEFQSSBmb3IgcHJpbWFyeSBzZWFyY2ggZm9yOiAke3Byb2Nlc3Nvck5hbWV9YCwgNTAwMCk7XG4gICAgICAgICAgICBjb25zdCBzZWFyY2hRdWVyaWVzID0gdGhpcy5nZW5lcmF0ZVNlYXJjaFF1ZXJpZXMocHJvY2Vzc29yTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBzZXJwQXBpUmVzdWx0cyA9IGF3YWl0IHRoaXMuc2VhcmNoU2VycEFwaUZvckRwYXMocHJvY2Vzc29yTmFtZSwgc2VhcmNoUXVlcmllcywgdGhpcy5zZXR0aW5ncy5tYXhSZXN1bHRzUGVyUHJvY2Vzc29yKTtcbiAgICAgICAgICAgIGNhbmRpZGF0ZVVybHNJbmZvLnB1c2goLi4uc2VycEFwaVJlc3VsdHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MucmlnaHRicmFpbk9yZ0lkICYmIHRoaXMuc2V0dGluZ3MucmlnaHRicmFpblByb2plY3RJZCkgeyAvLyBDaGVjayBpZiBSaWdodEJyYWluIGlzIGNvbmZpZ3VyZWQgZm9yIERER1xuICAgICAgICAgICAgbmV3IE5vdGljZShgU2VycEFQSSBrZXkgbm90IGNvbmZpZ3VyZWQuIFVzaW5nIER1Y2tEdWNrR28gKEZpbHRlcmVkIEV4dHJhY3RvciBUYXNrKSB2aWEgUmlnaHRCcmFpbiBmb3I6ICR7cHJvY2Vzc29yTmFtZX1gLCA1MDAwKTtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FsbCBub3cgdXNlcyB0aGUgUkIgVGFzayB0aGF0IGZpbHRlcnMgYW5kIHBhcnNlcyBEREcgcmVzdWx0c1xuICAgICAgICAgICAgY2FuZGlkYXRlVXJsc0luZm8gPSBhd2FpdCB0aGlzLnNlYXJjaFZpYVJpZ2h0QnJhaW5EdWNrRHVja0dvKHByb2Nlc3Nvck5hbWUsIHJiVG9rZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIk5vIHNlYXJjaCBtZXRob2QgY29uZmlndXJlZCAoU2VycEFQSSBvciBSaWdodEJyYWluIGZvciBEREcpLiBBYm9ydGluZyBkaXNjb3ZlcnkuXCIsIDcwMDApO1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byByZXR1cm4gbnVsbCBpbW1lZGlhdGVseSwgYXMgaGFyZGNvZGVkIFVSTHMgbWlnaHQgc3RpbGwgYmUgcHJvY2Vzc2VkIGlmIHZlcmJvc2VEZWJ1ZyBpcyBvbi5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gSGFyZGNvZGVkIFVSTHMgZm9yIHRlc3RpbmcgKGlmIGVuYWJsZWQpXG4gICAgICAgIGNvbnN0IGhhcmRjb2RlZFRlc3RVcmxzOiBSZWNvcmQ8c3RyaW5nLCBTZXJwQXBpUmVzdWx0W10+ID0ge1xuICAgICAgICAgICAgLy8gXCJvcGVuYWlcIjogW3sgdGl0bGU6IFwiVGVzdCBPcGVuQUkgU3ViUCBMaXN0XCIsIHVybDogXCJodHRwczovL2V4YW1wbGUuY29tL29wZW5haS1zdWJwXCIsIHNuaXBwZXQ6IFwiXCIsIHByb2Nlc3Nvck5hbWU6IFwib3BlbmFpXCIsIGRvY3VtZW50VHlwZTogXCJoYXJkY29kZWRfdGVzdFwiIH1dLFxuICAgICAgICB9OyAvLyBLZWVwIHRoaXMgZW1wdHkgb3IgbWFuYWdlIGl0IGNhcmVmdWxseVxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcgJiYgaGFyZGNvZGVkVGVzdFVybHNbcHJvY2Vzc29yTmFtZS50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgQWRkaW5nIGhhcmRjb2RlZCB0ZXN0IFVSTHMgZm9yICR7cHJvY2Vzc29yTmFtZX1gKTtcbiAgICAgICAgICAgIGNhbmRpZGF0ZVVybHNJbmZvLnB1c2goLi4uaGFyZGNvZGVkVGVzdFVybHNbcHJvY2Vzc29yTmFtZS50b0xvd2VyQ2FzZSgpXSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFN0ZXAgMjogKE9wdGlvbmFsKSBFeHRyYWN0IG1vcmUgVVJMcyBmcm9tIGFscmVhZHkgaWRlbnRpZmllZCBEUEEvU3VicHJvY2Vzc29yIGxpc3QgcGFnZXNcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbFVybHNGcm9tQ2FuZGlkYXRlUGFnZXM6IFNlcnBBcGlSZXN1bHRbXSA9IFtdO1xuICAgICAgICBjb25zdCBwYWdlc1RvU2NhbkZvck1vcmVMaW5rcyA9IGNhbmRpZGF0ZVVybHNJbmZvLmZpbHRlcihcbiAgICAgICAgICAgIGl0ZW0gPT4gaXRlbS5kb2N1bWVudFR5cGUgPT09ICdkcGFfb3Jfc3VicHJvY2Vzc29yX2xpc3QnIHx8IFNVQlBST0NFU1NPUl9VUkxfS0VZV09SRFMuc29tZShrdyA9PiBpdGVtLnVybC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGt3KSlcbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKGNvbnN0IHBhZ2VJdGVtIG9mIHBhZ2VzVG9TY2FuRm9yTW9yZUxpbmtzKSB7XG4gICAgICAgICAgICBjb25zdCBleHRyYWN0ZWQgPSBhd2FpdCB0aGlzLmV4dHJhY3RVcmxzRnJvbURwYVBhZ2UocGFnZUl0ZW0udXJsLCBwcm9jZXNzb3JOYW1lLCBwYWdlSXRlbS50aXRsZSk7XG4gICAgICAgICAgICBhZGRpdGlvbmFsVXJsc0Zyb21DYW5kaWRhdGVQYWdlcy5wdXNoKC4uLmV4dHJhY3RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FuZGlkYXRlVXJsc0luZm8ucHVzaCguLi5hZGRpdGlvbmFsVXJsc0Zyb21DYW5kaWRhdGVQYWdlcyk7XG5cblxuICAgICAgICAvLyBDcmVhdGUgYSB1bmlxdWUgbGlzdCBvZiBVUkxzIHRvIHByb2Nlc3MsIHByaW9yaXRpemluZyBlYXJsaWVyIGZvdW5kIG9uZXMuXG4gICAgICAgIGNvbnN0IHVuaXF1ZUNhbmRpZGF0ZVVybHMgPSBuZXcgTWFwPHN0cmluZywgU2VycEFwaVJlc3VsdD4oKTtcbiAgICAgICAgY2FuZGlkYXRlVXJsc0luZm8uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLnVybCAmJiAoaXRlbS51cmwuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgaXRlbS51cmwuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSAmJiAhdW5pcXVlQ2FuZGlkYXRlVXJscy5oYXMoaXRlbS51cmwucmVwbGFjZSgvXFwvJC8sICcnKSkpIHsgLy8gTm9ybWFsaXplIFVSTCBieSByZW1vdmluZyB0cmFpbGluZyBzbGFzaFxuICAgICAgICAgICAgICAgIHVuaXF1ZUNhbmRpZGF0ZVVybHMuc2V0KGl0ZW0udXJsLnJlcGxhY2UoL1xcLyQvLCAnJyksIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdW5pcXVlVXJsc1RvUHJvY2VzcyA9IEFycmF5LmZyb20odW5pcXVlQ2FuZGlkYXRlVXJscy52YWx1ZXMoKSk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgVG90YWwgdW5pcXVlIFVSTHMgdG8gdmVyaWZ5IGZvciAke3Byb2Nlc3Nvck5hbWV9OiAke3VuaXF1ZVVybHNUb1Byb2Nlc3MubGVuZ3RofWApO1xuXG4gICAgICAgIGlmICh1bmlxdWVVcmxzVG9Qcm9jZXNzLmxlbmd0aCA9PT0gMCAmJiBjYW5kaWRhdGVVcmxzSW5mby5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLndhcm4oYEFsbCBjYW5kaWRhdGUgVVJMcyB3ZXJlIGludmFsaWQgb3IgZHVwbGljYXRlcyBmb3IgJHtwcm9jZXNzb3JOYW1lfS4gT3JpZ2luYWwgY291bnQ6ICR7Y2FuZGlkYXRlVXJsc0luZm8ubGVuZ3RofWApO1xuICAgICAgICB9IGVsc2UgaWYgKHVuaXF1ZVVybHNUb1Byb2Nlc3MubGVuZ3RoID09PSAwKSB7IFxuICAgICAgICAgICAgbmV3IE5vdGljZShgTm8gY2FuZGlkYXRlIFVSTHMgZm91bmQgdG8gcHJvY2VzcyBmb3IgJHtwcm9jZXNzb3JOYW1lfS5gKTtcbiAgICAgICAgICAgIC8vIE5vIFVSTHMgdG8gcHJvY2Vzcywgc28gcmV0dXJuIGN1cnJlbnQgc3RhdGUgKGxpa2VseSBlbXB0eSByZWxhdGlvbnNoaXBzKVxuICAgICAgICAgICAgLy8gcmV0dXJuIHsgY29sbGVjdGVkUmVsYXRpb25zaGlwcywgcHJvY2Vzc2VkVXJsRGV0YWlscywgZmxhZ2dlZENhbmRpZGF0ZVVybENvdW50IH07XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIFN0ZXAgMzogVmVyaWZ5IGVhY2ggdW5pcXVlIFVSTCBhbmQgZXh0cmFjdCBlbnRpdGllcyBpZiBpdCdzIGEgdmFsaWQsIGN1cnJlbnQgbGlzdFxuICAgICAgICBmb3IgKGNvbnN0IHVybEluZm8gb2YgdW5pcXVlVXJsc1RvUHJvY2Vzcykge1xuXG4gICAgICAgICAgICAvLyBBdm9pZCByZS1wcm9jZXNzaW5nIGlmIHRoaXMgZXhhY3QgVVJMIHdhcyBzb21laG93IGFkZGVkIHRvIHByb2Nlc3NlZFVybERldGFpbHMgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKHByb2Nlc3NlZFVybERldGFpbHMuc29tZShwID0+IHAudXJsLnJlcGxhY2UoL1xcLyQvLCAnJykgPT09IHVybEluZm8udXJsLnJlcGxhY2UoL1xcLyQvLCAnJykpKSB7XG4gICAgICAgICAgICAgICAgIGlmKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgVVJMICR7dXJsSW5mby51cmx9IGFscmVhZHkgcHJvY2Vzc2VkIGluIHByb2Nlc3NlZFVybERldGFpbHMsIHNraXBwaW5nIHJlLXZlcmlmaWNhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGN1cnJlbnRVcmxFeHRyYWN0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgY3VycmVudFByb2Nlc3NlZFVybEluZm86IFByb2Nlc3NlZFVybEluZm8gPSB7IC4uLnVybEluZm8sIGRvY3VtZW50VHlwZTogdXJsSW5mby5kb2N1bWVudFR5cGUgfHwgJ2R1Y2tkdWNrZ29fcmJfc2VhcmNoX3Jlc3VsdCcgfTsgXG5cbiAgICAgICAgICAgIGNvbnN0IHZlcmlmaWNhdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMudmVyaWZ5U3VicHJvY2Vzc29yTGlzdFVybCh1cmxJbmZvLnVybCwgcHJvY2Vzc29yTmFtZSwgcmJUb2tlbik7XG4gICAgICAgICAgICBjdXJyZW50UHJvY2Vzc2VkVXJsSW5mbyA9IHsgXG4gICAgICAgICAgICAgICAgLi4uY3VycmVudFByb2Nlc3NlZFVybEluZm8sXG4gICAgICAgICAgICAgICAgdmVyaWZpY2F0aW9uTWV0aG9kOiAncmlnaHRicmFpbicsXG4gICAgICAgICAgICAgICAgaXNMaXN0OiB2ZXJpZmljYXRpb25SZXN1bHQ/LmlzTGlzdCB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0N1cnJlbnQ6IHZlcmlmaWNhdGlvblJlc3VsdD8uaXNDdXJyZW50IHx8IGZhbHNlLCBcbiAgICAgICAgICAgICAgICB2ZXJpZmljYXRpb25SZWFzb25pbmc6IHZlcmlmaWNhdGlvblJlc3VsdD8ucmVhc29uaW5nIHx8ICdOL0EnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyAtLS0tIFRISVMgSVMgVEhFIEtFWSBMT0dJQyBDSEFOR0UgLS0tLVxuICAgICAgICAgICAgaWYgKHZlcmlmaWNhdGlvblJlc3VsdD8uaXNMaXN0ICYmIHZlcmlmaWNhdGlvblJlc3VsdC5pc0N1cnJlbnQgJiYgdmVyaWZpY2F0aW9uUmVzdWx0LmlzQ29ycmVjdFByb2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvLmRvY3VtZW50VHlwZSA9ICd2ZXJpZmllZF9jdXJyZW50X3N1YnByb2Nlc3Nvcl9saXN0JztcbiAgICAgICAgICAgICAgICBpZiAodmVyaWZpY2F0aW9uUmVzdWx0LnBhZ2VDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhY3Rpb25SZXN1bHQgPSBhd2FpdCB0aGlzLmV4dHJhY3RFbnRpdGllc0Zyb21QYWdlQ29udGVudCh2ZXJpZmljYXRpb25SZXN1bHQucGFnZUNvbnRlbnQsIHJiVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmFjdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0aGlyZFBhcnR5U3VicHJvY2Vzc29ycywgb3duRW50aXRpZXMgfSA9IGV4dHJhY3Rpb25SZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlyZFBhcnR5U3VicHJvY2Vzc29ycy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVcmxFeHRyYWN0ZWRDb3VudCArPSB0aGlzLmFkZFJlbGF0aW9uc2hpcChjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzLCBzZWVuUmVsYXRpb25zaGlwc0luQ3VycmVudFNlYXJjaCwgcHJvY2Vzc29yTmFtZSwgZSwgXCJ1c2VzX3N1YnByb2Nlc3NvclwiLCB1cmxJbmZvLnVybCwgdmVyaWZpY2F0aW9uUmVzdWx0LnJlYXNvbmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bkVudGl0aWVzLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFVybEV4dHJhY3RlZENvdW50ICs9IHRoaXMuYWRkUmVsYXRpb25zaGlwKGNvbGxlY3RlZFJlbGF0aW9uc2hpcHMsIHNlZW5SZWxhdGlvbnNoaXBzSW5DdXJyZW50U2VhcmNoLCBwcm9jZXNzb3JOYW1lLCBlLCBcImlzX293bl9lbnRpdHlcIiwgdXJsSW5mby51cmwsIHZlcmlmaWNhdGlvblJlc3VsdC5yZWFzb25pbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvLmRvY3VtZW50VHlwZSA9ICd2ZXJpZmllZF9jdXJyZW50X3N1YnByb2Nlc3Nvcl9saXN0IChyYl9leHRyYWN0aW9uX2ZhaWxlZCknOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgY3VycmVudFByb2Nlc3NlZFVybEluZm8uZG9jdW1lbnRUeXBlID0gJ3ZlcmlmaWVkX2N1cnJlbnRfc3VicHJvY2Vzc29yX2xpc3QgKG5vX2NvbnRlbnRfZm9yX2V4dHJhY3Rpb24pJzt9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3VycmVudFByb2Nlc3NlZFVybEluZm8uZXh0cmFjdGVkU3VicHJvY2Vzc29yc0NvdW50ID0gY3VycmVudFVybEV4dHJhY3RlZENvdW50O1xuICAgICAgICAgICAgICAgIHByb2Nlc3NlZFVybERldGFpbHMucHVzaChjdXJyZW50UHJvY2Vzc2VkVXJsSW5mbyk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBzdWNjZXNzZnVsbHkgZXh0cmFjdGVkIGVudGl0aWVzIGZyb20gYSB2ZXJpZmllZCBsaXN0LCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFVybEV4dHJhY3RlZENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBGb3VuZCBhbmQgcHJvY2Vzc2VkIGEgdmFsaWQgc3VicHJvY2Vzc29yIGxpc3QgYXQgJHt1cmxJbmZvLnVybH0uIFN0b3BwaW5nIHNlYXJjaC5gKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgRm91bmQgdmFsaWQgbGlzdCBmb3IgJHtwcm9jZXNzb3JOYW1lfS4gRmluaXNoaW5nIHByb2Nlc3MuYCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyA8LS0gRVhJVCBUSEUgTE9PUCBFQVJMWVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIFRoaXMgYmxvY2sgY2F0Y2hlcyBsaXN0cyB0aGF0IGFyZSBub3QgY3VycmVudCBPUiBub3QgZm9yIHRoZSBjb3JyZWN0IHByb2Nlc3NvclxuICAgICAgICAgICAgICAgIGNvbnN0IHVybExvd2VyID0gdXJsSW5mby51cmwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluc0tleXdvcmQgPSBTVUJQUk9DRVNTT1JfVVJMX0tFWVdPUkRTLnNvbWUoa2V5d29yZCA9PiB1cmxMb3dlci5pbmNsdWRlcyhrZXl3b3JkKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXZlcmlmaWNhdGlvblJlc3VsdD8uaXNMaXN0ICYmIGNvbnRhaW5zS2V5d29yZCkgeyBcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2Nlc3NlZFVybEluZm8uZG9jdW1lbnRUeXBlID0gJ2tleXdvcmRfbWF0Y2hfbm90X3ZlcmlmaWVkX2xpc3QnO1xuICAgICAgICAgICAgICAgICAgICBmbGFnZ2VkQ2FuZGlkYXRlVXJsQ291bnQrKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZlcmlmaWNhdGlvblJlc3VsdD8uaXNMaXN0ICYmICF2ZXJpZmljYXRpb25SZXN1bHQuaXNDb3JyZWN0UHJvY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvLmRvY3VtZW50VHlwZSA9ICd2ZXJpZmllZF9saXN0X2Zvcl93cm9uZ19wcm9jZXNzb3InO1xuICAgICAgICAgICAgICAgICAgICBmbGFnZ2VkQ2FuZGlkYXRlVXJsQ291bnQrKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZlcmlmaWNhdGlvblJlc3VsdD8uaXNMaXN0KSB7IFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvY2Vzc2VkVXJsSW5mby5kb2N1bWVudFR5cGUgPSAndmVyaWZpZWRfc3VicHJvY2Vzc29yX2xpc3QgKG5vdF9jdXJyZW50KSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvLmRvY3VtZW50VHlwZSA9ICdub3RfYV9zdWJwcm9jZXNzb3JfbGlzdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvLmV4dHJhY3RlZFN1YnByb2Nlc3NvcnNDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkVXJsRGV0YWlscy5wdXNoKGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBFbmQgb2YgbG9vcCB0aHJvdWdoIHVuaXF1ZSBVUkxzXG5cbiAgICAgICAgcmV0dXJuIHsgY29sbGVjdGVkUmVsYXRpb25zaGlwcywgcHJvY2Vzc2VkVXJsRGV0YWlscywgZmxhZ2dlZENhbmRpZGF0ZVVybENvdW50IH07XG4gICAgfVxuXG5cbiAgICBhc3luYyBmZXRjaERhdGFGcm9tRGlyZWN0VXJsKHByb2Nlc3Nvck5hbWU6IHN0cmluZywgbGlzdFVybDogc3RyaW5nKTogUHJvbWlzZTxTZWFyY2hEYXRhIHwgbnVsbD4ge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBGZXRjaGluZyBkYXRhIGZyb20gZGlyZWN0IFVSTCBmb3IgJHtwcm9jZXNzb3JOYW1lfTogJHtsaXN0VXJsfWApO1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZFVybChsaXN0VXJsLCBwcm9jZXNzb3JOYW1lKSkgeyAvLyBCYXNpYyBVUkwgdmFsaWRhdGlvblxuICAgICAgICAgICAgbmV3IE5vdGljZShgVGhlIHByb3ZpZGVkIFVSTCBmb3IgJHtwcm9jZXNzb3JOYW1lfSBpcyBub3QgdmFsaWQ6ICR7bGlzdFVybH1gKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29sbGVjdGVkUmVsYXRpb25zaGlwczogRXh0cmFjdGVkUmVsYXRpb25zaGlwW10gPSBbXTtcbiAgICAgICAgY29uc3Qgc2VlblJlbGF0aW9uc2hpcHNJbkN1cnJlbnRTZWFyY2ggPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkVXJsRGV0YWlsczogUHJvY2Vzc2VkVXJsSW5mb1tdID0gW107XG4gICAgICAgIGxldCBmbGFnZ2VkQ2FuZGlkYXRlVXJsQ291bnQgPSAwO1xuXG4gICAgICAgIGNvbnN0IGRpcmVjdFVybEluZm9CYXNlOiBQYXJ0aWFsPFNlcnBBcGlSZXN1bHQ+ID0geyAvLyBCYXNlIGluZm8gZm9yIHRoaXMgbWFudWFsbHkgcHJvdmlkZWQgVVJMXG4gICAgICAgICAgICB0aXRsZTogYE1hbnVhbGx5IFByb3ZpZGVkIExpc3QgZm9yICR7cHJvY2Vzc29yTmFtZX1gLCB1cmw6IGxpc3RVcmwsXG4gICAgICAgICAgICBzbmlwcGV0OiAnTWFudWFsbHkgcHJvdmlkZWQgVVJMJywgcHJvY2Vzc29yTmFtZTogcHJvY2Vzc29yTmFtZSwgZG9jdW1lbnRUeXBlOiAnZGlyZWN0X2lucHV0X2xpc3QnLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY3VycmVudFByb2Nlc3NlZFVybEluZm86IFByb2Nlc3NlZFVybEluZm8gPSB7IC4uLmRpcmVjdFVybEluZm9CYXNlLCB1cmw6IGxpc3RVcmwsIGRvY3VtZW50VHlwZTogJ2RpcmVjdF9pbnB1dF9saXN0JyB9O1xuXG5cbiAgICAgICAgY29uc3QgcmJUb2tlbiA9IGF3YWl0IHRoaXMuZ2V0UmlnaHRCcmFpbkFjY2Vzc1Rva2VuKCk7XG4gICAgICAgIGlmICghcmJUb2tlbikgeyAvLyBSQiB0b2tlbiBpcyBlc3NlbnRpYWwgZm9yIHZlcmlmaWNhdGlvbiBhbmQgZXh0cmFjdGlvblxuICAgICAgICAgICAgbmV3IE5vdGljZShcIkNvdWxkIG5vdCBvYnRhaW4gUmlnaHRCcmFpbiB0b2tlbiBmb3IgZGlyZWN0IFVSTCBwcm9jZXNzaW5nLlwiKTtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvLnZlcmlmaWNhdGlvbk1ldGhvZCA9ICdOL0EgKE5vIFJCIFRva2VuKSc7XG4gICAgICAgICAgICBwcm9jZXNzZWRVcmxEZXRhaWxzLnB1c2goY3VycmVudFByb2Nlc3NlZFVybEluZm8pOyAvLyBMb2cgdGhlIGF0dGVtcHRcbiAgICAgICAgICAgIHJldHVybiB7IGNvbGxlY3RlZFJlbGF0aW9uc2hpcHMsIHByb2Nlc3NlZFVybERldGFpbHMsIGZsYWdnZWRDYW5kaWRhdGVVcmxDb3VudCB9OyAvLyBSZXR1cm4gd2l0aCBubyBkYXRhIGJ1dCB3aXRoIGxvZ1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1cnJlbnRVcmxFeHRyYWN0ZWRDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IHZlcmlmaWNhdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMudmVyaWZ5U3VicHJvY2Vzc29yTGlzdFVybChsaXN0VXJsLCBwcm9jZXNzb3JOYW1lLHJiVG9rZW4pO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBjdXJyZW50UHJvY2Vzc2VkVXJsSW5mbyB3aXRoIHZlcmlmaWNhdGlvbiBkZXRhaWxzXG4gICAgICAgIGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvLnZlcmlmaWNhdGlvbk1ldGhvZCA9ICdyaWdodGJyYWluJztcbiAgICAgICAgY3VycmVudFByb2Nlc3NlZFVybEluZm8uaXNMaXN0ID0gdmVyaWZpY2F0aW9uUmVzdWx0Py5pc0xpc3QgfHwgZmFsc2U7XG4gICAgICAgIGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvLmlzQ3VycmVudCA9IHZlcmlmaWNhdGlvblJlc3VsdD8uaXNDdXJyZW50IHx8IGZhbHNlOyAvLyBpc0N1cnJlbnQgaW1wbGllcyBpc0xpc3RcbiAgICAgICAgY3VycmVudFByb2Nlc3NlZFVybEluZm8udmVyaWZpY2F0aW9uUmVhc29uaW5nID0gdmVyaWZpY2F0aW9uUmVzdWx0Py5yZWFzb25pbmcgfHwgJ04vQSc7XG5cbiAgICAgICAgaWYgKHZlcmlmaWNhdGlvblJlc3VsdCAmJiB2ZXJpZmljYXRpb25SZXN1bHQuaXNMaXN0ICYmIHZlcmlmaWNhdGlvblJlc3VsdC5pc0N1cnJlbnQpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFZlcmlmaWVkIG1hbnVhbCBVUkw6ICR7bGlzdFVybH0gYXMgY3VycmVudCBsaXN0LmApO1xuICAgICAgICAgICAgY3VycmVudFByb2Nlc3NlZFVybEluZm8uZG9jdW1lbnRUeXBlID0gJ3ZlcmlmaWVkX2N1cnJlbnRfc3VicHJvY2Vzc29yX2xpc3QgKG1hbnVhbF91cmxfaW5wdXQpJztcbiAgICAgICAgICAgIGlmICh2ZXJpZmljYXRpb25SZXN1bHQucGFnZUNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRyYWN0aW9uUmVzdWx0ID0gYXdhaXQgdGhpcy5leHRyYWN0RW50aXRpZXNGcm9tUGFnZUNvbnRlbnQodmVyaWZpY2F0aW9uUmVzdWx0LnBhZ2VDb250ZW50LCByYlRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFjdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRoaXJkUGFydHlTdWJwcm9jZXNzb3JzLCBvd25FbnRpdGllcyB9ID0gZXh0cmFjdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcmRQYXJ0eVN1YnByb2Nlc3NvcnMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVcmxFeHRyYWN0ZWRDb3VudCArPSB0aGlzLmFkZFJlbGF0aW9uc2hpcChjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzLCBzZWVuUmVsYXRpb25zaGlwc0luQ3VycmVudFNlYXJjaCwgcHJvY2Vzc29yTmFtZSwgZSwgXCJ1c2VzX3N1YnByb2Nlc3NvclwiLCBsaXN0VXJsLCB2ZXJpZmljYXRpb25SZXN1bHQucmVhc29uaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG93bkVudGl0aWVzLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXJsRXh0cmFjdGVkQ291bnQgKz0gdGhpcy5hZGRSZWxhdGlvbnNoaXAoY29sbGVjdGVkUmVsYXRpb25zaGlwcywgc2VlblJlbGF0aW9uc2hpcHNJbkN1cnJlbnRTZWFyY2gsIHByb2Nlc3Nvck5hbWUsIGUsIFwiaXNfb3duX2VudGl0eVwiLCBsaXN0VXJsLCB2ZXJpZmljYXRpb25SZXN1bHQucmVhc29uaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgY3VycmVudFByb2Nlc3NlZFVybEluZm8uZG9jdW1lbnRUeXBlID0gJ3ZlcmlmaWVkX2N1cnJlbnRfc3VicHJvY2Vzc29yX2xpc3QgKG1hbnVhbF91cmxfaW5wdXRfcmJfZXh0cmFjdGlvbl9mYWlsZWQpJzt9XG4gICAgICAgICAgICB9IGVsc2Uge2N1cnJlbnRQcm9jZXNzZWRVcmxJbmZvLmRvY3VtZW50VHlwZSA9ICd2ZXJpZmllZF9jdXJyZW50X3N1YnByb2Nlc3Nvcl9saXN0IChtYW51YWxfdXJsX2lucHV0X25vX2NvbnRlbnQpJzt9XG4gICAgICAgIH0gZWxzZSB7IC8vIE5vdCB2ZXJpZmllZCBhcyBjdXJyZW50IGFuZCB2YWxpZCwgb3IgdmVyaWZpY2F0aW9uIGZhaWxlZFxuICAgICAgICAgICAgY29uc3QgdXJsTG93ZXIgPSBsaXN0VXJsLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBjb250YWluc0tleXdvcmQgPSBTVUJQUk9DRVNTT1JfVVJMX0tFWVdPUkRTLnNvbWUoa2V5d29yZCA9PiB1cmxMb3dlci5pbmNsdWRlcyhrZXl3b3JkKSk7XG4gICAgICAgICAgICBpZiAoIXZlcmlmaWNhdGlvblJlc3VsdD8uaXNMaXN0ICYmIGNvbnRhaW5zS2V5d29yZCkgeyAvLyBMb29rcyBsaWtlIG9uZSAoa2V5d29yZCksIGJ1dCBSQiBzYXlzIG5vXG4gICAgICAgICAgICAgICAgY3VycmVudFByb2Nlc3NlZFVybEluZm8uZG9jdW1lbnRUeXBlID0gJ2tleXdvcmRfbWF0Y2hfbm90X3ZlcmlmaWVkX2xpc3QgKG1hbnVhbF91cmxfaW5wdXQpJztcbiAgICAgICAgICAgICAgICBmbGFnZ2VkQ2FuZGlkYXRlVXJsQ291bnQrKztcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBNYW51YWwgVVJMICR7bGlzdFVybH0gbG9va3MgbGlrZSBhIHN1YnByb2Nlc3NvciBsaXN0IGJ1dCBjb3VsZG4ndCBiZSB2ZXJpZmllZC4gUmVhc29uOiAke3RoaXMuc2NydWJIeXBlcmxpbmtzKHZlcmlmaWNhdGlvblJlc3VsdD8ucmVhc29uaW5nKSB8fCAnRGV0YWlscyB1bmF2YWlsYWJsZS4nfWApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coYEZsYWdnZWQgTWFudWFsIFVSTCAoa2V5d29yZCBtYXRjaCwgbm90IHZlcmlmaWVkKTogJHtsaXN0VXJsfWApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2ZXJpZmljYXRpb25SZXN1bHQ/LmlzTGlzdCkgeyAvLyBSQiBzYXlzIGl0J3MgYSBsaXN0LCBidXQgbm90IGN1cnJlbnRcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvY2Vzc2VkVXJsSW5mby5kb2N1bWVudFR5cGUgPSAndmVyaWZpZWRfc3VicHJvY2Vzc29yX2xpc3QgKG1hbnVhbF91cmxfaW5wdXRfbm90X2N1cnJlbnQpJztcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBNYW51YWwgVVJMICR7bGlzdFVybH0gdmVyaWZpZWQgYXMgYSBsaXN0LCBidXQgbm90IGN1cnJlbnQuIFJlYXNvbjogJHt0aGlzLnNjcnViSHlwZXJsaW5rcyh2ZXJpZmljYXRpb25SZXN1bHQ/LnJlYXNvbmluZykgfHwgJ0RldGFpbHMgdW5hdmFpbGFibGUuJ31gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIFJCIHNheXMgbm90IGEgbGlzdCwgb3IgdmVyaWZpY2F0aW9uIGZhaWxlZCBtb3JlIGJyb2FkbHlcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvY2Vzc2VkVXJsSW5mby5kb2N1bWVudFR5cGUgPSAnbm90X2Ffc3VicHJvY2Vzc29yX2xpc3QgKG1hbnVhbF91cmxfaW5wdXQpJztcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBNYW51YWwgVVJMICR7bGlzdFVybH0gY291bGQgbm90IGJlIHZlcmlmaWVkIGFzIGEgbGlzdC4gUmVhc29uOiAke3RoaXMuc2NydWJIeXBlcmxpbmtzKHZlcmlmaWNhdGlvblJlc3VsdD8ucmVhc29uaW5nKSB8fCAnRGV0YWlscyB1bmF2YWlsYWJsZS4nfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvLmV4dHJhY3RlZFN1YnByb2Nlc3NvcnNDb3VudCA9IGN1cnJlbnRVcmxFeHRyYWN0ZWRDb3VudDtcbiAgICAgICAgcHJvY2Vzc2VkVXJsRGV0YWlscy5wdXNoKGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvKTsgLy8gTG9nIHRoZSBwcm9jZXNzaW5nIGF0dGVtcHQgZm9yIHRoaXMgVVJMXG4gICAgICAgIHJldHVybiB7IGNvbGxlY3RlZFJlbGF0aW9uc2hpcHMsIHByb2Nlc3NlZFVybERldGFpbHMsIGZsYWdnZWRDYW5kaWRhdGVVcmxDb3VudCB9O1xuICAgIH1cblxuXG4gICAgYXN5bmMgZmV0Y2hEYXRhRnJvbVBhc3RlZFRleHQocHJvY2Vzc29yTmFtZTogc3RyaW5nLCBwYXN0ZWRUZXh0OiBzdHJpbmcpOiBQcm9taXNlPFNlYXJjaERhdGEgfCBudWxsPiB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coYEZldGNoaW5nIGRhdGEgZnJvbSBwYXN0ZWQgdGV4dCBmb3IgJHtwcm9jZXNzb3JOYW1lfWApO1xuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkV4dHJhY3RFbnRpdGllc1Rhc2tJZCkgeyAvLyBDaGVjayBmb3IgdGhlIHNwZWNpZmljIHRhc2sgSURcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJSaWdodEJyYWluIFRhc2sgSUQgZm9yIGVudGl0eSBleHRyYWN0aW9uIGlzIG5vdCBjb25maWd1cmVkLiBQbGVhc2Ugc2V0IGl0IGluIHBsdWdpbiBzZXR0aW5ncy5cIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbGxlY3RlZFJlbGF0aW9uc2hpcHM6IEV4dHJhY3RlZFJlbGF0aW9uc2hpcFtdID0gW107XG4gICAgICAgIGNvbnN0IHNlZW5SZWxhdGlvbnNoaXBzSW5DdXJyZW50U2VhcmNoID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZFVybERldGFpbHM6IFByb2Nlc3NlZFVybEluZm9bXSA9IFtdOyAvLyBUbyBsb2cgdGhpcyBcInRleHQgcHJvY2Vzc2luZ1wiIGV2ZW50XG5cbiAgICAgICAgY29uc3QgcmJUb2tlbiA9IGF3YWl0IHRoaXMuZ2V0UmlnaHRCcmFpbkFjY2Vzc1Rva2VuKCk7XG4gICAgICAgIGlmICghcmJUb2tlbikgeyAvLyBSQiB0b2tlbiBpcyBlc3NlbnRpYWxcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJDb3VsZCBub3Qgb2J0YWluIFJpZ2h0QnJhaW4gdG9rZW4gZm9yIHBhc3RlZCB0ZXh0IHByb2Nlc3NpbmcuXCIpO1xuICAgICAgICAgICAgLy8gTG9nIHRoaXMgYXR0ZW1wdCBhcyBhIGZhaWx1cmUgZHVlIHRvIG5vIHRva2VuXG4gICAgICAgICAgICBwcm9jZXNzZWRVcmxEZXRhaWxzLnB1c2goe1xuICAgICAgICAgICAgICAgIHVybDogYHRleHRfaW5wdXRfZm9yXyR7dGhpcy5zYW5pdGl6ZU5hbWVGb3JGaWxlUGF0aEFuZEFsaWFzKHByb2Nlc3Nvck5hbWUpLmZpbGVQYXRoTmFtZX1gLCAvLyBQbGFjZWhvbGRlciBVUkwgZm9yIGxvZ2dpbmdcbiAgICAgICAgICAgICAgICB0aXRsZTogYFBhc3RlZCBUZXh0IGZvciAke3Byb2Nlc3Nvck5hbWV9YCxcbiAgICAgICAgICAgICAgICBkb2N1bWVudFR5cGU6ICdtYW51YWxfdGV4dF9zdWJtaXNzaW9uX2ZhaWxlZCAobm9fcmJfdG9rZW4pJyxcbiAgICAgICAgICAgICAgICAvLyBObyB2ZXJpZmljYXRpb24gZGV0YWlscyBhcHBsaWNhYmxlIGhlcmUgYXMgdGhlIHByb2Nlc3MgY291bGRuJ3Qgc3RhcnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgY29sbGVjdGVkUmVsYXRpb25zaGlwcywgcHJvY2Vzc2VkVXJsRGV0YWlscywgZmxhZ2dlZENhbmRpZGF0ZVVybENvdW50OiAwIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmVwYXJlIGlucHV0IGZvciB0aGUgUkIgdGFzayBiYXNlZCBvbiBjb25maWd1cmVkIGZpZWxkIG5hbWVcbiAgICAgICAgY29uc3QgdGFza0lucHV0ID0geyBbdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluRXh0cmFjdElucHV0RmllbGRdOiBwYXN0ZWRUZXh0IH07XG4gICAgICAgIGNvbnN0IGV4dHJhY3Rpb25SZXN1bHQgPSBhd2FpdCB0aGlzLmNhbGxSaWdodEJyYWluVGFzayh0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5FeHRyYWN0RW50aXRpZXNUYXNrSWQsIHRhc2tJbnB1dCwgcmJUb2tlbik7XG5cbiAgICAgICAgbGV0IGN1cnJlbnRVcmxFeHRyYWN0ZWRDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IHNvdXJjZVBsYWNlaG9sZGVyID0gYG1hbnVhbF90ZXh0X2lucHV0OiR7cHJvY2Vzc29yTmFtZX1gOyAvLyBGb3IgdGhlIFNvdXJjZVVSTCBmaWVsZFxuXG4gICAgICAgIGlmIChleHRyYWN0aW9uUmVzdWx0ICYmIHR5cGVvZiBleHRyYWN0aW9uUmVzdWx0LnJlc3BvbnNlID09PSAnb2JqZWN0JyAmJiBleHRyYWN0aW9uUmVzdWx0LnJlc3BvbnNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCByYlJlc3BvbnNlID0gZXh0cmFjdGlvblJlc3VsdC5yZXNwb25zZTtcbiAgICAgICAgICAgIC8vIEFjY2VzcyBleHRyYWN0ZWQgZW50aXRpZXMgdXNpbmcgY29uZmlndXJlZCBmaWVsZCBuYW1lc1xuICAgICAgICAgICAgY29uc3QgdGhpcmRQYXJ0eSA9IHJiUmVzcG9uc2VbdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluRXh0cmFjdE91dHB1dFRoaXJkUGFydHlGaWVsZF0gfHwgW107XG4gICAgICAgICAgICBjb25zdCBvd24gPSByYlJlc3BvbnNlW3RoaXMuc2V0dGluZ3MucmlnaHRicmFpbkV4dHJhY3RPdXRwdXRPd25FbnRpdGllc0ZpZWxkXSB8fCBbXTtcblxuICAgICAgICAgICAgdGhpcmRQYXJ0eS5mb3JFYWNoKChlOiBhbnkpID0+IHsgLy8gQXNzdW1pbmcgJ2UnIGlzIGFuIG9iamVjdCB3aXRoICduYW1lJywgJ3Byb2Nlc3NpbmdfZnVuY3Rpb24nLCAnbG9jYXRpb24nXG4gICAgICAgICAgICAgICAgY3VycmVudFVybEV4dHJhY3RlZENvdW50ICs9IHRoaXMuYWRkUmVsYXRpb25zaGlwKGNvbGxlY3RlZFJlbGF0aW9uc2hpcHMsIHNlZW5SZWxhdGlvbnNoaXBzSW5DdXJyZW50U2VhcmNoLCBwcm9jZXNzb3JOYW1lLCBlLCBcInVzZXNfc3VicHJvY2Vzc29yXCIsIHNvdXJjZVBsYWNlaG9sZGVyLCBcIlByb2Nlc3NlZCBmcm9tIG1hbnVhbGx5IHBhc3RlZCB0ZXh0LlwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb3duLmZvckVhY2goKGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRVcmxFeHRyYWN0ZWRDb3VudCArPSB0aGlzLmFkZFJlbGF0aW9uc2hpcChjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzLCBzZWVuUmVsYXRpb25zaGlwc0luQ3VycmVudFNlYXJjaCwgcHJvY2Vzc29yTmFtZSwgZSwgXCJpc19vd25fZW50aXR5XCIsIHNvdXJjZVBsYWNlaG9sZGVyLCBcIlByb2Nlc3NlZCBmcm9tIG1hbnVhbGx5IHBhc3RlZCB0ZXh0LlwiKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBMb2cgc3VjY2Vzc2Z1bCBwcm9jZXNzaW5nXG4gICAgICAgICAgICBwcm9jZXNzZWRVcmxEZXRhaWxzLnB1c2goeyBcbiAgICAgICAgICAgICAgICB1cmw6IHNvdXJjZVBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBgUGFzdGVkIFRleHQgZm9yICR7cHJvY2Vzc29yTmFtZX1gLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50VHlwZTogJ21hbnVhbF90ZXh0X3N1Ym1pc3Npb25fcHJvY2Vzc2VkJyxcbiAgICAgICAgICAgICAgICB2ZXJpZmljYXRpb25NZXRob2Q6ICdyaWdodGJyYWluX3RleHRfdGFzaycsXG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkU3VicHJvY2Vzc29yc0NvdW50OiBjdXJyZW50VXJsRXh0cmFjdGVkQ291bnQsXG4gICAgICAgICAgICAgICAgdmVyaWZpY2F0aW9uUmVhc29uaW5nOiBgRXh0cmFjdGVkICR7Y3VycmVudFVybEV4dHJhY3RlZENvdW50fSBlbnRpdGllcyBmcm9tIHBhc3RlZCB0ZXh0LmBcbiAgICAgICAgICAgIH0pOyBcbiAgICAgICAgICAgIFxuICAgICAgICB9IGVsc2UgeyAvLyBSQiB0YXNrIGZhaWxlZCBvciByZXR1cm5lZCB1bmV4cGVjdGVkIGZvcm1hdFxuICAgICAgICAgICAgbmV3IE5vdGljZShgRmFpbGVkIHRvIGV4dHJhY3QgZW50aXRpZXMgZnJvbSBwYXN0ZWQgdGV4dCBmb3IgJHtwcm9jZXNzb3JOYW1lfS4gQ2hlY2sgY29uc29sZS5gKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFByb2Nlc3NvclByb2Nlc3NvcjogUkIgRXh0cmFjdCBGcm9tIFRleHQgdGFzayBkaWQgbm90IHJldHVybiBleHBlY3RlZCAncmVzcG9uc2UnIG9iamVjdCBvciBmYWlsZWQuIEZ1bGwgdGFzayByZXN1bHQ6YCwgSlNPTi5zdHJpbmdpZnkoZXh0cmFjdGlvblJlc3VsdCkuc3Vic3RyaW5nKDAsNTAwKSk7XG4gICAgICAgICAgICAvLyBMb2cgZmFpbGVkIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIHByb2Nlc3NlZFVybERldGFpbHMucHVzaCh7IFxuICAgICAgICAgICAgICAgIHVybDogc291cmNlUGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGBQYXN0ZWQgVGV4dCBmb3IgJHtwcm9jZXNzb3JOYW1lfWAsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRUeXBlOiAnbWFudWFsX3RleHRfc3VibWlzc2lvbl9mYWlsZWQgKHJiX3Rhc2tfZXJyb3IpJyxcbiAgICAgICAgICAgICAgICB2ZXJpZmljYXRpb25NZXRob2Q6ICdyaWdodGJyYWluX3RleHRfdGFzaycsXG4gICAgICAgICAgICAgICAgdmVyaWZpY2F0aW9uUmVhc29uaW5nOiAnUmlnaHRCcmFpbiB0YXNrIGZvciB0ZXh0IHByb2Nlc3NpbmcgZmFpbGVkIG9yIHJldHVybmVkIGFuIHVuZXhwZWN0ZWQgcmVzcG9uc2UuJ1xuICAgICAgICAgICAgfSk7IFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgY29sbGVjdGVkUmVsYXRpb25zaGlwcywgcHJvY2Vzc2VkVXJsRGV0YWlscywgZmxhZ2dlZENhbmRpZGF0ZVVybENvdW50OiAwIH07IC8vIGZsYWdnZWRDYW5kaWRhdGVVcmxDb3VudCBpcyAwIGZvciB0ZXh0IGlucHV0XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGFzeW5jIGVuc3VyZUZvbGRlckV4aXN0cyhmb2xkZXJQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgLy8gTm9ybWFsaXplIHBhdGg6IHJlbW92ZSBsZWFkaW5nIHNsYXNoIGlmIHByZXNlbnQsIGFzIHZhdWx0IHBhdGhzIGFyZSByZWxhdGl2ZSB0byB2YXVsdCByb290XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkUGF0aCA9IGZvbGRlclBhdGguc3RhcnRzV2l0aCgnLycpID8gZm9sZGVyUGF0aC5zdWJzdHJpbmcoMSkgOiBmb2xkZXJQYXRoO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQYXRoID09PSAnJykgcmV0dXJuOyAvLyBEbyBub3RoaW5nIGlmIHBhdGggaXMgZW1wdHkgKGUuZy4gcm9vdCwgdGhvdWdoIG5vdCB0eXBpY2FsIGZvciB0aGlzIHVzZSlcblxuICAgICAgICAgICAgY29uc3QgYWJzdHJhY3RGb2xkZXJQYXRoID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG5vcm1hbGl6ZWRQYXRoKTtcbiAgICAgICAgICAgIGlmICghYWJzdHJhY3RGb2xkZXJQYXRoKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlRm9sZGVyKG5vcm1hbGl6ZWRQYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBGb2xkZXIgY3JlYXRlZDogJHtub3JtYWxpemVkUGF0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2UgeyBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBGb2xkZXIgYWxyZWFkeSBleGlzdHM6ICR7bm9ybWFsaXplZFBhdGh9YCk7IH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgdGhyb3csIGJ1dCBsb2cgYW5kIG5vdGlmeS4gVGhlIG9wZXJhdGlvbiBtaWdodCBzdGlsbCBwcm9jZWVkIGlmIHRoZSBmb2xkZXIgZXhpc3RzIGJ1dCBhbiBlcnJvciBvY2N1cnJlZCBjaGVja2luZy5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGVuc3VyaW5nIGZvbGRlciAke2ZvbGRlclBhdGh9IGV4aXN0czpgLCBlKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYEVycm9yIGNyZWF0aW5nIGZvbGRlcjogJHtmb2xkZXJQYXRofWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBlbnN1cmVQcm9jZXNzb3JGaWxlKG9yaWdpbmFsUHJvY2Vzc29yTmFtZTogc3RyaW5nLCBhZGRGcm9udG1hdHRlcjogYm9vbGVhbiA9IGZhbHNlLCBpc1RvcExldmVsUHJvY2Vzc29yOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8VEZpbGUgfCBudWxsPiB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRm9sZGVyRXhpc3RzKHRoaXMuc2V0dGluZ3MucHJvY2Vzc29yc0ZvbGRlclBhdGgpO1xuICAgICAgICBjb25zdCB7IGZpbGVQYXRoTmFtZSwgb3JpZ2luYWxOYW1lQXNBbGlhcyB9ID0gdGhpcy5zYW5pdGl6ZU5hbWVGb3JGaWxlUGF0aEFuZEFsaWFzKG9yaWdpbmFsUHJvY2Vzc29yTmFtZSk7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuc2V0dGluZ3MucHJvY2Vzc29yc0ZvbGRlclBhdGguc3RhcnRzV2l0aCgnLycpID8gdGhpcy5zZXR0aW5ncy5wcm9jZXNzb3JzRm9sZGVyUGF0aC5zdWJzdHJpbmcoMSkgOiB0aGlzLnNldHRpbmdzLnByb2Nlc3NvcnNGb2xkZXJQYXRoO1xuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGAke2ZvbGRlcn0vJHtmaWxlUGF0aE5hbWV9Lm1kYDtcbiAgICAgICAgbGV0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZVBhdGgpIGFzIFRGaWxlO1xuICAgIFxuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGluaXRpYWxDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoYWRkRnJvbnRtYXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFnID0gaXNUb3BMZXZlbFByb2Nlc3NvciA/ICdwcm9jZXNzb3InIDogJ3N1YnByb2Nlc3Nvcic7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsaWFzRm9yRnJvbnRtYXR0ZXIgPSBvcmlnaW5hbE5hbWVBc0FsaWFzLnJlcGxhY2UoL1s6XFxbXFxdLFwiXS9nLCAnJyk7IFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGVudCA9IGAtLS1cXG50YWdzOiBbJHt0YWd9XVxcbmFsaWFzZXM6IFtcIiR7YWxpYXNGb3JGcm9udG1hdHRlcn1cIl1cXG4tLS1cXG5cXG4jICR7b3JpZ2luYWxOYW1lQXNBbGlhc31cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZW50ID0gYCMgJHtvcmlnaW5hbE5hbWVBc0FsaWFzfVxcblxcbmA7IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaWxlID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKGZpbGVQYXRoLCBpbml0aWFsQ29udGVudCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgaWYgKGUubWVzc2FnZT8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImZpbGUgYWxyZWFkeSBleGlzdHNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmaWxlUGF0aCkgYXMgVEZpbGU7XG4gICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGUpIHsgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGdldCBmaWxlICR7ZmlsZVBhdGh9IGFmdGVyICdhbHJlYWR5IGV4aXN0cycgZXJyb3IuYCk7IHJldHVybiBudWxsOyB9XG4gICAgICAgICAgICAgICAgIH0gZWxzZSB7IGNvbnNvbGUuZXJyb3IoYEVycm9yIGNyZWF0aW5nIHByb2Nlc3NvciBmaWxlICR7ZmlsZVBhdGh9OmAsIGUpOyByZXR1cm4gbnVsbDsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlICYmIGFkZEZyb250bWF0dGVyKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBpc1RvcExldmVsUHJvY2Vzc29yID8gJ3Byb2Nlc3NvcicgOiAnc3VicHJvY2Vzc29yJztcbiAgICAgICAgICAgIGNvbnN0IGFsaWFzRm9yRnJvbnRtYXR0ZXIgPSBvcmlnaW5hbE5hbWVBc0FsaWFzLnJlcGxhY2UoL1s6XFxbXFxdLFwiXS9nLCAnJyk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5wcm9jZXNzKGZpbGUsIChjb250ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0NvbnRlbnQgPSB0aGlzLnVwZGF0ZUZyb250bWF0dGVyKGNvbnRlbnQsIHsgdGFnczogW3RhZ10sIGFsaWFzZXM6IFthbGlhc0ZvckZyb250bWF0dGVyXSB9LCBvcmlnaW5hbE5hbWVBc0FsaWFzKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5ld0NvbnRlbnQudHJpbSgpLmluY2x1ZGVzKGAjICR7b3JpZ2luYWxOYW1lQXNBbGlhc31gKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5U3RhcnRJbmRleCA9IG5ld0NvbnRlbnQuaW5kZXhPZignXFxuLS0tJykgPiAwID8gbmV3Q29udGVudC5pbmRleE9mKCdcXG4tLS0nLCBuZXdDb250ZW50LmluZGV4T2YoJ1xcbi0tLScpICsgMykgKyA0IDogMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IG5ld0NvbnRlbnQuc3Vic3RyaW5nKGJvZHlTdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJvbnRtYXR0ZXJQYXJ0ID0gbmV3Q29udGVudC5zdWJzdHJpbmcoMCwgYm9keVN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZW50ID0gZnJvbnRtYXR0ZXJQYXJ0ICsgKGZyb250bWF0dGVyUGFydC5lbmRzV2l0aChcIlxcblwiKSA/IFwiXCIgOiBcIlxcblwiKSArIGAjICR7b3JpZ2luYWxOYW1lQXNBbGlhc31cXG5cXG5gICsgYm9keS50cmltU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NvbnRlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgYXN5bmMgdXBkYXRlUHJvY2Vzc29yRmlsZShmaWxlOiBURmlsZSwgb3JpZ2luYWxQcm9jZXNzb3JOYW1lOiBzdHJpbmcsIHJlbGF0aW9uc2hpcHM6IEV4dHJhY3RlZFJlbGF0aW9uc2hpcFtdLCBpc1RvcExldmVsUHJvY2Vzc29yOiBib29sZWFuKSB7XG4gICAgICAgIGNvbnN0IHN1YnByb2Nlc3NvcnNIZWFkaW5nID0gXCJTdWJwcm9jZXNzb3JzXCI7XG4gICAgICAgIGxldCB0YWJsZU1kID0gYHwgU3VicHJvY2Vzc29yIEVudGl0eSBOYW1lIHwgUHJvY2Vzc2luZyBGdW5jdGlvbiB8IExvY2F0aW9uIHxcXG5gO1xuICAgICAgICB0YWJsZU1kICs9IGB8LS0tfC0tLXwtLS18XFxuYDtcblxuICAgICAgICAvLyBGaWx0ZXIgZm9yICd1c2VzX3N1YnByb2Nlc3NvcicgcmVsYXRpb25zaGlwcyB3aGVyZSB0aGUgY3VycmVudCBwcm9jZXNzb3IgaXMgdGhlIFByaW1hcnlQcm9jZXNzb3JcbiAgICAgICAgY29uc3QgcmVsZXZhbnRSZWxhdGlvbnNoaXBzID0gcmVsYXRpb25zaGlwcy5maWx0ZXIociA9PiByLlJlbGF0aW9uc2hpcFR5cGUgPT09ICd1c2VzX3N1YnByb2Nlc3NvcicgJiYgci5QcmltYXJ5UHJvY2Vzc29yID09PSBvcmlnaW5hbFByb2Nlc3Nvck5hbWUpO1xuXG4gICAgICAgIHJlbGV2YW50UmVsYXRpb25zaGlwcy5mb3JFYWNoKHJlbCA9PiB7XG4gICAgICAgICAgICAvLyBTYW5pdGl6ZSB0aGUgc3VicHJvY2Vzc29yJ3MgbmFtZSBmb3IgZmlsZSBwYXRoIGFuZCBnZXQgb3JpZ2luYWwgZm9yIGFsaWFzXG4gICAgICAgICAgICBjb25zdCB7IGZpbGVQYXRoTmFtZTogc3ViRmlsZVBhdGhOYW1lLCBvcmlnaW5hbE5hbWVBc0FsaWFzOiBzdWJPcmlnaW5hbE5hbWUgfSA9IHRoaXMuc2FuaXRpemVOYW1lRm9yRmlsZVBhdGhBbmRBbGlhcyhyZWwuU3VicHJvY2Vzc29yTmFtZSk7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIGRpc3BsYXkgYWxpYXMgZm9yIE1hcmtkb3duIGxpbmsgKHJlbW92ZSBjaGFycyB0aGF0IGJyZWFrIGxpbmtzL2Rpc3BsYXkpXG4gICAgICAgICAgICBjb25zdCBtYXJrZG93bkFsaWFzID0gc3ViT3JpZ2luYWxOYW1lLnJlcGxhY2UoL1xcbi9nLCAnICcpLnJlcGxhY2UoL1tcXFtcXF0oKXxdL2csICcnKTsgLy8gQmFzaWMgc2FuaXRpemF0aW9uIGZvciBsaW5rIHRleHRcblxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29yc0ZvbGRlciA9IHRoaXMuc2V0dGluZ3MucHJvY2Vzc29yc0ZvbGRlclBhdGg7IC8vIE5vIGxlYWRpbmcvdHJhaWxpbmcgc2xhc2hlcyBuZWVkZWQgYnkgZW5jb2RlVVJJIGlmIHBhdGggaXMgY2xlYW5cbiAgICAgICAgICAgIGNvbnN0IG1hcmtkb3duTGlua1RhcmdldCA9IGVuY29kZVVSSShgJHtwcm9jZXNzb3JzRm9sZGVyfS8ke3N1YkZpbGVQYXRoTmFtZX0ubWRgKTsgLy8gVXNlIHNhbml0aXplZCBuYW1lIGZvciBsaW5rIHRhcmdldFxuXG4gICAgICAgICAgICBjb25zdCBzdWJwcm9jZXNzb3JQYWdlTGluayA9IGBbJHttYXJrZG93bkFsaWFzfV0oJHttYXJrZG93bkxpbmtUYXJnZXR9KWA7IC8vIFVzZSBzdGFuZGFyZCBNYXJrZG93biBsaW5rIGZvcm1hdFxuXG4gICAgICAgICAgICAvLyBTY3J1YiBhbmQgcHJlcGFyZSBkaXNwbGF5IGZvciBwcm9jZXNzaW5nIGZ1bmN0aW9uIGFuZCBsb2NhdGlvblxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2luZ0Z1bmN0aW9uRGlzcGxheSA9IChyZWwuUHJvY2Vzc2luZ0Z1bmN0aW9uIHx8IFwiTi9BXCIpLnJlcGxhY2UoL1xcbi9nLCBcIjxicj5cIikucmVwbGFjZSgvXFx8L2csIFwiXFxcXHxcIik7XG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbkRpc3BsYXkgPSAocmVsLkxvY2F0aW9uIHx8IFwiTi9BXCIpLnJlcGxhY2UoL1xcbi9nLCBcIjxicj5cIikucmVwbGFjZSgvXFx8L2csIFwiXFxcXHxcIik7XG5cbiAgICAgICAgICAgIHRhYmxlTWQgKz0gYHwgJHtzdWJwcm9jZXNzb3JQYWdlTGlua30gfCAke3Byb2Nlc3NpbmdGdW5jdGlvbkRpc3BsYXl9IHwgJHtsb2NhdGlvbkRpc3BsYXl9IHxcXG5gO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIGNvbnN0IGFuYWx5c2lzTG9nc0hlYWRpbmcgPSBcIkFuYWx5c2lzIExvZ3NcIjtcbiAgICAgICAgLy8gU2FuaXRpemUgcHJvY2Vzc29yIG5hbWUgZm9yIGxvZyBmaWxlIG5hbWUgcGFydFxuICAgICAgICBjb25zdCB7IGZpbGVQYXRoTmFtZTogbG9nRmlsZVBhdGhOYW1lUGFydCB9ID0gdGhpcy5zYW5pdGl6ZU5hbWVGb3JGaWxlUGF0aEFuZEFsaWFzKG9yaWdpbmFsUHJvY2Vzc29yTmFtZSk7XG4gICAgICAgIGNvbnN0IGFuYWx5c2lzTG9nc0ZvbGRlciA9IHRoaXMuc2V0dGluZ3MuYW5hbHlzaXNMb2dzRm9sZGVyUGF0aDsgLy8gTm9ybWFsaXplZFxuICAgICAgICBjb25zdCBsb2dGaWxlTmFtZSA9IGAke2xvZ0ZpbGVQYXRoTmFtZVBhcnR9IFN1YnByb2Nlc3NvciBMb2dzLm1kYDtcbiAgICAgICAgY29uc3QgbG9nRmlsZUxpbmtUYXJnZXQgPSBlbmNvZGVVUkkoYCR7YW5hbHlzaXNMb2dzRm9sZGVyfS8ke2xvZ0ZpbGVOYW1lfWApOyAvLyBVc2Ugc2FuaXRpemVkIG5hbWUgZm9yIGxvZyBmaWxlIGxpbmtcbiAgICAgICAgY29uc3QgbG9nRmlsZUxpbmsgPSBgW1ske2FuYWx5c2lzTG9nc0ZvbGRlcn0vJHtsb2dGaWxlTmFtZX18JHtvcmlnaW5hbFByb2Nlc3Nvck5hbWV9IFN1YnByb2Nlc3NvciBMb2dzXV1gOyAvLyBPYnNpZGlhbiBsaW5rIHRvIGxvZ1xuICAgICAgICBjb25zdCBhbmFseXNpc0xvZ1NlY3Rpb24gPSBgXFxuLSAke2xvZ0ZpbGVMaW5rfVxcbmA7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQucHJvY2VzcyhmaWxlLCAoY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBpc1RvcExldmVsUHJvY2Vzc29yID8gJ3Byb2Nlc3NvcicgOiAnc3VicHJvY2Vzc29yJztcbiAgICAgICAgICAgIGxldCBuZXdDb250ZW50ID0gdGhpcy51cGRhdGVGcm9udG1hdHRlcihjb250ZW50LCB7IHRhZ3M6IFt0YWddLCBhbGlhc2VzOiBbb3JpZ2luYWxQcm9jZXNzb3JOYW1lLnJlcGxhY2UoL1s6XFxbXFxdLFwiXS9nLCAnJyldIH0sIG9yaWdpbmFsUHJvY2Vzc29yTmFtZSk7XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBIMSBoZWFkaW5nIGZvciBvcmlnaW5hbFByb2Nlc3Nvck5hbWVcbiAgICAgICAgICAgIGlmICghbmV3Q29udGVudC50cmltKCkuaW5jbHVkZXMoYCMgJHtvcmlnaW5hbFByb2Nlc3Nvck5hbWV9YCkpIHtcbiAgICAgICAgICAgICAgICAgY29uc3QgYm9keVN0YXJ0SW5kZXggPSBuZXdDb250ZW50LmluZGV4T2YoJ1xcbi0tLScpID4gMCA/IG5ld0NvbnRlbnQuaW5kZXhPZignXFxuLS0tJywgbmV3Q29udGVudC5pbmRleE9mKCdcXG4tLS0nKSArIDMpICsgNCA6IDA7XG4gICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBuZXdDb250ZW50LnN1YnN0cmluZyhib2R5U3RhcnRJbmRleCk7XG4gICAgICAgICAgICAgICAgIGNvbnN0IGZyb250bWF0dGVyUGFydCA9IG5ld0NvbnRlbnQuc3Vic3RyaW5nKDAsIGJvZHlTdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICAgbmV3Q29udGVudCA9IGZyb250bWF0dGVyUGFydCArIChmcm9udG1hdHRlclBhcnQuZW5kc1dpdGgoXCJcXG5cIikgPyBcIlwiIDogXCJcXG5cIikgKyBgIyAke29yaWdpbmFsUHJvY2Vzc29yTmFtZX1cXG5cXG5gICsgYm9keS50cmltU3RhcnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5zdXJlL1VwZGF0ZSBTdWJwcm9jZXNzb3JzIHNlY3Rpb25cbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSB0aGlzLmVuc3VyZUhlYWRpbmdBbmRTZWN0aW9uKG5ld0NvbnRlbnQsIHN1YnByb2Nlc3NvcnNIZWFkaW5nLCB0YWJsZU1kLCBudWxsLCBudWxsKTsgLy8gUmVwbGFjZSBlbnRpcmUgc2VjdGlvblxuICAgICAgICAgICAgLy8gRW5zdXJlL1VwZGF0ZSBBbmFseXNpcyBMb2dzIHNlY3Rpb25cbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSB0aGlzLmVuc3VyZUhlYWRpbmdBbmRTZWN0aW9uKG5ld0NvbnRlbnQsIGFuYWx5c2lzTG9nc0hlYWRpbmcsIGFuYWx5c2lzTG9nU2VjdGlvbiwgbnVsbCwgbnVsbCwgdHJ1ZSk7IC8vIEFwcGVuZCBpZiBoZWFkaW5nIGV4aXN0cywgZWxzZSBjcmVhdGVcbiAgICAgICAgICAgIHJldHVybiBuZXdDb250ZW50O1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgYXN5bmMgY3JlYXRlT3JVcGRhdGVTdWJwcm9jZXNzb3JGaWxlKFxuICAgICAgICBvcmlnaW5hbFN1YnByb2Nlc3Nvck5hbWU6IHN0cmluZywgLy8gVGhlIG5hbWUgb2YgdGhlIHN1YnByb2Nlc3NvciBpdHNlbGYgKGUuZy4sIFwiQVdTXCIpXG4gICAgICAgIG9yaWdpbmFsUHJpbWFyeVByb2Nlc3Nvck5hbWVGb3JDb250ZXh0OiBzdHJpbmcsIC8vIFRoZSBwcmltYXJ5IHByb2Nlc3NvciBjdXJyZW50bHkgYmVpbmcgcHJvY2Vzc2VkIChlLmcuLCBcIk9wZW5BSVwiKSAtIGZvciBjb250ZXh0LCBub3QgdXN1YWxseSBtYWluIGNvbnRlbnQgb2YgQVdTLm1kXG4gICAgICAgIG5ld0NsaWVudFJlbGF0aW9uc2hpcHM6IEV4dHJhY3RlZFJlbGF0aW9uc2hpcFtdIC8vIFJlbGF0aW9uc2hpcHMgd2hlcmUgb3JpZ2luYWxTdWJwcm9jZXNzb3JOYW1lIGlzIHRoZSB0YXJnZXQgKFN1YnByb2Nlc3Nvck5hbWUpIGFuZCB0eXBlIGlzICd1c2VzX3N1YnByb2Nlc3NvcidcbiAgICApIHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVGb2xkZXJFeGlzdHModGhpcy5zZXR0aW5ncy5wcm9jZXNzb3JzRm9sZGVyUGF0aCk7XG4gICAgICAgIGNvbnN0IHsgZmlsZVBhdGhOYW1lOiBzdWJGaWxlUGF0aE5hbWUsIG9yaWdpbmFsTmFtZUFzQWxpYXM6IHN1Yk9yaWdpbmFsTmFtZUFzQWxpYXMgfSA9IHRoaXMuc2FuaXRpemVOYW1lRm9yRmlsZVBhdGhBbmRBbGlhcyhvcmlnaW5hbFN1YnByb2Nlc3Nvck5hbWUpO1xuICAgICAgICBjb25zdCBmb2xkZXIgPSB0aGlzLnNldHRpbmdzLnByb2Nlc3NvcnNGb2xkZXJQYXRoLnN0YXJ0c1dpdGgoJy8nKSA/IHRoaXMuc2V0dGluZ3MucHJvY2Vzc29yc0ZvbGRlclBhdGguc3Vic3RyaW5nKDEpIDogdGhpcy5zZXR0aW5ncy5wcm9jZXNzb3JzRm9sZGVyUGF0aDtcbiAgICAgICAgY29uc3Qgc3ViRmlsZVBhdGggPSBgJHtmb2xkZXJ9LyR7c3ViRmlsZVBhdGhOYW1lfS5tZGA7XG5cbiAgICAgICAgbGV0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoc3ViRmlsZVBhdGgpIGFzIFRGaWxlO1xuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFsaWFzRm9yRnJvbnRtYXR0ZXIgPSBzdWJPcmlnaW5hbE5hbWVBc0FsaWFzLnJlcGxhY2UoL1s6XFxbXFxdLFwiXS9nLCAnJyk7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsQ29udGVudCA9IGAtLS1cXG50YWdzOiBbc3VicHJvY2Vzc29yXVxcbmFsaWFzZXM6IFtcIiR7YWxpYXNGb3JGcm9udG1hdHRlcn1cIl1cXG4tLS1cXG5cXG4jICR7c3ViT3JpZ2luYWxOYW1lQXNBbGlhc31cXG5cXG4jIyBVc2VkIEJ5XFxuXFxuYDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZmlsZSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShzdWJGaWxlUGF0aCwgaW5pdGlhbENvbnRlbnQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUubWVzc2FnZT8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImZpbGUgYWxyZWFkeSBleGlzdHNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChzdWJGaWxlUGF0aCkgYXMgVEZpbGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlsZSkgeyBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZ2V0IHN1YnByb2Nlc3NvciBmaWxlICR7c3ViRmlsZVBhdGh9IGFmdGVyICdhbHJlYWR5IGV4aXN0cycgZXJyb3IuYCk7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IGNvbnNvbGUuZXJyb3IoYEVycm9yIGNyZWF0aW5nIHN1YnByb2Nlc3NvciBmaWxlICR7c3ViRmlsZVBhdGh9OmAsIGUpOyByZXR1cm47IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmlsZSkgcmV0dXJuOyAvLyBTaG91bGQgbm90IGhhcHBlbiBpZiBjcmVhdGlvbi9yZXRyaWV2YWwgd2FzIHN1Y2Nlc3NmdWxcblxuICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5wcm9jZXNzKGZpbGUsIChjb250ZW50OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGxldCBuZXdDb250ZW50ID0gdGhpcy51cGRhdGVGcm9udG1hdHRlcihjb250ZW50LCB7IHRhZ3M6IFtcInN1YnByb2Nlc3NvclwiXSwgYWxpYXNlczogW3N1Yk9yaWdpbmFsTmFtZUFzQWxpYXMucmVwbGFjZSgvWzpcXFtcXF0sXCJdL2csICcnKV0gfSwgc3ViT3JpZ2luYWxOYW1lQXNBbGlhcyk7XG4gICAgICAgICAgICBpZiAoIW5ld0NvbnRlbnQudHJpbSgpLmluY2x1ZGVzKGAjICR7c3ViT3JpZ2luYWxOYW1lQXNBbGlhc31gKSkge1xuICAgICAgICAgICAgICAgICBjb25zdCBib2R5U3RhcnRJbmRleCA9IG5ld0NvbnRlbnQuaW5kZXhPZignXFxuLS0tJykgPiAwID8gbmV3Q29udGVudC5pbmRleE9mKCdcXG4tLS0nLCBuZXdDb250ZW50LmluZGV4T2YoJ1xcbi0tLScpICsgMykgKyA0IDogMDtcbiAgICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IG5ld0NvbnRlbnQuc3Vic3RyaW5nKGJvZHlTdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICAgY29uc3QgZnJvbnRtYXR0ZXJQYXJ0ID0gbmV3Q29udGVudC5zdWJzdHJpbmcoMCwgYm9keVN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgICBuZXdDb250ZW50ID0gZnJvbnRtYXR0ZXJQYXJ0ICsgKGZyb250bWF0dGVyUGFydC5lbmRzV2l0aChcIlxcblwiKSA/IFwiXCIgOiBcIlxcblwiKSArIGAjICR7c3ViT3JpZ2luYWxOYW1lQXNBbGlhc31cXG5cXG5gICsgYm9keS50cmltU3RhcnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdXNlZEJ5SGVhZGluZyA9IFwiVXNlZCBCeVwiO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTdGVwIDE6IEV4dHJhY3QgZXhpc3Rpbmcgcm93cyBhbmQgcHV0IHRoZW0gaW4gYSBTZXQgdG8gaGFuZGxlIHVuaXF1ZW5lc3NcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUm93cyA9IHRoaXMuZXh0cmFjdENsaWVudFRhYmxlUm93cyhjb250ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGFsbFJvd3MgPSBuZXcgU2V0PHN0cmluZz4oZXhpc3RpbmdSb3dzKTtcblxuICAgICAgICAgICAgLy8gU3RlcCAyOiBQcm9jZXNzIG5ldyByZWxhdGlvbnNoaXBzIGFuZCBhZGQgdGhlbSB0byB0aGUgU2V0XG4gICAgICAgICAgICBuZXdDbGllbnRSZWxhdGlvbnNoaXBzLmZvckVhY2gocmVsID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsTmFtZUFzQWxpYXM6IHByaW1hcnlPcmlnaW5hbE5hbWUgfSA9IHRoaXMuc2FuaXRpemVOYW1lRm9yRmlsZVBhdGhBbmRBbGlhcyhyZWwuUHJpbWFyeVByb2Nlc3Nvcik7XG4gICAgICAgICAgICAgICAgLy8gV2Ugbm8gbG9uZ2VyIGNyZWF0ZSBhIGxpbmssIHNvIHdlIGp1c3QgdXNlIHRoZSBuYW1lIGFuZCBlc2NhcGUgYW55IHBpcGUgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICBjb25zdCBwcmltYXJ5UHJvY2Vzc29yUGxhaW5UZXh0ID0gcHJpbWFyeU9yaWdpbmFsTmFtZS5yZXBsYWNlKC9cXHwvZywgXCJcXFxcfFwiKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NpbmdGdW5jdGlvbkRpc3BsYXkgPSAocmVsLlByb2Nlc3NpbmdGdW5jdGlvbiB8fCBcIk4vQVwiKS5yZXBsYWNlKC9cXG4vZywgXCI8YnI+XCIpLnJlcGxhY2UoL1xcfC9nLCBcIlxcXFx8XCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uRGlzcGxheSA9IChyZWwuTG9jYXRpb24gfHwgXCJOL0FcIikucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKS5yZXBsYWNlKC9cXHwvZywgXCJcXFxcfFwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VVcmxMaW5rID0gcmVsLlNvdXJjZVVSTC5zdGFydHNXaXRoKFwiaHR0cFwiKSA/IGBbU291cmNlXSgke3JlbC5Tb3VyY2VVUkx9KWAgOiByZWwuU291cmNlVVJMO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBpbm5lciBjb250ZW50IG9mIHRoZSByb3csIG5vdyB1c2luZyBwbGFpbiB0ZXh0IGZvciB0aGUgcHJpbWFyeSBwcm9jZXNzb3IuXG4gICAgICAgICAgICAgICAgY29uc3Qgcm93Q29udGVudCA9IGAgJHtwcmltYXJ5UHJvY2Vzc29yUGxhaW5UZXh0fSB8ICR7cHJvY2Vzc2luZ0Z1bmN0aW9uRGlzcGxheX0gfCAke2xvY2F0aW9uRGlzcGxheX0gfCAke3NvdXJjZVVybExpbmt9IGA7XG4gICAgICAgICAgICAgICAgYWxsUm93cy5hZGQocm93Q29udGVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU3RlcCAzOiBCdWlsZCB0aGUgZmluYWwsIGNvbXBsZXRlIHRhYmxlIGZyb20gdGhlIFNldCBvZiBhbGwgcm93c1xuICAgICAgICAgICAgbGV0IGNsaWVudFRhYmxlTWQgPSBgfCBQcmltYXJ5IFByb2Nlc3NvciB8IFByb2Nlc3NpbmcgRnVuY3Rpb24gfCBMb2NhdGlvbiB8IFNvdXJjZSBVUkwgfFxcbmA7XG4gICAgICAgICAgICBjbGllbnRUYWJsZU1kICs9IGB8LS0tfC0tLXwtLS18LS0tfFxcbmA7XG4gICAgICAgICAgICBhbGxSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBSZS1hZGQgdGhlIG91dGVyIHBpcGVzIGZvciBlYWNoIHJvd1xuICAgICAgICAgICAgICAgIGNsaWVudFRhYmxlTWQgKz0gYHwke3Jvd318XFxuYDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTdGVwIDQ6IFJlcGxhY2UgdGhlIG9sZCBzZWN0aW9uIHdpdGggdGhlIG5ldywgbWVyZ2VkIHRhYmxlXG4gICAgICAgICAgICBuZXdDb250ZW50ID0gdGhpcy5lbnN1cmVIZWFkaW5nQW5kU2VjdGlvbihuZXdDb250ZW50LCB1c2VkQnlIZWFkaW5nLCBjbGllbnRUYWJsZU1kLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdDb250ZW50O1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgdXBkYXRlRnJvbnRtYXR0ZXIoY29udGVudDogc3RyaW5nLCB1cGRhdGVzOiB7IHRhZ3M/OiBzdHJpbmdbXSwgYWxpYXNlcz86IHN0cmluZ1tdIH0sIHBhZ2VOYW1lRm9yQWxpYXM6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGxldCBmbTogYW55ID0ge307XG4gICAgICAgIGNvbnN0IGZtUmVnZXggPSAvXi0tLVxccypcXG4oW1xcc1xcU10qPylcXG4tLS1cXHMqXFxuLztcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjb250ZW50Lm1hdGNoKGZtUmVnZXgpO1xuICAgICAgICBsZXQgYm9keSA9IGNvbnRlbnQ7XG5cbiAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEJhc2ljIFlBTUwgcGFyc2luZyAtIGZvciBtb3JlIGNvbXBsZXggWUFNTCwgYSBsaWJyYXJ5IHdvdWxkIGJlIG5lZWRlZFxuICAgICAgICAgICAgICAgIGNvbnN0IHlhbWxMaW5lcyA9IG1hdGNoWzFdLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICB5YW1sTGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcGFydHNbMF0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJ0cy5zbGljZSgxKS5qb2luKCc6JykudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3RhZ3MnIHx8IGtleSA9PT0gJ2FsaWFzZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIGFzIGFycmF5IGlmIGl0IGxvb2tzIGxpa2Ugb25lLCBvdGhlcndpc2UgdHJlYXQgYXMgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ1snKSAmJiB2YWx1ZS5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtW2tleV0gPSB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSkuc3BsaXQoJywnKS5tYXAocyA9PiBzLnRyaW0oKS5yZXBsYWNlKC9eW1wiJ118W1wiJ10kL2csICcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gU2luZ2xlIGl0ZW0gbm90IGluIGxpc3QgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtW2tleV0gPSBbdmFsdWUucmVwbGFjZSgvXltcIiddfFtcIiddJC9nLCAnJyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm1ba2V5XSA9IHZhbHVlLnJlcGxhY2UoL15bXCInXXxbXCInXSQvZywgJycpOyAvLyBTaW1wbGUgc3RyaW5nIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJQcm9jZXNzb3JQcm9jZXNzb3I6IENvdWxkIG5vdCBwYXJzZSBleGlzdGluZyBmcm9udG1hdHRlciwgd2lsbCBvdmVyd3JpdGUgcmVsZXZhbnQga2V5cy5cIiwgZSk7XG4gICAgICAgICAgICAgICAgZm0gPSB7fTsgLy8gUmVzZXQgaWYgcGFyc2luZyBmYWlsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keSA9IGNvbnRlbnQuc3Vic3RyaW5nKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGFnc1xuICAgICAgICBpZiAodXBkYXRlcy50YWdzKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VGFncyA9IG5ldyBTZXQoQXJyYXkuaXNBcnJheShmbS50YWdzKSA/IGZtLnRhZ3MubWFwKCh0OiBzdHJpbmcpID0+IFN0cmluZyh0KS50b0xvd2VyQ2FzZSgpKSA6IFtdKTtcbiAgICAgICAgICAgIHVwZGF0ZXMudGFncy5mb3JFYWNoKHRhZyA9PiBjdXJyZW50VGFncy5hZGQoU3RyaW5nKHRhZykudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgZm0udGFncyA9IEFycmF5LmZyb20oY3VycmVudFRhZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGFsaWFzZXMsIGVuc3VyaW5nIHBhZ2VOYW1lRm9yQWxpYXMgKHNhbml0aXplZCkgaXMgcHJlc2VudFxuICAgICAgICBpZiAodXBkYXRlcy5hbGlhc2VzKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QWxpYXNlcyA9IG5ldyBTZXQoQXJyYXkuaXNBcnJheShmbS5hbGlhc2VzKSA/IGZtLmFsaWFzZXMubWFwKChhOiBzdHJpbmcpID0+IFN0cmluZyhhKSkgOiBbXSk7XG4gICAgICAgICAgICB1cGRhdGVzLmFsaWFzZXMuZm9yRWFjaChhbGlhcyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FuaXRpemVkQWxpYXMgPSBTdHJpbmcoYWxpYXMpLnJlcGxhY2UoL1s6XFxbXFxdLFwiXS9nLCAnJyk7IC8vIFNhbml0aXplIGZvciBZQU1MXG4gICAgICAgICAgICAgICAgaWYgKHNhbml0aXplZEFsaWFzKSBjdXJyZW50QWxpYXNlcy5hZGQoc2FuaXRpemVkQWxpYXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIG1haW4gcGFnZU5hbWVGb3JBbGlhcyAoc2FuaXRpemVkKSBpcyBhbHNvIHByZXNlbnQgYXMgYW4gYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IHNhbml0aXplZFBhZ2VOYW1lQWxpYXMgPSBTdHJpbmcocGFnZU5hbWVGb3JBbGlhcykucmVwbGFjZSgvWzpcXFtcXF0sXCJdL2csICcnKTtcbiAgICAgICAgICAgIGlmIChzYW5pdGl6ZWRQYWdlTmFtZUFsaWFzKSBjdXJyZW50QWxpYXNlcy5hZGQoc2FuaXRpemVkUGFnZU5hbWVBbGlhcyk7XG5cbiAgICAgICAgICAgIGZtLmFsaWFzZXMgPSBBcnJheS5mcm9tKGN1cnJlbnRBbGlhc2VzKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gUmVjb25zdHJ1Y3QgZnJvbnRtYXR0ZXIgc3RyaW5nXG4gICAgICAgIGxldCBmbVN0cmluZyA9IFwiLS0tXFxuXCI7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZtKSB7XG4gICAgICAgICAgICBpZiAoZm0uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZtW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbVtrZXldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZtU3RyaW5nICs9IGAke2tleX06IFske2ZtW2tleV0ubWFwKChpdGVtOiBzdHJpbmcpID0+IGBcIiR7aXRlbX1cImApLmpvaW4oJywgJyl9XVxcbmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmbVN0cmluZyArPSBgJHtrZXl9OiBcIiR7Zm1ba2V5XX1cIlxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZtU3RyaW5nICs9IFwiLS0tXFxuXCI7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIG5vIG9yaWdpbmFsIGZyb250bWF0dGVyIGFuZCB3ZSBkaWRuJ3QgYWN0dWFsbHkgYWRkIGFueSB2YWxpZCBmbSwgZG9uJ3QgcHJlcGVuZCBlbXB0eSBmbSBibG9ja1xuICAgICAgICBpZiAoZm1TdHJpbmcgPT09IFwiLS0tXFxuLS0tXFxuXCIgJiYgIW1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbVN0cmluZyArIGJvZHk7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGFzeW5jIHVwZGF0ZUFuYWx5c2lzTG9nUGFnZShwcm9jZXNzb3JOYW1lOiBzdHJpbmcsIHByb2Nlc3NlZFVybHM6IFByb2Nlc3NlZFVybEluZm9bXSwgcmVsYXRpb25zaGlwczogRXh0cmFjdGVkUmVsYXRpb25zaGlwW10sIG1lcmdlRGVjaXNpb25zOiBzdHJpbmdbXSkge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUZvbGRlckV4aXN0cyh0aGlzLnNldHRpbmdzLmFuYWx5c2lzTG9nc0ZvbGRlclBhdGgpO1xuICAgICAgICBjb25zdCB7IGZpbGVQYXRoTmFtZTogc2FuaXRpemVkUHJvY2Vzc29yTmFtZUZvckxvZ0ZpbGUgfSA9IHRoaXMuc2FuaXRpemVOYW1lRm9yRmlsZVBhdGhBbmRBbGlhcyhwcm9jZXNzb3JOYW1lKTtcblxuICAgICAgICBjb25zdCBsb2dzRm9sZGVyID0gdGhpcy5zZXR0aW5ncy5hbmFseXNpc0xvZ3NGb2xkZXJQYXRoOyAvLyBOb3JtYWxpemVkXG4gICAgICAgIGNvbnN0IGxvZ0ZpbGVOYW1lID0gYCR7c2FuaXRpemVkUHJvY2Vzc29yTmFtZUZvckxvZ0ZpbGV9IFN1YnByb2Nlc3NvciBMb2dzLm1kYDsgLy8gVXNlIHNhbml0aXplZCBuYW1lXG4gICAgICAgIGNvbnN0IGxvZ0ZpbGVQYXRoID0gYCR7bG9nc0ZvbGRlcn0vJHtsb2dGaWxlTmFtZX1gO1xuXG4gICAgICAgIGNvbnN0IGxvZ0VudHJ5Q29udGVudCA9IHRoaXMuZm9ybWF0UmVzdWx0c0Zvck9ic2lkaWFuTG9nKHByb2Nlc3Nvck5hbWUsIHJlbGF0aW9uc2hpcHMsIHByb2Nlc3NlZFVybHMsIG1lcmdlRGVjaXNpb25zKTtcblxuICAgICAgICAvLyBVc2UgZW5zdXJlX2V4aXN0c19hbmRfYXBwZW5kIG1vZGUuIFRoZSB0aXRsZSBpcyBoYW5kbGVkIGJ5IGZvcm1hdFJlc3VsdHNGb3JPYnNpZGlhbkxvZy5cbiAgICAgICAgYXdhaXQgdGhpcy53cml0ZVJlc3VsdHNUb09ic2lkaWFuTm90ZShsb2dGaWxlUGF0aCwgbG9nRW50cnlDb250ZW50LCAnZW5zdXJlX2V4aXN0c19hbmRfYXBwZW5kJywgcHJvY2Vzc29yTmFtZSk7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGVuc3VyZUhlYWRpbmdBbmRTZWN0aW9uKFxuICAgICAgICBjb250ZW50OiBzdHJpbmcsXG4gICAgICAgIGhlYWRpbmdUZXh0OiBzdHJpbmcsXG4gICAgICAgIHNlY3Rpb25OZXdDb250ZW50OiBzdHJpbmcsXG4gICAgICAgIHN0YXJ0TWFya2VyOiBzdHJpbmcgfCBudWxsID0gbnVsbCwgLy8gZS5nLiwgPCEtLSBTVEFSVDogU1VCUFJPQ0VTU09SUyAtLT5cbiAgICAgICAgZW5kTWFya2VyOiBzdHJpbmcgfCBudWxsID0gbnVsbCwgICAvLyBlLmcuLCA8IS0tIEVORDogU1VCUFJPQ0VTU09SUyAtLT5cbiAgICAgICAgYXBwZW5kVW5kZXJIZWFkaW5nSWZOb01hcmtlcnMgPSBmYWxzZSAvLyBJZiB0cnVlIGFuZCBtYXJrZXJzIG5vdCBmb3VuZCwgYXBwZW5kcyB1bmRlciBleGlzdGluZyBoZWFkaW5nIGlmIGZvdW5kXG4gICAgKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgaGVhZGluZ1JlZ2V4ID0gbmV3IFJlZ0V4cChgXigjKylcXFxccyoke2hlYWRpbmdUZXh0LnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyl9KFxcXFxzKlxcXFxufCQpYCwgXCJpbVwiKTtcbiAgICAgICAgY29uc3QgaGVhZGluZ01hdGNoID0gY29udGVudC5tYXRjaChoZWFkaW5nUmVnZXgpO1xuICAgICAgICBjb25zdCBzZWN0aW9uV2l0aEhlYWRpbmcgPSBgXFxuIyMgJHtoZWFkaW5nVGV4dH1cXG4ke3NlY3Rpb25OZXdDb250ZW50LnRyaW0oKX1cXG5gO1xuXG4gICAgICAgIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0SWR4ID0gY29udGVudC5pbmRleE9mKHN0YXJ0TWFya2VyKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZElkeCA9IGNvbnRlbnQuaW5kZXhPZihlbmRNYXJrZXIpO1xuXG4gICAgICAgICAgICBpZiAoc3RhcnRJZHggIT09IC0xICYmIGVuZElkeCAhPT0gLTEgJiYgc3RhcnRJZHggPCBlbmRJZHgpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXJrZXJzIGZvdW5kLCByZXBsYWNlIGNvbnRlbnQgYmV0d2VlbiB0aGVtIChleGNsdXNpdmUgb2YgbWFya2VycyB0aGVtc2VsdmVzKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50LnN1YnN0cmluZygwLCBzdGFydElkeCArIHN0YXJ0TWFya2VyLmxlbmd0aCkgK1xuICAgICAgICAgICAgICAgICAgICAgICBgXFxuJHtzZWN0aW9uTmV3Q29udGVudC50cmltKCl9XFxuYCArIC8vIEVuc3VyZSBuZXcgY29udGVudCBpcyBvbiBuZXcgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgY29udGVudC5zdWJzdHJpbmcoZW5kSWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hcmtlcnMgbm90IHVzZWQgb3Igbm90IGZvdW5kLCB0cnkgdG8gZmluZCBoZWFkaW5nXG4gICAgICAgIGlmIChoZWFkaW5nTWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIEhlYWRpbmcgZm91bmRcbiAgICAgICAgICAgIGNvbnN0IGhlYWRpbmdMZXZlbCA9IGhlYWRpbmdNYXRjaFsxXS5sZW5ndGg7IC8vIGUuZy4sIFwiIyNcIiAtPiBsZW5ndGggMlxuICAgICAgICAgICAgY29uc3QgbmV4dEhlYWRpbmdSZWdleCA9IG5ldyBSZWdFeHAoYF4jezEsJHtoZWFkaW5nTGV2ZWx9fVxcXFxzKy4qKFxcXFxzKlxcXFxufCQpYCwgXCJpbVwiKTtcbiAgICAgICAgICAgIGxldCBzdGFydEluZGV4QWZ0ZXJIZWFkaW5nID0gaGVhZGluZ01hdGNoLmluZGV4ISArIGhlYWRpbmdNYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgY29udGVudEFmdGVySGVhZGluZyA9IGNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0SW5kZXhBZnRlckhlYWRpbmcpO1xuICAgICAgICAgICAgbGV0IGVuZEluZGV4ID0gY29udGVudC5sZW5ndGg7IC8vIERlZmF1bHQgdG8gZW5kIG9mIGNvbnRlbnRcblxuICAgICAgICAgICAgLy8gRmluZCB3aGVyZSB0aGUgY3VycmVudCBzZWN0aW9uIGVuZHMgKHN0YXJ0IG9mIG5leHQgaGVhZGluZyBvZiBzYW1lIG9yIGhpZ2hlciBsZXZlbCwgb3IgZW5kIG9mIGRvYylcbiAgICAgICAgICAgIGNvbnN0IG5leHRNYXRjaCA9IGNvbnRlbnRBZnRlckhlYWRpbmcubWF0Y2gobmV4dEhlYWRpbmdSZWdleCk7XG4gICAgICAgICAgICBpZiAobmV4dE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSBzdGFydEluZGV4QWZ0ZXJIZWFkaW5nICsgbmV4dE1hdGNoLmluZGV4ITtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFwcGVuZFVuZGVySGVhZGluZ0lmTm9NYXJrZXJzKSB7XG4gICAgICAgICAgICAgICAgIC8vIEFwcGVuZCBuZXcgY29udGVudCB1bmRlciB0aGUgZXhpc3RpbmcgaGVhZGluZywgYmVmb3JlIHRoZSBuZXh0IG9uZS5cbiAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0cmlja3kgaWYgdGhlIHNlY3Rpb24gYWxyZWFkeSBoYXMgY29udGVudC4gVGhpcyBzaW1wbGUgYXBwZW5kIGFkZHMgdG8gdGhlIGVuZCBvZiB0aGUgc2VjdGlvbi5cbiAgICAgICAgICAgICAgICAgLy8gRm9yIGZ1bGwgcmVwbGFjZW1lbnQsIHRoZSBsb2dpYyBvdXRzaWRlIHRoaXMgYGlmYCBoYW5kbGVzIGl0LlxuICAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudC5zdWJzdHJpbmcoMCwgZW5kSW5kZXgpICsgLy8gQ29udGVudCB1cCB0byB3aGVyZSBuZXh0IHNlY3Rpb24gd291bGQgc3RhcnQgKG9yIGVuZCBvZiBkb2MpXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxuJHtzZWN0aW9uTmV3Q29udGVudC50cmltKCl9XFxuYCArIC8vIEFwcGVuZCBuZXcgc3R1ZmZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuc3Vic3RyaW5nKGVuZEluZGV4KTsgICAgICAvLyBSZXN0IG9mIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBjb250ZW50IGZyb20gYWZ0ZXIgdGhlIGhlYWRpbmdNYXRjaCB0byB3aGVyZSB0aGUgbmV4dCBoZWFkaW5nL2VuZCBvZiBkb2Mgc3RhcnRzXG4gICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50LnN1YnN0cmluZygwLCBzdGFydEluZGV4QWZ0ZXJIZWFkaW5nKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtzZWN0aW9uTmV3Q29udGVudC50cmltKCl9XFxuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LnN1YnN0cmluZyhlbmRJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhlYWRpbmcgbm90IGZvdW5kLCBhcHBlbmQgdGhlIG5ldyBoZWFkaW5nIGFuZCBzZWN0aW9uIHRvIHRoZSBlbmRcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50LnRyaW1FbmQoKSArIFwiXFxuXFxuXCIgKyBzZWN0aW9uV2l0aEhlYWRpbmcudHJpbVN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHByaXZhdGUgZm9ybWF0UmVzdWx0c0Zvck9ic2lkaWFuTG9nKHByb2Nlc3Nvck5hbWU6IHN0cmluZywgcmVsYXRpb25zaGlwczogRXh0cmFjdGVkUmVsYXRpb25zaGlwW10sIHByb2Nlc3NlZFVybHM6IFByb2Nlc3NlZFVybEluZm9bXSwgbWVyZ2VEZWNpc2lvbnM6IHN0cmluZ1tdID0gW10pOiBzdHJpbmcge1xuICAgICAgICBsZXQgbG9nQ29udGVudCA9IGBcXG4tLS1cXG4jIyMgTG9nIEVudHJ5OiAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX0gZm9yICR7cHJvY2Vzc29yTmFtZX1cXG5cXG5gO1xuXG4gICAgICAgIGlmIChtZXJnZURlY2lzaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsb2dDb250ZW50ICs9IGAjIyMjIFByb2FjdGl2ZSBEZWR1cGxpY2F0aW9uIERlY2lzaW9ucyAoJHttZXJnZURlY2lzaW9ucy5sZW5ndGh9KTpcXG5gO1xuICAgICAgICAgICAgbWVyZ2VEZWNpc2lvbnMuZm9yRWFjaChkZWNpc2lvbiA9PiB7XG4gICAgICAgICAgICAgICAgbG9nQ29udGVudCArPSBgLSAke2RlY2lzaW9ufVxcbmA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvZ0NvbnRlbnQgKz0gXCJcXG5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZ0NvbnRlbnQgKz0gYCMjIyMgUHJvY2Vzc2VkIFVSTHMgKCR7cHJvY2Vzc2VkVXJscy5sZW5ndGh9KTpcXG5gO1xuICAgICAgICBpZiAocHJvY2Vzc2VkVXJscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvZ0NvbnRlbnQgKz0gXCItIE5vIFVSTHMgd2VyZSBwcm9jZXNzZWQuXFxuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dDb250ZW50ICs9IFwifCBVUkwgfCBUaXRsZSB8IFR5cGUgfCBWZXJpZmllZCBMaXN0PyB8IEN1cnJlbnQ/IHwgRXh0cmFjdGVkICMgfCBSZWFzb25pbmcgfFxcblwiO1xuICAgICAgICAgICAgbG9nQ29udGVudCArPSBcInwtLS18LS0tfC0tLXwtLS18LS0tfC0tLXwtLS18XFxuXCI7XG4gICAgICAgICAgICBwcm9jZXNzZWRVcmxzLmZvckVhY2godXJsID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aXRsZURpc3BsYXkgPSB0aGlzLnNjcnViSHlwZXJsaW5rcyh1cmwudGl0bGUgfHwgXCJOL0FcIikuc3Vic3RyaW5nKDAsIDcwKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmxMaW5rID0gdXJsLnVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSA/IGBbTGlua10oJHt1cmwudXJsfSlgIDogdXJsLnVybDtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFzb25pbmdEaXNwbGF5ID0gdGhpcy5zY3J1Ykh5cGVybGlua3ModXJsLnZlcmlmaWNhdGlvblJlYXNvbmluZyB8fCBcIk4vQVwiKS5zdWJzdHJpbmcoMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBsb2dDb250ZW50ICs9IGB8ICR7dXJsTGlua30gfCAke3RpdGxlRGlzcGxheX0uLi4gfCAke3VybC5kb2N1bWVudFR5cGUgfHwgJ04vQSd9IHwgJHt1cmwuaXNMaXN0ID8gJ1llcycgOiAnTm8nfSB8ICR7dXJsLmlzQ3VycmVudCA/ICdZZXMnIDogJ05vJ30gfCAke3VybC5leHRyYWN0ZWRTdWJwcm9jZXNzb3JzQ291bnQgfHwgMH0gfCAke3JlYXNvbmluZ0Rpc3BsYXl9Li4uIHxcXG5gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nQ29udGVudCArPSBcIlxcblwiO1xuXG4gICAgICAgIGxvZ0NvbnRlbnQgKz0gYCMjIyMgRXh0cmFjdGVkIFJlbGF0aW9uc2hpcHMgKCR7cmVsYXRpb25zaGlwcy5sZW5ndGh9KTpcXG5gO1xuICAgICAgICBpZiAocmVsYXRpb25zaGlwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvZ0NvbnRlbnQgKz0gXCItIE5vIG5ldyByZWxhdGlvbnNoaXBzIHdlcmUgZXh0cmFjdGVkIGluIHRoaXMgcnVuLlxcblwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nQ29udGVudCArPSBcInwgUHJpbWFyeSBQcm9jZXNzb3IgfCBUYXJnZXQgRW50aXR5IHwgVHlwZSB8IEZ1bmN0aW9uIHwgTG9jYXRpb24gfCBTb3VyY2UgVVJMIHxcXG5cIjtcbiAgICAgICAgICAgIGxvZ0NvbnRlbnQgKz0gXCJ8LS0tfC0tLXwtLS18LS0tfC0tLXwtLS18XFxuXCI7XG4gICAgICAgICAgICByZWxhdGlvbnNoaXBzLmZvckVhY2gocmVsID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRFbnRpdHlEaXNwbGF5ID0gdGhpcy5zY3J1Ykh5cGVybGlua3MocmVsLlN1YnByb2Nlc3Nvck5hbWUpLnN1YnN0cmluZygwLCA1MCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpbWFyeVByb2NEaXNwbGF5ID0gdGhpcy5zY3J1Ykh5cGVybGlua3MocmVsLlByaW1hcnlQcm9jZXNzb3IpLnN1YnN0cmluZygwLCA1MCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuY0Rpc3BsYXkgPSB0aGlzLnNjcnViSHlwZXJsaW5rcyhyZWwuUHJvY2Vzc2luZ0Z1bmN0aW9uKS5zdWJzdHJpbmcoMCwgNzApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY0Rpc3BsYXkgPSB0aGlzLnNjcnViSHlwZXJsaW5rcyhyZWwuTG9jYXRpb24pLnN1YnN0cmluZygwLCA1MCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlVXJsTGluayA9IHJlbC5Tb3VyY2VVUkwuc3RhcnRzV2l0aChcImh0dHBcIikgPyBgW1NvdXJjZV0oJHtyZWwuU291cmNlVVJMfSlgIDogcmVsLlNvdXJjZVVSTDtcblxuICAgICAgICAgICAgICAgIGxvZ0NvbnRlbnQgKz0gYHwgJHtwcmltYXJ5UHJvY0Rpc3BsYXl9IHwgJHt0YXJnZXRFbnRpdHlEaXNwbGF5fSB8ICR7cmVsLlJlbGF0aW9uc2hpcFR5cGV9IHwgJHtmdW5jRGlzcGxheX0uLi4gfCAke2xvY0Rpc3BsYXl9Li4uIHwgJHtzb3VyY2VVcmxMaW5rfSB8XFxuYDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ0NvbnRlbnQgKz0gXCJcXG5cIjtcbiAgICAgICAgcmV0dXJuIGxvZ0NvbnRlbnQ7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGFzeW5jIHdyaXRlUmVzdWx0c1RvT2JzaWRpYW5Ob3RlKFxuICAgICAgICBmaWxlUGF0aDogc3RyaW5nLCAvLyBGdWxsIHBhdGggZnJvbSB2YXVsdCByb290LCBlLmcuLCBcIkFuYWx5c2lzIExvZ3MvT3BlbkFJIExvZ3MubWRcIlxuICAgICAgICBjb250ZW50VG9BcHBlbmRPckluaXRpYWw6IHN0cmluZyxcbiAgICAgICAgbW9kZTogJ292ZXJ3cml0ZScgfCAnYXBwZW5kJyB8ICdlbnN1cmVfZXhpc3RzX2FuZF9hcHBlbmQnID0gJ2Vuc3VyZV9leGlzdHNfYW5kX2FwcGVuZCcsXG4gICAgICAgIHByb2Nlc3Nvck5hbWVGb3JMb2dUaXRsZT86IHN0cmluZyAvLyBVc2VkIGlmIGNyZWF0aW5nIHRoZSBmaWxlXG4gICAgKSB7XG4gICAgICAgIGxldCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZpbGVQYXRoKSBhcyBURmlsZTtcblxuICAgICAgICBpZiAoIWZpbGUgJiYgKG1vZGUgPT09ICdlbnN1cmVfZXhpc3RzX2FuZF9hcHBlbmQnIHx8IG1vZGUgPT09ICdvdmVyd3JpdGUnKSkge1xuICAgICAgICAgICAgLy8gRmlsZSBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgaXRcbiAgICAgICAgICAgIGxldCBpbml0aWFsQ29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAocHJvY2Vzc29yTmFtZUZvckxvZ1RpdGxlKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRlbnQgKz0gYCMgQW5hbHlzaXMgTG9nOiAke3Byb2Nlc3Nvck5hbWVGb3JMb2dUaXRsZX1cXG5cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5pdGlhbENvbnRlbnQgKz0gY29udGVudFRvQXBwZW5kT3JJbml0aWFsOyAvLyBBZGQgdGhlIGN1cnJlbnQgbG9nIGVudHJ5XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZpbGUgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoZmlsZVBhdGgsIGluaXRpYWxDb250ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBMb2cgZmlsZSBjcmVhdGVkOiAke2ZpbGVQYXRofWApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICAgICAgIGlmIChlLm1lc3NhZ2U/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJmaWxlIGFscmVhZHkgZXhpc3RzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZVBhdGgpIGFzIFRGaWxlO1xuICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlKSB7IGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBnZXQgbG9nIGZpbGUgJHtmaWxlUGF0aH0gYWZ0ZXIgJ2FscmVhZHkgZXhpc3RzJyBlcnJvci5gKTsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgICAgICAgLy8gTm93IHRoYXQgZmlsZSBleGlzdHMsIHByb2NlZWQgdG8gYXBwZW5kL3Byb2Nlc3MgaWYgbW9kZSBpcyBlbnN1cmVfZXhpc3RzX2FuZF9hcHBlbmRcbiAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY3JlYXRpbmcgbG9nIGZpbGUgJHtmaWxlUGF0aH06YCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYEVycm9yIGNyZWF0aW5nIGxvZyBmaWxlOiAke2ZpbGVQYXRofWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFN0b3AgaWYgY3JlYXRpb24gZmFpbHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgaWYgKGZpbGUgJiYgbW9kZSA9PT0gJ2Vuc3VyZV9leGlzdHNfYW5kX2FwcGVuZCcpIHsgLyogRmlsZSBjcmVhdGVkIHdpdGggY29udGVudCwgbm8gZnVydGhlciBhY3Rpb24gZm9yIHRoaXMgY2FsbCAqLyByZXR1cm47IH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gSWYgZmlsZSBleGlzdHMgKG9yIHdhcyBqdXN0IGNyZWF0ZWQgYW5kIG1vZGUgaXMgbm90ICdlbnN1cmVfZXhpc3RzX2FuZF9hcHBlbmQnIHdoZXJlIGNvbnRlbnQgd2FzIGluaXRpYWwpXG4gICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ292ZXJ3cml0ZScpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3Nvck5hbWVGb3JMb2dUaXRsZSkgeyAvLyBLZWVwIHRoZSB0aXRsZSBpZiBvdmVyd3JpdGluZ1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZW50ICs9IGAjIEFuYWx5c2lzIExvZzogJHtwcm9jZXNzb3JOYW1lRm9yTG9nVGl0bGV9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3Q29udGVudCArPSBjb250ZW50VG9BcHBlbmRPckluaXRpYWw7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGZpbGUsIG5ld0NvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coYExvZyBmaWxlIG92ZXJ3cml0dGVuOiAke2ZpbGVQYXRofWApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnYXBwZW5kJyB8fCAobW9kZSA9PT0gJ2Vuc3VyZV9leGlzdHNfYW5kX2FwcGVuZCcgJiYgZmlsZSkpIHsgLy8gQXBwZW5kIGlmIG1vZGUgaXMgYXBwZW5kIG9yIChlbnN1cmVfZXhpc3RzX2FuZF9hcHBlbmQgYW5kIGZpbGUgYWxyZWFkeSBleGlzdGVkKVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFwcGVuZChmaWxlLCBjb250ZW50VG9BcHBlbmRPckluaXRpYWwpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coYENvbnRlbnQgYXBwZW5kZWQgdG8gbG9nIGZpbGU6ICR7ZmlsZVBhdGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2FwcGVuZCcpIHtcbiAgICAgICAgICAgIC8vIEZpbGUgZG9lc24ndCBleGlzdCBhbmQgbW9kZSBpcyAnYXBwZW5kJyAoc3RyaWN0IGFwcGVuZCwgbm90IGNyZWF0ZSlcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYExvZyBmaWxlICR7ZmlsZVBhdGh9IG5vdCBmb3VuZC4gQ2Fubm90IGFwcGVuZC5gKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coYExvZyBmaWxlIG5vdCBmb3VuZCBmb3IgYXBwZW5kOiAke2ZpbGVQYXRofWApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBhc3luYyBnZXRSaWdodEJyYWluQWNjZXNzVG9rZW4oY3JlZHM/OiB7IGNsaWVudElkOiBzdHJpbmcsIGNsaWVudFNlY3JldDogc3RyaW5nLCBvYXV0aFVybDogc3RyaW5nIH0pOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICAgICAgLy8gVXNlIHRoZSBwYXNzZWQtaW4gY3JlZGVudGlhbHMgaWYgdGhleSBleGlzdCwgb3RoZXJ3aXNlIHVzZSB0aGUgc2F2ZWQgc2V0dGluZ3MuXG4gICAgICAgIGNvbnN0IGNsaWVudElkID0gY3JlZHM/LmNsaWVudElkIHx8IHRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkNsaWVudElkO1xuICAgICAgICBjb25zdCBjbGllbnRTZWNyZXQgPSBjcmVkcz8uY2xpZW50U2VjcmV0IHx8IHRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkNsaWVudFNlY3JldDtcbiAgICAgICAgY29uc3Qgb2F1dGhVcmwgPSBjcmVkcz8ub2F1dGhVcmwgfHwgdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluT2F1dGgyVXJsO1xuXG4gICAgICAgIGlmICghY2xpZW50SWQgfHwgIWNsaWVudFNlY3JldCkge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIlJpZ2h0QnJhaW4gQ2xpZW50IElEIG9yIFNlY3JldCBub3QgY29uZmlndXJlZC5cIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciB0aGUgY2FjaGVkIHRva2VuIGZpcnN0XG4gICAgICAgIGlmICgodGhpcyBhcyBhbnkpLl9yYlRva2VuICYmICh0aGlzIGFzIGFueSkuX3JiVG9rZW5FeHBpcnkgPiBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKFwiVXNpbmcgY2FjaGVkIFJpZ2h0QnJhaW4gdG9rZW4uXCIpO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzIGFzIGFueSkuX3JiVG9rZW47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b2tlblVybCA9IGAke29hdXRoVXJsfS9vYXV0aDIvdG9rZW5gO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgYm9keVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgYm9keVBhcmFtcy5hcHBlbmQoJ2dyYW50X3R5cGUnLCAnY2xpZW50X2NyZWRlbnRpYWxzJyk7XG5cbiAgICAgICAgY29uc3QgY3JlZGVudGlhbHMgPSBgJHtjbGllbnRJZH06JHtjbGllbnRTZWNyZXR9YDtcbiAgICAgICAgY29uc3QgZW5jb2RlZENyZWRlbnRpYWxzID0gYnRvYShjcmVkZW50aWFscyk7IFxuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCYXNpYyAke2VuY29kZWRDcmVkZW50aWFsc31gLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBgT2JzaWRpYW5Qcm9jZXNzb3JQcm9jZXNzb3JQbHVnaW4vJHt0aGlzLm1hbmlmZXN0LnZlcnNpb259YFxuICAgICAgICB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKFwiUmVxdWVzdGluZyBuZXcgUmlnaHRCcmFpbiB0b2tlbi5cIik7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgICAgICAgICAgICAgIHVybDogdG9rZW5VcmwsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5UGFyYW1zLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgdGhyb3c6IGZhbHNlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwICYmIHJlc3BvbnNlLmpzb24gJiYgcmVzcG9uc2UuanNvbi5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKFwiU3VjY2Vzc2Z1bGx5IG9idGFpbmVkIG5ldyBSaWdodEJyYWluIHRva2VuLlwiKTtcbiAgICAgICAgICAgICAgICAodGhpcyBhcyBhbnkpLl9yYlRva2VuID0gcmVzcG9uc2UuanNvbi5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICAgICAgKHRoaXMgYXMgYW55KS5fcmJUb2tlbkV4cGlyeSA9IERhdGUubm93KCkgKyAocmVzcG9uc2UuanNvbi5leHBpcmVzX2luIHx8IDM2MDApICogMTAwMCAtIDYwMDAwMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbi5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQcm9jZXNzb3JQcm9jZXNzb3I6IEZhaWxlZCB0byBnZXQgUmlnaHRCcmFpbiB0b2tlbi5cIiwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS50ZXh0KTtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBGYWlsZWQgdG8gZ2V0IFJpZ2h0QnJhaW4gdG9rZW46ICR7cmVzcG9uc2Uuc3RhdHVzfS5gKTtcbiAgICAgICAgICAgICAgICAodGhpcyBhcyBhbnkpLl9yYlRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICAodGhpcyBhcyBhbnkpLl9yYlRva2VuRXhwaXJ5ID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQcm9jZXNzb3JQcm9jZXNzb3I6IE5ldHdvcmsgZXJyb3IgZmV0Y2hpbmcgUmlnaHRCcmFpbiB0b2tlbjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIk5ldHdvcmsgZXJyb3IgZmV0Y2hpbmcgUmlnaHRCcmFpbiB0b2tlbi5cIik7XG4gICAgICAgICAgICAodGhpcyBhcyBhbnkpLl9yYlRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICh0aGlzIGFzIGFueSkuX3JiVG9rZW5FeHBpcnkgPSAwO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHByaXZhdGUgZ2VuZXJhdGVTZWFyY2hRdWVyaWVzKHByb2Nlc3Nvck5hbWU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICAgICAgLy8gU2FuaXRpemUgcHJvY2Vzc29yTmFtZSBmb3IgdXNlIGluIHF1ZXJpZXMgKGUuZy4sIHJlbW92ZSBcIkluYy5cIiwgXCJMTENcIilcbiAgICAgICAgY29uc3QgY2xlYW5lZE5hbWUgPSBwcm9jZXNzb3JOYW1lXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxiKD86aW5jXFwuP3xsbGNcXC4/fGx0ZFxcLj98Y29ycFxcLj98Z21iaFxcLj98aW5jb3Jwb3JhdGVkfGxpbWl0ZWR8Y29ycG9yYXRpb24pXFxiL2dpLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bLC5dL2csICcnKSAvLyBSZW1vdmUgY29tbWFzIGFuZCBwZXJpb2RzIHRoYXQgbWlnaHQgYnJlYWsgc2VhcmNoXG4gICAgICAgICAgICAudHJpbSgpO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBgXCIke2NsZWFuZWROYW1lfVwiIHN1Yi1wcm9jZXNzb3IgbGlzdGAsXG4gICAgICAgICAgICBgXCIke2NsZWFuZWROYW1lfVwiIHN1YnByb2Nlc3NvcnNgLFxuICAgICAgICAgICAgYFwiJHtjbGVhbmVkTmFtZX1cIiBkYXRhIHByb2Nlc3NpbmcgYWRkZW5kdW0gZXhoaWJpdGAsXG4gICAgICAgICAgICBgXCIke2NsZWFuZWROYW1lfVwiIERQQSBzdWJwcm9jZXNzb3JzYCxcbiAgICAgICAgICAgIGBcIiR7Y2xlYW5lZE5hbWV9XCIgdGhpcmQtcGFydHkgdmVuZG9yc2AsXG4gICAgICAgICAgICBgXCIke2NsZWFuZWROYW1lfVwiIHNlcnZpY2UgcHJvdmlkZXJzIGxpc3RgLFxuICAgICAgICAgICAgLy8gTW9yZSBnZW5lcmljIGJ1dCBzb21ldGltZXMgdXNlZnVsIGZvciBmaW5kaW5nIHBvcnRhbHNcbiAgICAgICAgICAgIGBcIiR7Y2xlYW5lZE5hbWV9XCIgdHJ1c3QgY2VudGVyIHN1YnByb2Nlc3NvcnNgLFxuICAgICAgICAgICAgYFwiJHtjbGVhbmVkTmFtZX1cIiBsZWdhbCBzdWJwcm9jZXNzb3JzYCxcbiAgICAgICAgICAgIC8vIElmIHRoZSBuYW1lIGlzIHNob3J0LCBicm9hZCBzZWFyY2hlcyBtaWdodCBiZSB0b28gbm9pc3kuXG4gICAgICAgICAgICAvLyBDb25zaWRlciBhZGRpbmcgcXVvdGVzIGFyb3VuZCBjbGVhbmVkTmFtZSBpZiBpdCBjb250YWlucyBzcGFjZXMuXG4gICAgICAgIF07XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGFzeW5jIHNlYXJjaFNlcnBBcGlGb3JEcGFzKHByb2Nlc3Nvck5hbWU6IHN0cmluZywgcXVlcmllczogc3RyaW5nW10sIG1heFJlc3VsdHNTZXR0aW5nOiBudW1iZXIpOiBQcm9taXNlPFNlcnBBcGlSZXN1bHRbXT4ge1xuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3Muc2VycEFwaUtleSkge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIlNlcnBBUEkga2V5IG5vdCBzZXQuIENhbm5vdCBwZXJmb3JtIFNlcnBBUEkgc2VhcmNoLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFsbFJlc3VsdHM6IFNlcnBBcGlSZXN1bHRbXSA9IFtdO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRVcmxzID0gbmV3IFNldDxzdHJpbmc+KCk7IC8vIFRvIGF2b2lkIGR1cGxpY2F0ZSBVUkxzIGZyb20gZGlmZmVyZW50IHF1ZXJpZXNcblxuICAgICAgICAvLyBVc2UgYSBzbWFsbGVyIG51bWJlciBvZiBxdWVyaWVzIGZvciBTZXJwQVBJIHRvIG1hbmFnZSBjb3N0L3JhdGUgbGltaXRzXG4gICAgICAgIGNvbnN0IHF1ZXJpZXNUb1J1biA9IHF1ZXJpZXMuc2xpY2UoMCwgTWF0aC5taW4ocXVlcmllcy5sZW5ndGgsIDMpKTsgLy8gZS5nLiwgcnVuIGZpcnN0IDMgcXVlcmllc1xuXG4gICAgICAgIG5ldyBOb3RpY2UoYFNlYXJjaGluZyBTZXJwQVBJIGZvciAke3Byb2Nlc3Nvck5hbWV9IHVzaW5nICR7cXVlcmllc1RvUnVuLmxlbmd0aH0gcXVlcmllcy4uLmAsIDMwMDApO1xuXG4gICAgICAgIGZvciAoY29uc3QgcXVlcnkgb2YgcXVlcmllc1RvUnVuKSB7XG4gICAgICAgICAgICBpZiAoYWxsUmVzdWx0cy5sZW5ndGggPj0gbWF4UmVzdWx0c1NldHRpbmcgJiYgbWF4UmVzdWx0c1NldHRpbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgTWF4IHJlc3VsdHMgKCR7bWF4UmVzdWx0c1NldHRpbmd9KSByZWFjaGVkIGZvciAke3Byb2Nlc3Nvck5hbWV9LCBzdG9wcGluZyBTZXJwQVBJIHNlYXJjaC5gKTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gU3RvcCBpZiB3ZSd2ZSBoaXQgdGhlIG92ZXJhbGwgbWF4IHJlc3VsdHMgZGVzaXJlZCAodGhvdWdoIGxvZ2ljIGlzIDEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgICAgIGFwaV9rZXk6IHRoaXMuc2V0dGluZ3Muc2VycEFwaUtleSxcbiAgICAgICAgICAgICAgICBxOiBxdWVyeSxcbiAgICAgICAgICAgICAgICBlbmdpbmU6IFwiZ29vZ2xlXCIsIC8vIE9yIG90aGVyIGVuZ2luZXMgbGlrZSAnYmluZydcbiAgICAgICAgICAgICAgICBudW06IFwiMTBcIiwgLy8gTnVtYmVyIG9mIHJlc3VsdHMgcGVyIHF1ZXJ5IChtYXggMTAwIGZvciBHb29nbGUsIHVzdWFsbHkgMTAtMjAgaXMgZmluZSlcbiAgICAgICAgICAgICAgICAvLyBZb3UgY2FuIGFkZCBvdGhlciBwYXJhbXMgbGlrZSAnbG9jYXRpb24nLCAnZ2wnIChjb3VudHJ5KSwgJ2hsJyAobGFuZ3VhZ2UpIGlmIG5lZWRlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzZXJwQXBpVXJsID0gYGh0dHBzOi8vc2VycGFwaS5jb20vc2VhcmNoPyR7cGFyYW1zLnRvU3RyaW5nKCl9YDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoeyB1cmw6IHNlcnBBcGlVcmwsIG1ldGhvZDogJ0dFVCcsIHRocm93OiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgJiYgcmVzcG9uc2UuanNvbiAmJiByZXNwb25zZS5qc29uLm9yZ2FuaWNfcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmdhbmljUmVzdWx0cyA9IHJlc3BvbnNlLmpzb24ub3JnYW5pY19yZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiBvcmdhbmljUmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5saW5rICYmICFwcm9jZXNzZWRVcmxzLmhhcyhyZXN1bHQubGluaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxMb3dlciA9IHJlc3VsdC5saW5rLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGl0bGVMb3dlciA9IHJlc3VsdC50aXRsZT8udG9Mb3dlckNhc2UoKSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNuaXBwZXRMb3dlciA9IHJlc3VsdC5zbmlwcGV0Py50b0xvd2VyQ2FzZSgpIHx8IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXNpYyBrZXl3b3JkIGNoZWNrIGluIFVSTCwgdGl0bGUsIG9yIHNuaXBwZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1JlbGV2YW50ID0gU1VCUFJPQ0VTU09SX1VSTF9LRVlXT1JEUy5zb21lKGtleXdvcmQgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsTG93ZXIuaW5jbHVkZXMoa2V5d29yZCkgfHwgdGl0bGVMb3dlci5pbmNsdWRlcyhrZXl3b3JkKSB8fCBzbmlwcGV0TG93ZXIuaW5jbHVkZXMoa2V5d29yZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVsZXZhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsUmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Nvck5hbWU6IHByb2Nlc3Nvck5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogcmVzdWx0LnRpdGxlIHx8IFwiTm8gVGl0bGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogcmVzdWx0LmxpbmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbmlwcGV0OiByZXN1bHQuc25pcHBldCB8fCBcIk5vIFNuaXBwZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50VHlwZTogJ3NlcnBhcGlfZHBhX29yX3N1YnByb2Nlc3Nvcl9saXN0X2NhbmRpZGF0ZScgLy8gTWFyayBhcyBwb3RlbnRpYWwgY2FuZGlkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRVcmxzLmFkZChyZXN1bHQubGluayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxSZXN1bHRzLmxlbmd0aCA+PSBtYXhSZXN1bHRzU2V0dGluZyAmJiBtYXhSZXN1bHRzU2V0dGluZyA+IDApIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFNlcnBBUEkgZXJyb3IgZm9yIHF1ZXJ5IFwiJHtxdWVyeX1cIjogJHtyZXNwb25zZS5zdGF0dXN9YCwgcmVzcG9uc2UudGV4dD8uc3Vic3RyaW5nKDAsIDIwMCkpO1xuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBTZXJwQVBJIHF1ZXJ5IGZhaWxlZCBmb3IgXCIke3F1ZXJ5LnN1YnN0cmluZygwLDIwKX0uLi5cIi4gU3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYE5ldHdvcmsgZXJyb3IgZHVyaW5nIFNlcnBBUEkgc2VhcmNoIGZvciBxdWVyeSBcIiR7cXVlcnl9XCI6YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYE5ldHdvcmsgZXJyb3IgZHVyaW5nIFNlcnBBUEkgc2VhcmNoIGZvciBcIiR7cXVlcnkuc3Vic3RyaW5nKDAsMjApfS4uLlwiLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCArIE1hdGgucmFuZG9tKCkgKiAzMDApKTsgLy8gRGVsYXkgYmV0d2VlbiBBUEkgY2FsbHNcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBTZXJwQVBJIHNlYXJjaCBmb3IgJHtwcm9jZXNzb3JOYW1lfSBmb3VuZCAke2FsbFJlc3VsdHMubGVuZ3RofSByZWxldmFudCBjYW5kaWRhdGVzLmApO1xuICAgICAgICByZXR1cm4gYWxsUmVzdWx0cztcbiAgICB9XG5cblxuICAgIHByaXZhdGUgZ2V0Q29tcGFueURvbWFpbihwcm9jZXNzb3JOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICAvLyBCYXNpYyBkb21haW4gZXh0cmFjdGlvbiAtIHRoaXMgaXMgbmFpdmUgYW5kIGNhbiBiZSBpbXByb3ZlZC5cbiAgICAgICAgLy8gSXQgYXNzdW1lcyBwcm9jZXNzb3JOYW1lIG1pZ2h0IGJlIGxpa2UgXCJDb21wYW55IE5hbWUgSW5jLlwiIG9yIFwiY29tcGFueS5jb21cIlxuICAgICAgICBsZXQgbmFtZSA9IHByb2Nlc3Nvck5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXFxiKD86aW5jXFwuP3xsbGNcXC4/fGx0ZFxcLj98Y29ycFxcLj98Z21iaFxcLj8pXFxiL2csICcnKS50cmltKCk7IC8vIFJlbW92ZSBjb21tb24gc3VmZml4ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvWywuXS9nLCAnJyk7IC8vIFJlbW92ZSBjb21tYXMsIHBlcmlvZHNcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSWYgaXQgbG9va3MgbGlrZSBhIFVSTCBhbHJlYWR5XG4gICAgICAgICAgICBpZiAobmFtZS5pbmNsdWRlcygnLicpICYmICFuYW1lLmluY2x1ZGVzKCcgJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKG5hbWUuc3RhcnRzV2l0aCgnaHR0cCcpID8gbmFtZSA6IGBodHRwOi8vJHtuYW1lfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmwuaG9zdG5hbWUucmVwbGFjZSgvXnd3d1xcLi8sICcnKTsgLy8gUmVtb3ZlIHd3dy5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkgeyAvKiBOb3QgYSB2YWxpZCBVUkwsIHByb2NlZWQgKi8gfVxuXG4gICAgICAgIC8vIElmIGl0J3MgYSBtdWx0aS13b3JkIG5hbWUsIHRyeSB0byBmb3JtIGEgZG9tYWluIChlLmcuLCBcIkNvbXBhbnkgTmFtZVwiIC0+IFwiY29tcGFueW5hbWUuY29tXCIpXG4gICAgICAgIC8vIFRoaXMgaXMgaGlnaGx5IHNwZWN1bGF0aXZlIGFuZCBvZnRlbiB3cm9uZy5cbiAgICAgICAgLy8gQSBiZXR0ZXIgYXBwcm9hY2ggaXMgdG8gbG9vayBmb3Igb2ZmaWNpYWwgd2Vic2l0ZSBpbiBzZWFyY2ggcmVzdWx0cy5cbiAgICAgICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gcGFydHMuam9pbignJykudG9Mb3dlckNhc2UoKSArIFwiLmNvbVwiOyAvLyBWZXJ5IG5haXZlXG4gICAgICAgICAgICByZXR1cm4gXCJcIjsgLy8gQmV0dGVyIHRvIG5vdCBndWVzcyBpZiB1bnN1cmVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTsgLy8gSWYgc2luZ2xlIHdvcmQsIGFzc3VtZSBpdCBtaWdodCBiZSBwYXJ0IG9mIGEgZG9tYWluXG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGlzVmFsaWRVcmwodXJsOiBzdHJpbmcsIHByb2Nlc3Nvck5hbWVDb250ZXh0OiBzdHJpbmcgPSBcIlwiKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghdXJsIHx8IHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgICAgICAgICAvLyBBbGxvdyBodHRwIGFuZCBodHRwcyBwcm90b2NvbHNcbiAgICAgICAgICAgIGlmICghWydodHRwOicsICdodHRwczonXS5pbmNsdWRlcyhwYXJzZWRVcmwucHJvdG9jb2wpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3B0aW9uYWw6IGNoZWNrIGlmIGRvbWFpbiBzZWVtcyByZWxhdGVkIHRvIHByb2Nlc3Nvck5hbWVDb250ZXh0IGlmIHByb3ZpZGVkXG4gICAgICAgICAgICBpZiAocHJvY2Vzc29yTmFtZUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzb3JEb21haW4gPSB0aGlzLmdldENvbXBhbnlEb21haW4ocHJvY2Vzc29yTmFtZUNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzb3JEb21haW4gJiYgIXBhcnNlZFVybC5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHByb2Nlc3NvckRvbWFpbi5yZXBsYWNlKC9ed3d3XFwuLywgJycpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc29mdCBjaGVjaywgbWlnaHQgYmUgdG9vIHJlc3RyaWN0aXZlLlxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBVUkwgJHt1cmx9IGhvc3RuYW1lICR7cGFyc2VkVXJsLmhvc3RuYW1lfSBkb2Vzbid0IG1hdGNoIGNvbnRleHQgJHtwcm9jZXNzb3JEb21haW59YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gSW52YWxpZCBVUkwgZm9ybWF0XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHByaXZhdGUgYXN5bmMgZXh0cmFjdFVybHNGcm9tRHBhUGFnZShwYWdlVXJsOiBzdHJpbmcsIHByb2Nlc3Nvck5hbWVDb250ZXh0OiBzdHJpbmcsIHNvdXJjZVBhZ2VUaXRsZT86IHN0cmluZyk6IFByb21pc2U8U2VycEFwaVJlc3VsdFtdPiB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluVmVyaWZ5VXJsVGFza0lkKSB7IC8vIFVzaW5nIHZlcmlmeSB0YXNrIElEIGFzIGEgcHJveHkgZm9yIFwiUkIgaXMgY29uZmlndXJlZFwiXG4gICAgICAgICAgICAvLyBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKFwiUkIgbm90IGNvbmZpZ3VyZWQsIHNraXBwaW5nIFVSTCBleHRyYWN0aW9uIGZyb20gRFBBIHBhZ2UgY29udGVudC5cIik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmJUb2tlbiA9IGF3YWl0IHRoaXMuZ2V0UmlnaHRCcmFpbkFjY2Vzc1Rva2VuKCk7XG4gICAgICAgIGlmICghcmJUb2tlbikgcmV0dXJuIFtdO1xuXG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZExpbmtzOiBTZXJwQXBpUmVzdWx0W10gPSBbXTtcblxuICAgICAgICAvLyBUaGlzIHdvdWxkIGlkZWFsbHkgdXNlIGEgUmlnaHRCcmFpbiB0YXNrIGRlc2lnbmVkIHRvIGZldGNoIGEgcGFnZSBhbmQgZXh0cmFjdCBhbGwgPGE+IGhyZWZzLlxuICAgICAgICAvLyBGb3Igbm93LCBsZXQncyBzaW11bGF0ZSBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB3aGF0IHN1Y2ggYSB0YXNrIG1pZ2h0IHJldHVybiBpZiB3ZSBwYXNzIHBhZ2VVcmwuXG4gICAgICAgIC8vIEEgcHJvcGVyIFJCIHRhc2sgd291bGQgdGFrZSBgcGFnZVVybGAgYXMgaW5wdXQgdG8gYSBgdXJsX2ZldGNoZXJgIGFuZCB0aGVuIHBhcnNlIGl0cyBIVE1MIG91dHB1dC5cblxuICAgICAgICAvLyBTaW11bGF0ZSBmZXRjaGluZyBwYWdlIGNvbnRlbnQgKHZlcnkgYmFzaWMsIG5vdCByb2J1c3QpXG4gICAgICAgIGxldCBwYWdlQ29udGVudCA9IFwiXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoe3VybDogcGFnZVVybCwgbWV0aG9kOiAnR0VUJywgdGhyb3c6IGZhbHNlfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICBwYWdlQ29udGVudCA9IHJlc3BvbnNlLnRleHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gZmV0Y2ggJHtwYWdlVXJsfSBmb3IgbGluayBleHRyYWN0aW9uLCBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyAke3BhZ2VVcmx9IGZvciBsaW5rIGV4dHJhY3Rpb246YCwgZSk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhZ2VDb250ZW50KSByZXR1cm4gW107XG5cbiAgICAgICAgLy8gU2ltcGxlIHJlZ2V4IHRvIGZpbmQgaHJlZiBhdHRyaWJ1dGVzIGluIDxhPiB0YWdzXG4gICAgICAgIGNvbnN0IGxpbmtSZWdleCA9IC88YVxccysoPzpbXj5dKj9cXHMrKT9ocmVmPVwiKFteXCJdKilcIi9naTtcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gbGlua1JlZ2V4LmV4ZWMocGFnZUNvbnRlbnQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGhyZWYgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICBpZiAoaHJlZiAmJiAhaHJlZi5zdGFydHNXaXRoKCcjJykgJiYgIWhyZWYuc3RhcnRzV2l0aCgnbWFpbHRvOicpICYmICFocmVmLnN0YXJ0c1dpdGgoJ2phdmFzY3JpcHQ6JykpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhYnNvbHV0ZVVybCA9IG5ldyBVUkwoaHJlZiwgcGFnZVVybCkudG9TdHJpbmcoKTsgLy8gUmVzb2x2ZSByZWxhdGl2ZSBVUkxzXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWRVcmwoYWJzb2x1dGVVcmwsIHByb2Nlc3Nvck5hbWVDb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBsaW5rIGl0c2VsZiBsb29rcyBsaWtlIGEgc3VicHJvY2Vzc29yIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybExvd2VyID0gYWJzb2x1dGVVcmwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aXRsZU9yVGV4dExvd2VyID0gKG1hdGNoWzBdLm1hdGNoKC8+KC4qPyk8Lyk/LlsxXSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpOyAvLyBHZXQgbGluayB0ZXh0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUG90ZW50aWFsU3VicHJvY2Vzc29yTGlzdCA9IFNVQlBST0NFU1NPUl9VUkxfS0VZV09SRFMuc29tZShrZXl3b3JkID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsTG93ZXIuaW5jbHVkZXMoa2V5d29yZCkgfHwgdGl0bGVPclRleHRMb3dlci5pbmNsdWRlcyhrZXl3b3JkKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUG90ZW50aWFsU3VicHJvY2Vzc29yTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RlZExpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzb3JOYW1lOiBwcm9jZXNzb3JOYW1lQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGBMaW5rZWQgZnJvbTogJHtzb3VyY2VQYWdlVGl0bGUgfHwgcGFnZVVybH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGFic29sdXRlVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbmlwcGV0OiBgRm91bmQgb24gcGFnZTogJHtwYWdlVXJsfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50VHlwZTogJ2xpbmtlZF9zdWJwcm9jZXNzb3JfbGlzdF9jYW5kaWRhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VEcGFVcmw6IHBhZ2VVcmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSW52YWxpZCBVUkwsIHNraXAgKi8gfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZyAmJiBleHRyYWN0ZWRMaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhgRXh0cmFjdGVkICR7ZXh0cmFjdGVkTGlua3MubGVuZ3RofSBwb3RlbnRpYWwgc3VicHJvY2Vzc29yIGxpc3QgVVJMcyBmcm9tICR7cGFnZVVybH1gKTtcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gZXh0cmFjdGVkTGlua3M7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGFzeW5jIGNhbGxSaWdodEJyYWluVGFzayh0YXNrSWQ6IHN0cmluZywgdGFza1ZhcmlhYmxlczogUmVjb3JkPHN0cmluZywgYW55PiwgcmJUb2tlbjogc3RyaW5nKTogUHJvbWlzZTxhbnkgfCBudWxsPiB7XG4gICAgICAgIGlmICghdGFza0lkKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiUmlnaHRCcmFpbiBUYXNrIElEIGlzIG1pc3NpbmcgZm9yIHRoZSBjYWxsLlwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQcm9jZXNzb3JQcm9jZXNzb3I6IEF0dGVtcHRlZCB0byBjYWxsIFJpZ2h0QnJhaW4gdGFzayB3aXRoIG5vIFRhc2sgSUQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5PcmdJZCB8fCAhdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluUHJvamVjdElkKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiUmlnaHRCcmFpbiBPcmcgSUQgb3IgUHJvamVjdCBJRCBub3Qgc2V0LiBDYW5ub3QgY2FsbCB0YXNrLlwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQcm9jZXNzb3JQcm9jZXNzb3I6IFJCIE9yZ0lEIG9yIFByb2plY3RJRCBtaXNzaW5nIGZvciB0YXNrIGNhbGwuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgY29uc3QgdGFza1J1blVybCA9IGAke3RoaXMuc2V0dGluZ3MucmlnaHRicmFpbkFwaVVybH0vb3JnLyR7dGhpcy5zZXR0aW5ncy5yaWdodGJyYWluT3JnSWR9L3Byb2plY3QvJHt0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5Qcm9qZWN0SWR9L3Rhc2svJHt0YXNrSWR9L3J1bmA7ICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7cmJUb2tlbn1gLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdVc2VyLUFnZW50JzogYE9ic2lkaWFuUHJvY2Vzc29yUHJvY2Vzc29yUGx1Z2luLyR7dGhpcy5tYW5pZmVzdC52ZXJzaW9ufWBcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgLy8gLS0tIFRISVMgSVMgVEhFIE5FVyBMT0dJQyAtLS1cbiAgICAgICAgLy8gQXV0b21hdGljYWxseSB3cmFwIHRoZSBwcm92aWRlZCB2YXJpYWJsZXMgaW4gdGhlIHJlcXVpcmVkICd0YXNrX2lucHV0JyBvYmplY3QuXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICB0YXNrX2lucHV0OiB0YXNrVmFyaWFibGVzXG4gICAgICAgIH07XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0YXNrUnVuVXJsLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksIC8vIFNlbmQgdGhlIG5ld2x5IGNvbnN0cnVjdGVkIHBheWxvYWRcbiAgICAgICAgICAgICAgICB0aHJvdzogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmpzb24gJiYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShgUmlnaHRCcmFpbiBUYXNrICR7dGFza0lkLnN1YnN0cmluZygwLDgpfS4uLiBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfS4gQ2hlY2sgY29uc29sZS5gLCA3MDAwKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBSQiBUYXNrIENhbGwgWyR7dGFza0lkfV0gRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWAsIHJlc3BvbnNlLnRleHQgPyByZXNwb25zZS50ZXh0LnN1YnN0cmluZygwLCAxMDAwKSA6IFwiTm8gYm9keVwiLCBcIlBheWxvYWQgU2VudDpcIiwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYE5ldHdvcmsgZXJyb3IgY2FsbGluZyBSaWdodEJyYWluIFRhc2sgJHt0YXNrSWQuc3Vic3RyaW5nKDAsOCl9Li4uLiBDaGVjayBjb25zb2xlLmAsIDcwMDApO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUkIgVGFzayBDYWxsIFske3Rhc2tJZH1dIE5ldHdvcmsgRXJyb3I6YCwgZXJyb3IsIFwiUGF5bG9hZCBTZW50OlwiLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGFzeW5jIHZlcmlmeVN1YnByb2Nlc3Nvckxpc3RVcmwodXJsVG9WZXJpZnk6IHN0cmluZywgcHJvY2Vzc29yTmFtZTogc3RyaW5nLHJiVG9rZW46IHN0cmluZyk6IFByb21pc2U8eyBpc0xpc3Q6IGJvb2xlYW47IGlzQ3VycmVudDogYm9vbGVhbjsgaXNDb3JyZWN0UHJvY2Vzc29yOiBib29sZWFuOyByZWFzb25pbmc6IHN0cmluZzsgcGFnZUNvbnRlbnQ/OiBzdHJpbmcgfSB8IG51bGw+IHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5WZXJpZnlVcmxUYXNrSWQpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJSaWdodEJyYWluIFZlcmlmeSBVUkwgVGFzayBJRCBpcyBub3QgY29uZmlndXJlZC4gQ2Fubm90IHZlcmlmeSBVUkwuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFRoZSBpbnB1dCBwYXJhbWV0ZXIgbmFtZSBmb3IgdGhlIFJCIHRhc2sgKCd1cmxfdG9fdmVyaWZ5JywgJ3VybF9jb250ZW50JywgZXRjLilcbiAgICAgICAgLy8gbXVzdCBtYXRjaCB3aGF0IHRoZSBSQiB0YXNrIGRlZmluaXRpb24gZXhwZWN0cy5cbiAgICAgICAgLy8gQXNzdW1pbmcgdGhlIHRhc2sgZXhwZWN0cyBzb21ldGhpbmcgbGlrZTogeyBcInVybF9jb250ZW50XCI6IFwiaHR0cHM6Ly8uLi5cIiB9XG4gICAgICAgIC8vIEFuZCB0aGUgdXJsX2ZldGNoZXIgaW5wdXRfcHJvY2Vzc29yIGlzIGNvbmZpZ3VyZWQgZm9yIFwidXJsX2NvbnRlbnRcIlxuICAgICAgICBjb25zdCB0YXNrSW5wdXQgPSB7IFxuICAgICAgICAgICAgXCJ1cmxfY29udGVudFwiOiB1cmxUb1ZlcmlmeSxcbiAgICAgICAgICAgIFwiZXhwZWN0ZWRfcHJvY2Vzc29yX25hbWVcIjogcHJvY2Vzc29yTmFtZVxuICAgICAgICB9OyAvLyBUaGlzIHdpbGwgYmUgZmV0Y2hlZCBieSB1cmxfZmV0Y2hlclxuICAgIFxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBWZXJpZnlpbmcgVVJMICR7dXJsVG9WZXJpZnl9IHdpdGggUkIgVGFzayAke3RoaXMuc2V0dGluZ3MucmlnaHRicmFpblZlcmlmeVVybFRhc2tJZH0uIElucHV0OmAsIEpTT04uc3RyaW5naWZ5KHRhc2tJbnB1dCkpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdGFza1Jlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbFJpZ2h0QnJhaW5UYXNrKHRoaXMuc2V0dGluZ3MucmlnaHRicmFpblZlcmlmeVVybFRhc2tJZCwgdGFza0lucHV0LCByYlRva2VuKTtcbiAgICBcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUkIgVmVyaWZ5IFRhc2sgWyR7dGhpcy5zZXR0aW5ncy5yaWdodGJyYWluVmVyaWZ5VXJsVGFza0lkfV0gRnVsbCBSZXN1bHQgZm9yIFVSTCAke3VybFRvVmVyaWZ5fTpgLCBKU09OLnN0cmluZ2lmeSh0YXNrUmVzdWx0LCBudWxsLCAyKSk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgdGFza1Jlc3VsdFxuICAgICAgICBpZiAodGFza1Jlc3VsdCAmJiB0eXBlb2YgdGFza1Jlc3VsdC5yZXNwb25zZSA9PT0gJ29iamVjdCcgJiYgdGFza1Jlc3VsdC5yZXNwb25zZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcmJSZXNwb25zZSA9IHRhc2tSZXN1bHQucmVzcG9uc2U7IFxuICAgICAgICAgICAgY29uc3QgaXNMaXN0ID0gU3RyaW5nKHJiUmVzcG9uc2UuaXNTdWJwcm9jZXNzb3JMaXN0KS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG4gICAgICAgICAgICBjb25zdCBpc0NvcnJlY3RQcm9jZXNzb3IgPSBTdHJpbmcocmJSZXNwb25zZS5pc0NvcnJlY3RQcm9jZXNzb3IpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbiAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudCA9IFN0cmluZyhyYlJlc3BvbnNlLmlzQ3VycmVudFZlcnNpb24pLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbiAgICAgICAgICAgIGNvbnN0IHJlYXNvbmluZyA9IHJiUmVzcG9uc2UucmVhc29uaW5nIHx8IFwiTi9BXCI7XG4gICAgXG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdldCBwYWdlQ29udGVudCBpZiB1cmxfZmV0Y2hlciB3YXMgdXNlZCBhbmQgcGFzc2VkIGl0IHRocm91Z2hcbiAgICAgICAgICAgIGxldCBwYWdlQ29udGVudDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gQ2hlY2sgY29tbW9uIHBsYWNlcyB3aGVyZSBmZXRjaGVkIEhUTUwgbWlnaHQgYmUgc3RvcmVkIGJ5IFJCL3VybF9mZXRjaGVyXG4gICAgICAgICAgICBpZiAodGFza1Jlc3VsdC5ydW5fZGF0YSAmJiB0YXNrUmVzdWx0LnJ1bl9kYXRhLnN1Ym1pdHRlZCAmJiBcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGFza1Jlc3VsdC5ydW5fZGF0YS5zdWJtaXR0ZWQudXJsX2NvbnRlbnQgPT09ICdzdHJpbmcnICYmIFxuICAgICAgICAgICAgICAgIHRhc2tSZXN1bHQucnVuX2RhdGEuc3VibWl0dGVkLnVybF9jb250ZW50LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJzxodG1sJykpIHsgLy8gQ2hlY2sgaWYgaXQgbG9va3MgbGlrZSBIVE1MXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhc3N1bWVzICd1cmxfY29udGVudCcgaW4gJ3N1Ym1pdHRlZCcgZGF0YSBpcyB0aGUgZmV0Y2hlZCBIVE1MIGlmIHVybF9mZXRjaGVyIHdhcyB1c2VkLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZGVwZW5kcyBoZWF2aWx5IG9uIFJCJ3MgaW50ZXJuYWwgc3RydWN0dXJlIGZvciBgcnVuX3dhaXRfZm9yX3Jlc3BvbnNlYC5cbiAgICAgICAgICAgICAgICBwYWdlQ29udGVudCA9IHRhc2tSZXN1bHQucnVuX2RhdGEuc3VibWl0dGVkLnVybF9jb250ZW50O1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhcIlJldHJpZXZlZCBwYWdlQ29udGVudCBmcm9tIHJ1bl9kYXRhLnN1Ym1pdHRlZC51cmxfY29udGVudCBmb3IgdmVyaWZ5IHRhc2tcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByYlJlc3BvbnNlLmZldGNoZWRfcGFnZV9odG1sID09PSAnc3RyaW5nJykgeyAvLyBJZiBMTE0gZXhwbGljaXRseSBwYXNzZXMgaXQgYmFja1xuICAgICAgICAgICAgICAgIHBhZ2VDb250ZW50ID0gcmJSZXNwb25zZS5mZXRjaGVkX3BhZ2VfaHRtbDtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coXCJSZXRyaWV2ZWQgcGFnZUNvbnRlbnQgZnJvbSByYlJlc3BvbnNlLmZldGNoZWRfcGFnZV9odG1sIGZvciB2ZXJpZnkgdGFza1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJiUmVzcG9uc2UucGFnZV9jb250ZW50ID09PSAnc3RyaW5nJykgeyAvLyBBbm90aGVyIHBvdGVudGlhbCBmYWxsYmFja1xuICAgICAgICAgICAgICAgICBwYWdlQ29udGVudCA9IHJiUmVzcG9uc2UucGFnZV9jb250ZW50O1xuICAgICAgICAgICAgICAgICBpZih0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coXCJSZXRyaWV2ZWQgcGFnZUNvbnRlbnQgZnJvbSByYlJlc3BvbnNlLnBhZ2VfY29udGVudCAoZmFsbGJhY2spIGZvciB2ZXJpZnkgdGFza1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1vcmUgcm9idXN0OiBpZiB5b3VyIFJCIHRhc2sncyBpbnB1dF9wcm9jZXNzb3IgKHVybF9mZXRjaGVyKSBzdG9yZXMgaXRzIG91dHB1dCBpbiBhIGtub3duIHdheSB3aXRoaW4gYHRhc2tSZXN1bHQucnVuX2RhdGEuaW5wdXRfcHJvY2Vzc29yX291dHB1dHNgLCBhY2Nlc3MgaXQgdGhlcmUuXG4gICAgICAgICAgICAvLyBlLmcuLCBpZiAodGFza1Jlc3VsdC5ydW5fZGF0YT8uaW5wdXRfcHJvY2Vzc29yX291dHB1dHM/LnVybF9jb250ZW50Py50ZXh0X2NvbnRlbnQpIHsgcGFnZUNvbnRlbnQgPSB0YXNrUmVzdWx0LnJ1bl9kYXRhLmlucHV0X3Byb2Nlc3Nvcl9vdXRwdXRzLnVybF9jb250ZW50LnRleHRfY29udGVudDsgfVxuXG4gICAgXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUkIgVmVyaWZ5IGZvciAke3VybFRvVmVyaWZ5fTogTGlzdD0ke2lzTGlzdH0sIEN1cnJlbnQ9JHtpc0N1cnJlbnR9LCBDb250ZW50IGF2YWlsYWJsZTogJHshIXBhZ2VDb250ZW50fSwgQ29udGVudCBzbmlwcGV0OiAke3BhZ2VDb250ZW50ID8gcGFnZUNvbnRlbnQuc3Vic3RyaW5nKDAsMTAwKSArIFwiLi4uXCIgOiBcIk4vQVwifWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNMaXN0LCBpc0N1cnJlbnQ6IChpc0xpc3QgJiYgaXNDdXJyZW50KSwgaXNDb3JyZWN0UHJvY2Vzc29yLCByZWFzb25pbmcsIHBhZ2VDb250ZW50IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFJCIFZlcmlmeSB0YXNrIGZvciAke3VybFRvVmVyaWZ5fSBmYWlsZWQgb3IgcmV0dXJuZWQgdW5leHBlY3RlZCByZXNwb25zZSBmb3JtYXQuIFRhc2tSZXN1bHQ6YCwgdGFza1Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIFZlcmlmaWNhdGlvbiBmYWlsZWQgb3IgdGFzayBvdXRwdXQgd2FzIG5vdCBhcyBleHBlY3RlZFxuICAgIH1cblxuICAgIFxuICAgIHByaXZhdGUgYXN5bmMgZXh0cmFjdEVudGl0aWVzRnJvbVBhZ2VDb250ZW50KHBhZ2VDb250ZW50OiBzdHJpbmcsIHJiVG9rZW46IHN0cmluZyk6IFByb21pc2U8eyB0aGlyZFBhcnR5U3VicHJvY2Vzc29yczogYW55W107IG93bkVudGl0aWVzOiBhbnlbXSB9IHwgbnVsbD4ge1xuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkV4dHJhY3RFbnRpdGllc1Rhc2tJZCkge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIlJCIEV4dHJhY3QgRW50aXRpZXMgVGFzayBJRCBtaXNzaW5nLiBDYW5ub3QgZXh0cmFjdCBmcm9tIGNvbnRlbnQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYWdlQ29udGVudC50cmltKCkpIHtcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coXCJQYWdlIGNvbnRlbnQgaXMgZW1wdHksIHNraXBwaW5nIGVudGl0eSBleHRyYWN0aW9uLlwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRoaXJkUGFydHlTdWJwcm9jZXNzb3JzOiBbXSwgb3duRW50aXRpZXM6IFtdIH07IC8vIFJldHVybiBlbXB0eSBpZiBubyBjb250ZW50XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgaW5wdXQgZmllbGQgbmFtZSBmb3IgdGhlIFJCIHRhc2sgbXVzdCBtYXRjaCB0aGUgdGFzayBkZWZpbml0aW9uLlxuICAgICAgICAvLyBlLmcuLCBpZiB0aGUgdGFzayBleHBlY3RzIHsgXCJ0ZXh0X3RvX2FuYWx5emVcIjogXCIuLi5cIiB9LCB1c2UgdGhhdCBoZXJlLlxuICAgICAgICBjb25zdCB0YXNrSW5wdXQgPSB7IFt0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5FeHRyYWN0SW5wdXRGaWVsZF06IHBhZ2VDb250ZW50IH07XG5cbiAgICAgICAgLy8gaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgRXh0cmFjdGluZyBlbnRpdGllcyB3aXRoIFJCIFRhc2sgJHt0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5FeHRyYWN0RW50aXRpZXNUYXNrSWR9LiBJbnB1dCBzbmlwcGV0OmAsIHBhZ2VDb250ZW50LnN1YnN0cmluZygwLCAyMDApICsgXCIuLi5cIik7XG5cbiAgICAgICAgY29uc3QgdGFza1Jlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbFJpZ2h0QnJhaW5UYXNrKHRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkV4dHJhY3RFbnRpdGllc1Rhc2tJZCwgdGFza0lucHV0LCByYlRva2VuKTtcblxuICAgICAgICAvLyBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcgJiYgdGFza1Jlc3VsdCkge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coYFJCIEV4dHJhY3QgRW50aXRpZXMgVGFzayBGdWxsIFJlc3VsdDpgLCBKU09OLnN0cmluZ2lmeSh0YXNrUmVzdWx0LCBudWxsLCAyKSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZiAodGFza1Jlc3VsdCAmJiB0eXBlb2YgdGFza1Jlc3VsdC5yZXNwb25zZSA9PT0gJ29iamVjdCcgJiYgdGFza1Jlc3VsdC5yZXNwb25zZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcmJSZXNwb25zZSA9IHRhc2tSZXN1bHQucmVzcG9uc2U7XG4gICAgICAgICAgICAvLyBBY2Nlc3MgdGhlIGFycmF5cyB1c2luZyB0aGUgY29uZmlndXJlZCBmaWVsZCBuYW1lcyBmb3IgdGhpcmQtcGFydHkgYW5kIG93biBlbnRpdGllc1xuICAgICAgICAgICAgY29uc3QgdGhpcmRQYXJ0eVN1YnByb2Nlc3NvcnMgPSByYlJlc3BvbnNlW3RoaXMuc2V0dGluZ3MucmlnaHRicmFpbkV4dHJhY3RPdXRwdXRUaGlyZFBhcnR5RmllbGRdIHx8IFtdO1xuICAgICAgICAgICAgY29uc3Qgb3duRW50aXRpZXMgPSByYlJlc3BvbnNlW3RoaXMuc2V0dGluZ3MucmlnaHRicmFpbkV4dHJhY3RPdXRwdXRPd25FbnRpdGllc0ZpZWxkXSB8fCBbXTtcblxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZXkgYXJlIGFycmF5c1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0aGlyZFBhcnR5U3VicHJvY2Vzc29yczogQXJyYXkuaXNBcnJheSh0aGlyZFBhcnR5U3VicHJvY2Vzc29ycykgPyB0aGlyZFBhcnR5U3VicHJvY2Vzc29ycyA6IFtdLFxuICAgICAgICAgICAgICAgIG93bkVudGl0aWVzOiBBcnJheS5pc0FycmF5KG93bkVudGl0aWVzKSA/IG93bkVudGl0aWVzIDogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLndhcm4oYFJCIEV4dHJhY3QgRW50aXRpZXMgdGFzayBmYWlsZWQgb3IgcmV0dXJuZWQgdW5leHBlY3RlZCByZXNwb25zZSBmb3JtYXQuIFRhc2tSZXN1bHQ6YCwgdGFza1Jlc3VsdCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyB1cGRhdGVEaXNjb3ZlcnlTdGF0dXMoZmlsZTogVEZpbGUsIHN0YXR1czogJ2NvbXBsZXRlJyB8ICdpbmNvbXBsZXRlJyB8ICdza2lwcGVkJykge1xuICAgICAgICBpZiAoIWZpbGUpIHJldHVybjtcbiAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQucHJvY2VzcyhmaWxlLCAoY29udGVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlczogYW55ID0ge1xuICAgICAgICAgICAgICAgICdkaXNjb3Zlcnktc3RhdHVzJzogc3RhdHVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZXNbJ2xhc3QtZGlzY292ZXJlZCddID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07IC8vIFlZWVktTU0tREQgZm9ybWF0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVGcm9udG1hdHRlcihjb250ZW50LCB1cGRhdGVzLCBmaWxlLmJhc2VuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBidWlsZEFsaWFzTWFwKCk6IFByb21pc2U8TWFwPHN0cmluZywgeyBwYXRoOiBzdHJpbmcsIGNhbm9uaWNhbE5hbWU6IHN0cmluZyB9Pj4ge1xuICAgICAgICBjb25zdCBhbGlhc01hcCA9IG5ldyBNYXA8c3RyaW5nLCB7IHBhdGg6IHN0cmluZywgY2Fub25pY2FsTmFtZTogc3RyaW5nIH0+KCk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NvcnNGb2xkZXIgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5zZXR0aW5ncy5wcm9jZXNzb3JzRm9sZGVyUGF0aCkgYXMgVEZvbGRlcjtcbiAgICAgICAgaWYgKCFwcm9jZXNzb3JzRm9sZGVyPy5jaGlsZHJlbikgcmV0dXJuIGFsaWFzTWFwO1xuXG4gICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBwcm9jZXNzb3JzRm9sZGVyLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlICYmIGZpbGUuZXh0ZW5zaW9uID09PSAnbWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9udG1hdHRlciA9IGNhY2hlPy5mcm9udG1hdHRlciB8fCB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5vbmljYWxOYW1lID0gZnJvbnRtYXR0ZXIuYWxpYXNlcz8uWzBdIHx8IGZpbGUuYmFzZW5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxpYXNlcyA9IChmcm9udG1hdHRlci5hbGlhc2VzIHx8IFtdKS5tYXAoKGE6IHN0cmluZykgPT4gU3RyaW5nKGEpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIGFsaWFzZXMucHVzaChmaWxlLmJhc2VuYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgbmV3IFNldChhbGlhc2VzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzTWFwLnNldChhbGlhcywgeyBwYXRoOiBmaWxlLnBhdGgsIGNhbm9uaWNhbE5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsaWFzTWFwO1xuICAgIH1cblxuICAgIGFzeW5jIHJ1bkRlZHVwbGljYXRpb25Gb3JGb2xkZXIoZm9sZGVyOiBURm9sZGVyKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYFByZXBhcmluZyB0byBkZWR1cGxpY2F0ZSBwYWdlcyBpbiAke2ZvbGRlci5wYXRofS4uLmApO1xuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkRlZHVwbGljYXRlU3VicHJvY2Vzc29yc1Rhc2tJZCkge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIkRlZHVwbGljYXRpb24gVGFzayBJRCBub3Qgc2V0LiBDYW5ub3QgcHJvY2VlZC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmJUb2tlbiA9IGF3YWl0IHRoaXMuZ2V0UmlnaHRCcmFpbkFjY2Vzc1Rva2VuKCk7XG4gICAgICAgIGlmICghcmJUb2tlbikge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIkNvdWxkIG5vdCBnZXQgUmlnaHRCcmFpbiB0b2tlbiBmb3IgZGVkdXBsaWNhdGlvbi5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaWxlcyA9IGZvbGRlci5jaGlsZHJlbi5maWx0ZXIoZiA9PiBmIGluc3RhbmNlb2YgVEZpbGUgJiYgZi5leHRlbnNpb24gPT09ICdtZCcpIGFzIFRGaWxlW107XG4gICAgICAgIGlmIChmaWxlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiTm90IGVub3VnaCBNYXJrZG93biBmaWxlcyBpbiB0aGUgZm9sZGVyIHRvIHBlcmZvcm0gZGVkdXBsaWNhdGlvbi5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdWJwcm9jZXNzb3JQYWdlc0luZm86IFN1YnByb2Nlc3NvclBhZ2VJbmZvW10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlQ2FjaGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICAgICAgICAgIGNvbnN0IGZyb250bWF0dGVyID0gZmlsZUNhY2hlPy5mcm9udG1hdHRlcjtcbiAgICAgICAgICAgIGNvbnN0IGFsaWFzZXMgPSAoZnJvbnRtYXR0ZXI/LmFsaWFzZXMgJiYgQXJyYXkuaXNBcnJheShmcm9udG1hdHRlci5hbGlhc2VzKSkgPyBmcm9udG1hdHRlci5hbGlhc2VzLm1hcChTdHJpbmcpIDogW107XG4gICAgICAgICAgICBpZiAoZnJvbnRtYXR0ZXI/LmNvbXBhbnlfbmFtZSkgYWxpYXNlcy5wdXNoKFN0cmluZyhmcm9udG1hdHRlci5jb21wYW55X25hbWUpKTsgLy8gSW5jbHVkZSBjb21wYW55X25hbWUgaWYgcHJlc2VudFxuICAgICAgICAgICAgYWxpYXNlcy5wdXNoKGZpbGUuYmFzZW5hbWUpOyAvLyBJbmNsdWRlIGJhc2VuYW1lIGFzIGFuIGFsaWFzXG5cbiAgICAgICAgICAgIHN1YnByb2Nlc3NvclBhZ2VzSW5mby5wdXNoKHtcbiAgICAgICAgICAgICAgICBmaWxlX3BhdGg6IGZpbGUucGF0aCxcbiAgICAgICAgICAgICAgICBwYWdlX25hbWU6IGZpbGUuYmFzZW5hbWUsIC8vIE9yIGEgbW9yZSBjYW5vbmljYWwgbmFtZSBmcm9tIGZyb250bWF0dGVyIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGFsaWFzZXM6IEFycmF5LmZyb20obmV3IFNldChhbGlhc2VzLmZpbHRlcihhID0+IGEpKSkgLy8gVW5pcXVlLCBub24tZW1wdHkgYWxpYXNlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VicHJvY2Vzc29yUGFnZXNJbmZvLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJOb3QgZW5vdWdoIHByb2Nlc3NhYmxlIHBhZ2VzIHdpdGggYWxpYXNlcyBmb3VuZCBmb3IgZGVkdXBsaWNhdGlvbi5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRhc2tJbnB1dFBheWxvYWQgPSB7XG4gICAgICAgICAgICBzdWJwcm9jZXNzb3JfcGFnZXM6IHN1YnByb2Nlc3NvclBhZ2VzSW5mbyxcbiAgICAgICAgICAgIC8vIE9wdGlvbmFsOiBBZGQgYSB0aHJlc2hvbGQgb3Igb3RoZXIgcGFyYW1ldGVycyBpZiB5b3VyIFJCIHRhc2sgc3VwcG9ydHMgdGhlbVxuICAgICAgICAgICAgLy8gXCJzaW1pbGFyaXR5X3RocmVzaG9sZFwiOiAwLjggXG4gICAgICAgIH07XG5cbiAgICAgICAgbmV3IE5vdGljZShgU2VuZGluZyAke3N1YnByb2Nlc3NvclBhZ2VzSW5mby5sZW5ndGh9IHBhZ2VzIHRvIFJpZ2h0QnJhaW4gZm9yIGRlZHVwbGljYXRpb24gYW5hbHlzaXMuLi4gVGhpcyBtYXkgdGFrZSBhIHdoaWxlLmApO1xuICAgICAgICAvLyBpZih0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coXCJEZWR1cGxpY2F0aW9uIHBheWxvYWQ6XCIsIEpTT04uc3RyaW5naWZ5KHRhc2tJbnB1dFBheWxvYWQpKTtcblxuICAgICAgICBjb25zdCB0YXNrUmVzdWx0ID0gYXdhaXQgdGhpcy5jYWxsUmlnaHRCcmFpblRhc2sodGhpcy5zZXR0aW5ncy5yaWdodGJyYWluRGVkdXBsaWNhdGVTdWJwcm9jZXNzb3JzVGFza0lkLCB0YXNrSW5wdXRQYXlsb2FkLCByYlRva2VuKTtcblxuICAgICAgICAvLyBpZih0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZyAmJiB0YXNrUmVzdWx0KSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcIkRlZHVwbGljYXRpb24gVGFzayBGdWxsIFJlc3VsdDpcIiwgSlNPTi5zdHJpbmdpZnkodGFza1Jlc3VsdCwgbnVsbCwgMikpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYgKHRhc2tSZXN1bHQgJiYgdGFza1Jlc3VsdC5yZXNwb25zZSAmJiBBcnJheS5pc0FycmF5KHRhc2tSZXN1bHQucmVzcG9uc2UuZGVkdXBsaWNhdGlvbl9yZXN1bHRzKSkge1xuICAgICAgICAgICAgY29uc3QgZGVkdXBsaWNhdGlvblJlc3VsdHM6IERlZHVwbGljYXRpb25SZXN1bHRJdGVtW10gPSB0YXNrUmVzdWx0LnJlc3BvbnNlLmRlZHVwbGljYXRpb25fcmVzdWx0cztcbiAgICAgICAgICAgIGlmIChkZWR1cGxpY2F0aW9uUmVzdWx0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiTm8gZHVwbGljYXRlcyBmb3VuZCBieSBSaWdodEJyYWluIHRhc2suXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYERlZHVwbGljYXRpb24gYW5hbHlzaXMgY29tcGxldGUuIEZvdW5kICR7ZGVkdXBsaWNhdGlvblJlc3VsdHMubGVuZ3RofSBwb3RlbnRpYWwgZHVwbGljYXRlIHNldHMuIFByb2Nlc3NpbmcgbWVyZ2VzLi4uYCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NEZWR1cGxpY2F0aW9uUmVzdWx0cyhkZWR1cGxpY2F0aW9uUmVzdWx0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiRGVkdXBsaWNhdGlvbiB0YXNrIGZhaWxlZCBvciByZXR1cm5lZCBhbiB1bmV4cGVjdGVkIHJlc3BvbnNlLiBDaGVjayBjb25zb2xlLlwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEZWR1cGxpY2F0aW9uIHRhc2sgZXJyb3IuIFJlc3BvbnNlOlwiLCB0YXNrUmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgYXN5bmMgcHJvY2Vzc0RlZHVwbGljYXRpb25SZXN1bHRzKHJlc3VsdHM6IERlZHVwbGljYXRpb25SZXN1bHRJdGVtW10pIHtcbiAgICAgICAgbGV0IG1lcmdlQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdFNldCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdFNldC5zdXJ2aXZvcl9maWxlX3BhdGggfHwgcmVzdWx0U2V0LmR1cGxpY2F0ZV9maWxlX3BhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS53YXJuKFwiU2tpcHBpbmcgaW52YWxpZCBkZWR1cGxpY2F0aW9uIHJlc3VsdCBzZXQ6XCIsIHJlc3VsdFNldCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHN1cnZpdm9yRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChyZXN1bHRTZXQuc3Vydml2b3JfZmlsZV9wYXRoKSBhcyBURmlsZTtcbiAgICAgICAgICAgIGlmICghc3Vydml2b3JGaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLndhcm4oYFN1cnZpdm9yIGZpbGUgbm90IGZvdW5kOiAke3Jlc3VsdFNldC5zdXJ2aXZvcl9maWxlX3BhdGh9YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3Vydml2b3JDb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChzdXJ2aXZvckZpbGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyAtLS0gU3RlcCAxOiBHYXRoZXIgYWxsIGRhdGEgZnJvbSBzdXJ2aXZvciBhbmQgZHVwbGljYXRlcyAtLS1cblxuICAgICAgICAgICAgLy8gR2F0aGVyIGFsaWFzZXMgYW5kIHJvd3MgZnJvbSB0aGUgc3Vydml2b3IgZmlsZSBmaXJzdFxuICAgICAgICAgICAgY29uc3Qgc3Vydml2b3JDYWNoZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKHN1cnZpdm9yRmlsZSk7XG4gICAgICAgICAgICBjb25zdCBhbGxBbGlhc2VzID0gbmV3IFNldDxzdHJpbmc+KChzdXJ2aXZvckNhY2hlPy5mcm9udG1hdHRlcj8uYWxpYXNlcyB8fCBbXSkubWFwKFN0cmluZykpO1xuICAgICAgICAgICAgYWxsQWxpYXNlcy5hZGQoc3Vydml2b3JGaWxlLmJhc2VuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbFJvd3MgPSBuZXcgU2V0PHN0cmluZz4odGhpcy5leHRyYWN0Q2xpZW50VGFibGVSb3dzKG9yaWdpbmFsU3Vydml2b3JDb250ZW50KSk7XG5cbiAgICAgICAgICAgIC8vIE5vdywgbG9vcCB0aHJvdWdoIGR1cGxpY2F0ZXMgdG8gZ2F0aGVyIHRoZWlyIGRhdGFcbiAgICAgICAgICAgIGZvciAoY29uc3QgZHVwRmlsZVBhdGggb2YgcmVzdWx0U2V0LmR1cGxpY2F0ZV9maWxlX3BhdGhzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGR1cEZpbGVQYXRoID09PSBzdXJ2aXZvckZpbGUucGF0aCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgZHVwRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChkdXBGaWxlUGF0aCkgYXMgVEZpbGU7XG4gICAgICAgICAgICAgICAgaWYgKGR1cEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHVwQ29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZHVwRmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cENhY2hlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZHVwRmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBkdXBsaWNhdGUncyBhbGlhc2VzIGFuZCBiYXNlbmFtZSB0byB0aGUgc2V0XG4gICAgICAgICAgICAgICAgICAgIChkdXBDYWNoZT8uZnJvbnRtYXR0ZXI/LmFsaWFzZXMgfHwgW10pLm1hcChTdHJpbmcpLmZvckVhY2goYWxpYXMgPT4gYWxsQWxpYXNlcy5hZGQoYWxpYXMpKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsQWxpYXNlcy5hZGQoZHVwRmlsZS5iYXNlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBkdXBsaWNhdGUncyBcIlVzZWQgQnlcIiByb3dzIHRvIHRoZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHRyYWN0Q2xpZW50VGFibGVSb3dzKGR1cENvbnRlbnQpLmZvckVhY2gocm93ID0+IGFsbFJvd3MuYWRkKHJvdykpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmRlbGV0ZShkdXBGaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGRlbGV0ZSBkdXBsaWNhdGUgZmlsZSAke2R1cEZpbGVQYXRofTpgLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLS0tIFN0ZXAgMjogUmVidWlsZCB0aGUgZmlsZSBmcm9tIHNjcmF0Y2ggd2l0aCBtZXJnZWQgZGF0YSAtLS1cblxuICAgICAgICAgICAgLy8gMkE6IElzb2xhdGUgdGhlIG9yaWdpbmFsIGJvZHkgb2YgdGhlIHN1cnZpdm9yIGZpbGUgKGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZyb250bWF0dGVyKVxuICAgICAgICAgICAgY29uc3QgZm1SZWdleCA9IC9eLS0tXFxzKlxcbihbXFxzXFxTXSo/KVxcbi0tLVxccypcXG4vO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBvcmlnaW5hbFN1cnZpdm9yQ29udGVudC5tYXRjaChmbVJlZ2V4KTtcbiAgICAgICAgICAgIGxldCBzdXJ2aXZvckJvZHkgPSBtYXRjaCA/IG9yaWdpbmFsU3Vydml2b3JDb250ZW50LnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpIDogb3JpZ2luYWxTdXJ2aXZvckNvbnRlbnQ7XG5cbiAgICAgICAgICAgIC8vIDJCOiBSZWJ1aWxkIHRoZSBmcm9udG1hdHRlciBzdHJpbmcgd2l0aCBhbGwgbWVyZ2VkIGFsaWFzZXNcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGFncyA9IG5ldyBTZXQ8c3RyaW5nPigoc3Vydml2b3JDYWNoZT8uZnJvbnRtYXR0ZXI/LnRhZ3MgfHwgW10pLm1hcChTdHJpbmcpKTtcbiAgICAgICAgICAgIGxldCBuZXdGbVN0cmluZyA9IFwiLS0tXFxuXCI7XG4gICAgICAgICAgICBuZXdGbVN0cmluZyArPSBgYWxpYXNlczogWyR7QXJyYXkuZnJvbShhbGxBbGlhc2VzKS5tYXAoYSA9PiBgXCIke2EucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpfVwiYCkuam9pbignLCAnKX1dXFxuYDtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1RhZ3Muc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBuZXdGbVN0cmluZyArPSBgdGFnczogWyR7QXJyYXkuZnJvbShleGlzdGluZ1RhZ3MpLm1hcCh0ID0+IGBcIiR7dH1cImApLmpvaW4oJywgJyl9XVxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdGbVN0cmluZyArPSBcIi0tLVxcblwiO1xuXG4gICAgICAgICAgICAvLyAyQzogUmVidWlsZCB0aGUgXCJVc2VkIEJ5XCIgdGFibGUgbWFya2Rvd24gc3RyaW5nIGZyb20gdGhlIG1lcmdlZCByb3dzXG4gICAgICAgICAgICBsZXQgY2xpZW50VGFibGVNZCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoYWxsUm93cy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIGNsaWVudFRhYmxlTWQgKz0gYHwgUHJpbWFyeSBQcm9jZXNzb3IgfCBQcm9jZXNzaW5nIEZ1bmN0aW9uIHwgTG9jYXRpb24gfCBTb3VyY2UgVVJMIHxcXG5gO1xuICAgICAgICAgICAgICAgIGNsaWVudFRhYmxlTWQgKz0gYHwtLS18LS0tfC0tLXwtLS18XFxuYDtcbiAgICAgICAgICAgICAgICBhbGxSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50VGFibGVNZCArPSBgfCR7cm93fXxcXG5gO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAyRDogUmVwbGFjZSB0aGUgXCJVc2VkIEJ5XCIgc2VjdGlvbiB3aXRoaW4gdGhlIGlzb2xhdGVkIGJvZHlcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsQm9keSA9IHRoaXMuZW5zdXJlSGVhZGluZ0FuZFNlY3Rpb24oc3Vydml2b3JCb2R5LCBcIlVzZWQgQnlcIiwgY2xpZW50VGFibGVNZCwgbnVsbCwgbnVsbCk7XG5cbiAgICAgICAgICAgIC8vIDJFOiBBc3NlbWJsZSB0aGUgZmluYWwsIGNvbXBsZXRlIGNvbnRlbnRcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsQ29udGVudCA9IG5ld0ZtU3RyaW5nICsgZmluYWxCb2R5O1xuXG4gICAgICAgICAgICAvLyAtLS0gU3RlcCAzOiBXcml0ZSB0aGUgZmluYWwgY29udGVudCBiYWNrIHRvIHRoZSBzdXJ2aXZvciBmaWxlIC0tLVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KHN1cnZpdm9yRmlsZSwgZmluYWxDb250ZW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbWVyZ2VDb3VudCsrO1xuICAgICAgICAgICAgbmV3IE5vdGljZShgTWVyZ2VkICR7cmVzdWx0U2V0LmR1cGxpY2F0ZV9maWxlX3BhdGhzLmxlbmd0aH0gZHVwbGljYXRlKHMpIGludG8gJHtzdXJ2aXZvckZpbGUuYmFzZW5hbWV9LmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lcmdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBEZWR1cGxpY2F0aW9uIGZpbmlzaGVkLiAke21lcmdlQ291bnR9IG1lcmdlIG9wZXJhdGlvbnMgcGVyZm9ybWVkLmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIkRlZHVwbGljYXRpb24gcHJvY2VzcyBmaW5pc2hlZCwgYnV0IG5vIGFjdGlvbmFibGUgbWVyZ2VzIHdlcmUgbWFkZS5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBwcm9jZXNzTWFudWFsTWVyZ2Uoc3Vydml2b3JGaWxlOiBURmlsZSwgZHVwbGljYXRlRmlsZXM6IFRGaWxlW10pIHtcbiAgICAgICAgaWYgKCFzdXJ2aXZvckZpbGUgfHwgZHVwbGljYXRlRmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiTWVyZ2UgY2FuY2VsbGVkOiBObyBzdXJ2aXZvciBvciBkdXBsaWNhdGVzIHNlbGVjdGVkLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ldyBOb3RpY2UoYE1lcmdpbmcgJHtkdXBsaWNhdGVGaWxlcy5sZW5ndGh9IGZpbGUocykgaW50byAke3N1cnZpdm9yRmlsZS5iYXNlbmFtZX0uLi5gLCA2MDAwKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdXJ2aXZvckNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKHN1cnZpdm9yRmlsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIC0tLSBTdGVwIDE6IEdhdGhlciBhbGwgZGF0YSBmcm9tIHN1cnZpdm9yIGFuZCBkdXBsaWNhdGVzIC0tLVxuICAgICAgICAgICAgY29uc3Qgc3Vydml2b3JDYWNoZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKHN1cnZpdm9yRmlsZSk7XG4gICAgICAgICAgICBjb25zdCBhbGxBbGlhc2VzID0gbmV3IFNldDxzdHJpbmc+KChzdXJ2aXZvckNhY2hlPy5mcm9udG1hdHRlcj8uYWxpYXNlcyB8fCBbXSkubWFwKFN0cmluZykpO1xuICAgICAgICAgICAgYWxsQWxpYXNlcy5hZGQoc3Vydml2b3JGaWxlLmJhc2VuYW1lKTsgLy8gQWRkIHN1cnZpdm9yJ3Mgb3duIG5hbWVcbiAgICAgICAgICAgIGNvbnN0IGFsbFJvd3MgPSBuZXcgU2V0PHN0cmluZz4odGhpcy5leHRyYWN0Q2xpZW50VGFibGVSb3dzKG9yaWdpbmFsU3Vydml2b3JDb250ZW50KSk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZHVwRmlsZSBvZiBkdXBsaWNhdGVGaWxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR1cENvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGR1cEZpbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR1cENhY2hlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZHVwRmlsZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQWRkIGR1cGxpY2F0ZSdzIGFsaWFzZXMgYW5kIGJhc2VuYW1lIHRvIHRoZSBzZXRcbiAgICAgICAgICAgICAgICAoZHVwQ2FjaGU/LmZyb250bWF0dGVyPy5hbGlhc2VzIHx8IFtdKS5tYXAoU3RyaW5nKS5mb3JFYWNoKGFsaWFzID0+IGFsbEFsaWFzZXMuYWRkKGFsaWFzKSk7XG4gICAgICAgICAgICAgICAgYWxsQWxpYXNlcy5hZGQoZHVwRmlsZS5iYXNlbmFtZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQWRkIGR1cGxpY2F0ZSdzIFwiVXNlZCBCeVwiIHRhYmxlIHJvd3MgdG8gdGhlIHNldFxuICAgICAgICAgICAgICAgIHRoaXMuZXh0cmFjdENsaWVudFRhYmxlUm93cyhkdXBDb250ZW50KS5mb3JFYWNoKHJvdyA9PiBhbGxSb3dzLmFkZChyb3cpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLS0tIFN0ZXAgMjogUmVidWlsZCB0aGUgc3Vydml2b3IgZmlsZSB3aXRoIG1lcmdlZCBkYXRhIC0tLVxuICAgICAgICAgICAgY29uc3QgZm1SZWdleCA9IC9eLS0tXFxzKlxcbihbXFxzXFxTXSo/KVxcbi0tLVxccypcXG4vO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBvcmlnaW5hbFN1cnZpdm9yQ29udGVudC5tYXRjaChmbVJlZ2V4KTtcbiAgICAgICAgICAgIGxldCBzdXJ2aXZvckJvZHkgPSBtYXRjaCA/IG9yaWdpbmFsU3Vydml2b3JDb250ZW50LnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpIDogb3JpZ2luYWxTdXJ2aXZvckNvbnRlbnQ7XG5cbiAgICAgICAgICAgIC8vIFJlYnVpbGQgZnJvbnRtYXR0ZXJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGFncyA9IG5ldyBTZXQ8c3RyaW5nPigoc3Vydml2b3JDYWNoZT8uZnJvbnRtYXR0ZXI/LnRhZ3MgfHwgW10pLm1hcChTdHJpbmcpKTtcbiAgICAgICAgICAgIGxldCBuZXdGbVN0cmluZyA9IFwiLS0tXFxuXCI7XG4gICAgICAgICAgICBuZXdGbVN0cmluZyArPSBgYWxpYXNlczogWyR7QXJyYXkuZnJvbShhbGxBbGlhc2VzKS5tYXAoYSA9PiBgXCIke2EucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpfVwiYCkuam9pbignLCAnKX1dXFxuYDtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1RhZ3Muc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBuZXdGbVN0cmluZyArPSBgdGFnczogWyR7QXJyYXkuZnJvbShleGlzdGluZ1RhZ3MpLm1hcCh0ID0+IGBcIiR7dH1cImApLmpvaW4oJywgJyl9XVxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdGbVN0cmluZyArPSBcIi0tLVxcblwiO1xuXG4gICAgICAgICAgICAvLyBSZWJ1aWxkIFwiVXNlZCBCeVwiIHRhYmxlXG4gICAgICAgICAgICBsZXQgY2xpZW50VGFibGVNZCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoYWxsUm93cy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIGNsaWVudFRhYmxlTWQgKz0gYHwgUHJpbWFyeSBQcm9jZXNzb3IgfCBQcm9jZXNzaW5nIEZ1bmN0aW9uIHwgTG9jYXRpb24gfCBTb3VyY2UgVVJMIHxcXG5gO1xuICAgICAgICAgICAgICAgIGNsaWVudFRhYmxlTWQgKz0gYHwtLS18LS0tfC0tLXwtLS18XFxuYDtcbiAgICAgICAgICAgICAgICBhbGxSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50VGFibGVNZCArPSBgfCR7cm93fXxcXG5gO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBcIlVzZWQgQnlcIiBzZWN0aW9uIHdpdGhpbiB0aGUgc3Vydml2b3IncyBib2R5XG4gICAgICAgICAgICBjb25zdCBmaW5hbEJvZHkgPSB0aGlzLmVuc3VyZUhlYWRpbmdBbmRTZWN0aW9uKHN1cnZpdm9yQm9keSwgXCJVc2VkIEJ5XCIsIGNsaWVudFRhYmxlTWQsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgY29uc3QgZmluYWxDb250ZW50ID0gbmV3Rm1TdHJpbmcgKyBmaW5hbEJvZHk7XG5cbiAgICAgICAgICAgIC8vIC0tLSBTdGVwIDM6IFdyaXRlIHRvIHN1cnZpdm9yIGFuZCBkZWxldGUgZHVwbGljYXRlcyAtLS1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShzdXJ2aXZvckZpbGUsIGZpbmFsQ29udGVudCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAoY29uc3QgZHVwRmlsZSBvZiBkdXBsaWNhdGVGaWxlcykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmRlbGV0ZShkdXBGaWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3IE5vdGljZShgU3VjY2Vzc2Z1bGx5IG1lcmdlZCAke2R1cGxpY2F0ZUZpbGVzLmxlbmd0aH0gZmlsZShzKSBpbnRvICR7c3Vydml2b3JGaWxlLmJhc2VuYW1lfS5gKTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGR1cmluZyBtYW51YWwgbWVyZ2U6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIG1lcmdlLiBDaGVjayB0aGUgZGV2ZWxvcGVyIGNvbnNvbGUuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHRyYWN0Q2xpZW50VGFibGVSb3dzKGNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3Qgcm93czogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgbGV0IGluVXNlZEJ5U2VjdGlvbiA9IGZhbHNlO1xuICAgICAgICBsZXQgdGFibGVIYXNTdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBoZWFkaW5nIHRvIHN0YXJ0IHRoZSBwcm9jZXNzXG4gICAgICAgICAgICBpZiAobGluZS5tYXRjaCgvXiMjK1xccypVc2VkIEJ5XFxzKiQvaSkpIHtcbiAgICAgICAgICAgICAgICBpblVzZWRCeVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRhYmxlSGFzU3RhcnRlZCA9IGZhbHNlOyAvLyBSZXNldCBpbiBjYXNlIG9mIG11bHRpcGxlIFwiVXNlZCBCeVwiIHNlY3Rpb25zXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9uY2Ugd2UgYXJlIGluIHRoZSByaWdodCBzZWN0aW9uLCBsb29rIGZvciB0aGUgdGFibGVcbiAgICAgICAgICAgIGlmIChpblVzZWRCeVNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkTGluZSA9IGxpbmUudHJpbSgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFN0b3AgaWYgd2UgaGl0IGFub3RoZXIgaGVhZGluZyBvZiB0aGUgc2FtZSBvciBoaWdoZXIgbGV2ZWxcbiAgICAgICAgICAgICAgICBpZiAodHJpbW1lZExpbmUuc3RhcnRzV2l0aCgnIyMnKSkge1xuICAgICAgICAgICAgICAgICAgICBpblVzZWRCeVNlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRhYmxlIHNlcGFyYXRvciB0byBiZWdpbiBjYXB0dXJpbmcgcm93c1xuICAgICAgICAgICAgICAgIGlmICh0cmltbWVkTGluZS5tYXRjaCgvXlxcfC0tLVxcfC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlSGFzU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0YWJsZSBoYXMgc3RhcnRlZCwgY2FwdHVyZSB2YWxpZCByb3cgY29udGVudFxuICAgICAgICAgICAgICAgIGlmICh0YWJsZUhhc1N0YXJ0ZWQgJiYgdHJpbW1lZExpbmUuc3RhcnRzV2l0aCgnfCcpICYmIHRyaW1tZWRMaW5lLmVuZHNXaXRoKCd8JykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBjb250ZW50IGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IHBpcGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB0cmltbWVkTGluZS5tYXRjaCgvXlxcfCguKilcXHwkLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCBpdCdzIGEgY29udGVudCByb3csIG5vdCBhbm90aGVyIHNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaFsxXS5tYXRjaCgvXi0tLVxcfC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhYmxlSGFzU3RhcnRlZCAmJiB0cmltbWVkTGluZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRhYmxlIGhhZCBzdGFydGVkIGFuZCB3ZSBmaW5kIGEgbm9uLWVtcHR5LCBub24tdGFibGUgcm93LCBhc3N1bWUgdGhlIHRhYmxlIGhhcyBlbmRlZC5cbiAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93cztcbiAgICB9XG5cblxuICAgIGFzeW5jIGRpc2NvdmVyUmVjdXJzaXZlbHkoaW5pdGlhbFByb2Nlc3Nvck5hbWU6IHN0cmluZywgaW5pdGlhbFByb2Nlc3NvckZpbGU/OiBURmlsZSwgbWF4RGVwdGg6IG51bWJlciA9IDMpIHtcbiAgICAgICAgbmV3IE5vdGljZShgU3RhcnRpbmcgc21hcnQgcmVjdXJzaXZlIGRpc2NvdmVyeSBmb3I6ICR7aW5pdGlhbFByb2Nlc3Nvck5hbWV9LiBNYXggZGVwdGg6ICR7bWF4RGVwdGh9YCwgMTAwMDApO1xuXG4gICAgICAgIGNvbnN0IGFsaWFzTWFwID0gYXdhaXQgdGhpcy5idWlsZEFsaWFzTWFwKCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkSW5DdXJyZW50UmVjdXJzaXZlU2VhcmNoID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgICAgIGNvbnN0IHF1ZXVlOiBBcnJheTx7IHByb2Nlc3Nvck5hbWU6IHN0cmluZywgZGVwdGg6IG51bWJlciB9PiA9IFt7IHByb2Nlc3Nvck5hbWU6IGluaXRpYWxQcm9jZXNzb3JOYW1lLCBkZXB0aDogMCB9XTtcbiAgICAgICAgbGV0IGRpc2NvdmVyZWRDb3VudCA9IDA7XG4gICAgICAgIGxldCBza2lwcGVkQ291bnQgPSAwO1xuICAgIFxuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQpIGNvbnRpbnVlO1xuICAgIFxuICAgICAgICAgICAgbGV0IHsgcHJvY2Vzc29yTmFtZSwgZGVwdGggfSA9IGN1cnJlbnQ7XG4gICAgXG4gICAgICAgICAgICAvLyAtLS0gU3RhdGUtQXdhcmUgUHJvY2Vzc2luZyBDaGVjayAtLS1cbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRW50aXR5ID0gYWxpYXNNYXAuZ2V0KHByb2Nlc3Nvck5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICBsZXQgY3VycmVudFByb2Nlc3NvckZpbGUgPSBleGlzdGluZ0VudGl0eSA/IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChleGlzdGluZ0VudGl0eS5wYXRoKSBhcyBURmlsZSA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJvY2Vzc29yRmlsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoY3VycmVudFByb2Nlc3NvckZpbGUpO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZT8uZnJvbnRtYXR0ZXI/LlsnZGlzY292ZXJ5LXN0YXR1cyddID09PSAnY29tcGxldGUnICYmIGNhY2hlPy5mcm9udG1hdHRlcj8uWydsYXN0LWRpc2NvdmVyZWQnXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0UnVuID0gbmV3IERhdGUoY2FjaGUuZnJvbnRtYXR0ZXJbJ2xhc3QtZGlzY292ZXJlZCddKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwaXJ5RGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGV4cGlyeURhdGUuc2V0RGF0ZShleHBpcnlEYXRlLmdldERhdGUoKSAtIHRoaXMuc2V0dGluZ3MuZGlzY292ZXJ5Q2FjaGVEYXlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RSdW4gPiBleHBpcnlEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBTa2lwcGluZyByZWNlbnRseSBwcm9jZXNzZWQ6ICR7cHJvY2Vzc29yTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFJlY3Vyc2l2ZSAoZGVwdGggJHtkZXB0aH0pOiBQcm9jZXNzaW5nICR7cHJvY2Vzc29yTmFtZX0uLi5gKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZmlsZVBhdGhOYW1lOiBzYW5pdGl6ZWROYW1lRm9yVHJhY2tpbmcgfSA9IHRoaXMuc2FuaXRpemVOYW1lRm9yRmlsZVBhdGhBbmRBbGlhcyhwcm9jZXNzb3JOYW1lKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NlZEluQ3VycmVudFJlY3Vyc2l2ZVNlYXJjaC5oYXMoc2FuaXRpemVkTmFtZUZvclRyYWNraW5nKSkgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NlZEluQ3VycmVudFJlY3Vyc2l2ZVNlYXJjaC5hZGQoc2FuaXRpemVkTmFtZUZvclRyYWNraW5nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgaXNUb3BMZXZlbCA9IGRlcHRoID09PSAwO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvY2Vzc29yRmlsZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9jZXNzb3JGaWxlID0gYXdhaXQgdGhpcy5lbnN1cmVQcm9jZXNzb3JGaWxlKHByb2Nlc3Nvck5hbWUsIHRydWUsIGlzVG9wTGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvY2Vzc29yRmlsZSkgY29udGludWU7XG5cbiAgICAgICAgICAgIGRpc2NvdmVyZWRDb3VudCsrO1xuICAgICAgICAgICAgY29uc3Qgc2VhcmNoRGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2hQcm9jZXNzb3JTZWFyY2hEYXRhV2l0aERpc2NvdmVyeShwcm9jZXNzb3JOYW1lKTtcbiAgICBcbiAgICAgICAgICAgIGlmIChzZWFyY2hEYXRhPy5jb2xsZWN0ZWRSZWxhdGlvbnNoaXBzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0U3ViTmFtZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoc2VhcmNoRGF0YS5jb2xsZWN0ZWRSZWxhdGlvbnNoaXBzXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIocmVsID0+IHJlbC5QcmltYXJ5UHJvY2Vzc29yID09PSBwcm9jZXNzb3JOYW1lICYmIHJlbC5SZWxhdGlvbnNoaXBUeXBlID09PSAndXNlc19zdWJwcm9jZXNzb3InKVxuICAgICAgICAgICAgICAgICAgICAubWFwKHJlbCA9PiByZWwuU3VicHJvY2Vzc29yTmFtZS50cmltKCkpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobmFtZSA9PiBuYW1lKSkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VEZWNpc2lvbnNMb2c6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPCBtYXhEZXB0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWJOYW1lIG9mIGRpcmVjdFN1Yk5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRTdWJOYW1lRm9yVHJhY2tpbmcgPSB0aGlzLnNhbml0aXplTmFtZUZvckZpbGVQYXRoQW5kQWxpYXMoc3ViTmFtZSkuZmlsZVBhdGhOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkSW5DdXJyZW50UmVjdXJzaXZlU2VhcmNoLmhhcyhzYW5pdGl6ZWRTdWJOYW1lRm9yVHJhY2tpbmcpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdNYXBwaW5nID0gYWxpYXNNYXAuZ2V0KHN1Yk5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZVRvUXVldWUgPSBzdWJOYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZVRvUXVldWUgPSBleGlzdGluZ01hcHBpbmcuY2Fub25pY2FsTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViTmFtZSAhPT0gbmFtZVRvUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjaXNpb24gPSBgTWFwcGVkIGRpc2NvdmVyZWQgbmFtZSBcIiR7c3ViTmFtZX1cIiB0byBleGlzdGluZyBwcm9jZXNzb3IgXCIke25hbWVUb1F1ZXVlfVwiLmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlRGVjaXNpb25zTG9nLnB1c2goZGVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQncyBhIG5ldyBlbnRpdHksIGFkZCBpdCB0byBvdXIgbWFwIGZvciB0aGlzIHJ1biB0byBjYXRjaCBkdXBsaWNhdGVzIHdpdGhpbiB0aGUgc2FtZSBydW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZpbGVQYXRoTmFtZSwgb3JpZ2luYWxOYW1lQXNBbGlhcyB9ID0gdGhpcy5zYW5pdGl6ZU5hbWVGb3JGaWxlUGF0aEFuZEFsaWFzKHN1Yk5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhdGggPSBgJHt0aGlzLnNldHRpbmdzLnByb2Nlc3NvcnNGb2xkZXJQYXRofS8ke2ZpbGVQYXRoTmFtZX0ubWRgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzTWFwLnNldChzdWJOYW1lLnRvTG93ZXJDYXNlKCksIHsgcGF0aDogbmV3UGF0aCwgY2Fub25pY2FsTmFtZTogb3JpZ2luYWxOYW1lQXNBbGlhcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFxdWV1ZS5zb21lKHEgPT4gcS5wcm9jZXNzb3JOYW1lID09PSBuYW1lVG9RdWV1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHsgcHJvY2Vzc29yTmFtZTogbmFtZVRvUXVldWUsIGRlcHRoOiBkZXB0aCArIDEgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0U3VicHJvY2Vzc29ySW5mbyhwcm9jZXNzb3JOYW1lLCBjdXJyZW50UHJvY2Vzc29yRmlsZSwgc2VhcmNoRGF0YSwgaXNUb3BMZXZlbCwgbWVyZ2VEZWNpc2lvbnNMb2cpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlRGlzY292ZXJ5U3RhdHVzKGN1cnJlbnRQcm9jZXNzb3JGaWxlLCAnY29tcGxldGUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVEaXNjb3ZlcnlTdGF0dXMoY3VycmVudFByb2Nlc3NvckZpbGUsICdpbmNvbXBsZXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgbmV3IE5vdGljZShgUmVjdXJzaXZlIGRpc2NvdmVyeSBjb21wbGV0ZS4gUHJvY2Vzc2VkICR7ZGlzY292ZXJlZENvdW50fSBlbnRpdGllcywgc2tpcHBlZCAke3NraXBwZWRDb3VudH0gcmVjZW50IG9uZXMuYCwgMTAwMDApO1xuICAgICAgICB0aGlzLnByb2Nlc3NlZEluQ3VycmVudFJlY3Vyc2l2ZVNlYXJjaC5jbGVhcigpO1xuICAgIH1cblxuICAgIHByaXZhdGUgb3BlbkZpbGVTZWxlY3Rvck1lcmdlTW9kYWwoKSB7XG4gICAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpLmZpbHRlcihmaWxlID0+IGZpbGUucGF0aC5zdGFydHNXaXRoKHRoaXMuc2V0dGluZ3MucHJvY2Vzc29yc0ZvbGRlclBhdGggKyBcIi9cIikpO1xuICAgICAgICBpZiAoZmlsZXMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIlRoZXJlIGFyZSBub3QgZW5vdWdoIHByb2Nlc3NvciBmaWxlcyB0byBwZXJmb3JtIGEgbWVyZ2UuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3IEZpbGVTZWxlY3Rvck1lcmdlTW9kYWwodGhpcy5hcHAsIGZpbGVzLCAoc2VsZWN0ZWRGaWxlcykgPT4ge1xuICAgICAgICAgICAgLy8gQWZ0ZXIgdGhlIHVzZXIgc2VsZWN0cyBmaWxlcywgd2Ugb3BlbiB0aGUgc2Vjb25kIG1vZGFsIHRvIGNob29zZSB0aGUgc3Vydml2b3IuXG4gICAgICAgICAgICBuZXcgRm9yY2VNZXJnZU1vZGFsKHRoaXMuYXBwLCBzZWxlY3RlZEZpbGVzLCAoc3Vydml2b3IsIGR1cGxpY2F0ZXMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NNYW51YWxNZXJnZShzdXJ2aXZvciwgZHVwbGljYXRlcyk7XG4gICAgICAgICAgICB9KS5vcGVuKCk7XG4gICAgICAgIH0pLm9wZW4oKTtcbiAgICB9XG5cblxufVxuXG4vLyAtLS0tLSBNT0RBTCBDTEFTU0VTIC0tLS0tXG5jbGFzcyBNYW51YWxJbnB1dE1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICAgIHByb2Nlc3Nvck5hbWU6IHN0cmluZyA9ICcnO1xuICAgIGxpc3RVcmw6IHN0cmluZyA9ICcnO1xuICAgIGlzUHJpbWFyeVByb2Nlc3NvcjogYm9vbGVhbiA9IHRydWU7IC8vIDwtLSBOZXcgc3RhdGUgdmFyaWFibGUsIGRlZmF1bHRzIHRvIHRydWVcbiAgICBvblN1Ym1pdDogKHByb2Nlc3Nvck5hbWU6IHN0cmluZywgbGlzdFVybDogc3RyaW5nLCBpc1ByaW1hcnk6IGJvb2xlYW4pID0+IFByb21pc2U8dm9pZD47IC8vIDwtLSBVcGRhdGVkIHNpZ25hdHVyZVxuICAgIGluaXRpYWxQcm9jZXNzb3JOYW1lPzogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIG9uU3VibWl0OiAocHJvY2Vzc29yTmFtZTogc3RyaW5nLCBsaXN0VXJsOiBzdHJpbmcsIGlzUHJpbWFyeTogYm9vbGVhbikgPT4gUHJvbWlzZTx2b2lkPiwgaW5pdGlhbFByb2Nlc3Nvck5hbWU/OiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgdGhpcy5vblN1Ym1pdCA9IG9uU3VibWl0O1xuICAgICAgICB0aGlzLmluaXRpYWxQcm9jZXNzb3JOYW1lID0gaW5pdGlhbFByb2Nlc3Nvck5hbWU7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxQcm9jZXNzb3JOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3Nvck5hbWUgPSB0aGlzLmluaXRpYWxQcm9jZXNzb3JOYW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25PcGVuKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ01hbnVhbGx5IEFkZCBTdWJwcm9jZXNzb3IgTGlzdCBVUkwnIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdQcm9jZXNzb3IgTmFtZScpXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgdGhlIG5hbWUgb2YgdGhlIHByaW1hcnkgcHJvY2Vzc29yIChlLmcuLCBPcGVuQUkpLicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdFbnRlciBwcm9jZXNzb3IgbmFtZScpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnByb2Nlc3Nvck5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZSh2YWx1ZSA9PiB0aGlzLnByb2Nlc3Nvck5hbWUgPSB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgLmlucHV0RWwuc2V0QXR0cihcInJlcXVpcmVkXCIsIFwidHJ1ZVwiKTsgXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFByb2Nlc3Nvck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5zZXREaXNhYmxlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnU3VicHJvY2Vzc29yIExpc3QgVVJMJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdFbnRlciB0aGUgZGlyZWN0IFVSTCB0byB0aGUgc3VicHJvY2Vzc29yIGxpc3Qgb3IgRFBBIHBhZ2UuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT5cbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdodHRwczovL2V4YW1wbGUuY29tL3N1YnByb2Nlc3NvcnMnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5saXN0VXJsKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4gdGhpcy5saXN0VXJsID0gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5pbnB1dEVsLnNldEF0dHIoXCJyZXF1aXJlZFwiLCBcInRydWVcIikpO1xuXG4gICAgICAgIC8vIE5ldyBcIklzIFByaW1hcnlcIiBUb2dnbGUgU2V0dGluZ1xuICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnSXMgYSBwcmltYXJ5IHByb2Nlc3Nvcj8nKVxuICAgICAgICAgICAgLnNldERlc2MoJ0VuYWJsZSB0aGlzIGlmIHlvdSBhcmUgaW5pdGlhdGluZyBhIHNlYXJjaCBvbiB0aGlzIHByb2Nlc3Nvci4gRGlzYWJsZSBpZiB5b3UgYXJlIGFkZGluZyBhIHN1YnByb2Nlc3NvciBvZiBhbm90aGVyIGVudGl0eS4nKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMuaXNQcmltYXJ5UHJvY2Vzc29yKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZSh2YWx1ZSA9PiB0aGlzLmlzUHJpbWFyeVByb2Nlc3NvciA9IHZhbHVlKSk7XG5cblxuICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PlxuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdQcm9jZXNzIFVSTCcpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi4gdmFsaWRhdGlvbiBjaGVja3MgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU3VibWl0KHRoaXMucHJvY2Vzc29yTmFtZSwgdGhpcy5saXN0VXJsLCB0aGlzLmlzUHJpbWFyeVByb2Nlc3Nvcik7IC8vIDwtLSBQYXNzIHRoZSBuZXcgZmxhZ1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jb250ZW50RWwuZW1wdHkoKTtcbiAgICB9XG59XG5cbmNsYXNzIFNlYXJjaE1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICAgIHByb2Nlc3Nvck5hbWU6IHN0cmluZyA9ICcnO1xuICAgIHNldHRpbmdzOiBQcm9jZXNzb3JQcm9jZXNzb3JTZXR0aW5nczsgLy8gVG8gaW5mb3JtIHVzZXIgYWJvdXQgc2VhcmNoIG1ldGhvZFxuICAgIG9uU3VibWl0OiAocHJvY2Vzc29yTmFtZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHNldHRpbmdzOiBQcm9jZXNzb3JQcm9jZXNzb3JTZXR0aW5ncywgb25TdWJtaXQ6IChwcm9jZXNzb3JOYW1lOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4pIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLm9uU3VibWl0ID0gb25TdWJtaXQ7XG4gICAgfVxuXG4gICAgb25PcGVuKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0Rpc2NvdmVyIFN1YnByb2Nlc3NvcnMnIH0pO1xuXG4gICAgICAgIGxldCBzZWFyY2hNZXRob2ROb3RlID0gXCJTZWFyY2ggd2lsbCBiZSBwZXJmb3JtZWQgdXNpbmcgYXZhaWxhYmxlIGNvbmZpZ3VyZWQgbWV0aG9kcy5cIjtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2VycEFwaUtleSkge1xuICAgICAgICAgICAgc2VhcmNoTWV0aG9kTm90ZSA9IFwiU2VhcmNoIHdpbGwgcHJpbWFyaWx5IHVzZSBTZXJwQVBJLlwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MucmlnaHRicmFpbk9yZ0lkICYmIHRoaXMuc2V0dGluZ3MucmlnaHRicmFpblByb2plY3RJZCAmJiB0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5EdWNrRHVja0dvU2VhcmNoVGFza0lkKSB7XG4gICAgICAgICAgICBzZWFyY2hNZXRob2ROb3RlID0gXCJTZXJwQVBJIGtleSBub3QgZm91bmQuIFNlYXJjaCB3aWxsIHVzZSBEdWNrRHVja0dvIHZpYSBSaWdodEJyYWluLlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VhcmNoTWV0aG9kTm90ZSA9IFwiTmVpdGhlciBTZXJwQVBJIG5vciBSaWdodEJyYWluIER1Y2tEdWNrR28gc2VhcmNoIGlzIGZ1bGx5IGNvbmZpZ3VyZWQuIERpc2NvdmVyeSBtaWdodCBiZSBsaW1pdGVkLlwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogc2VhcmNoTWV0aG9kTm90ZSB9KTtcblxuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdQcm9jZXNzb3IgTmFtZScpXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgdGhlIG5hbWUgb2YgdGhlIHByb2Nlc3NvciB0byBzZWFyY2ggZm9yIChlLmcuLCBTdHJpcGUpLicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignRW50ZXIgcHJvY2Vzc29yIG5hbWUnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wcm9jZXNzb3JOYW1lKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4gdGhpcy5wcm9jZXNzb3JOYW1lID0gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5pbnB1dEVsLnNldEF0dHIoXCJyZXF1aXJlZFwiLCBcInRydWVcIikpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+XG4gICAgICAgICAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoJ1N0YXJ0IERpc2NvdmVyeScpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc29yTmFtZS50cmltKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiUHJvY2Vzc29yIE5hbWUgaXMgcmVxdWlyZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TdWJtaXQodGhpcy5wcm9jZXNzb3JOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY29udGVudEVsLmVtcHR5KCk7XG4gICAgfVxufVxuXG5jbGFzcyBNYW51YWxUZXh0RW50cnlNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgICBwcm9jZXNzb3JOYW1lOiBzdHJpbmcgPSAnJztcbiAgICBwYXN0ZWRUZXh0OiBzdHJpbmcgPSAnJztcbiAgICBpc1ByaW1hcnlQcm9jZXNzb3I6IGJvb2xlYW4gPSB0cnVlOyAvLyA8LS0gTmV3IHN0YXRlIHZhcmlhYmxlLCBkZWZhdWx0cyB0byB0cnVlXG4gICAgb25TdWJtaXQ6IChwcm9jZXNzb3JOYW1lOiBzdHJpbmcsIHBhc3RlZFRleHQ6IHN0cmluZywgaXNQcmltYXJ5OiBib29sZWFuKSA9PiBQcm9taXNlPHZvaWQ+OyAvLyA8LS0gVXBkYXRlZCBzaWduYXR1cmVcbiAgICBpbml0aWFsUHJvY2Vzc29yTmFtZT86IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBvblN1Ym1pdDogKHByb2Nlc3Nvck5hbWU6IHN0cmluZywgcGFzdGVkVGV4dDogc3RyaW5nLCBpc1ByaW1hcnk6IGJvb2xlYW4pID0+IFByb21pc2U8dm9pZD4sIGluaXRpYWxQcm9jZXNzb3JOYW1lPzogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKGFwcCk7XG4gICAgICAgIHRoaXMub25TdWJtaXQgPSBvblN1Ym1pdDtcbiAgICAgICAgdGhpcy5pbml0aWFsUHJvY2Vzc29yTmFtZSA9IGluaXRpYWxQcm9jZXNzb3JOYW1lO1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsUHJvY2Vzc29yTmFtZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzb3JOYW1lID0gdGhpcy5pbml0aWFsUHJvY2Vzc29yTmFtZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdJbnB1dCBTdWJwcm9jZXNzb3IgTGlzdCBmcm9tIFRleHQnIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdQcm9jZXNzb3IgTmFtZScpXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgdGhlIG5hbWUgb2YgdGhlIHByaW1hcnkgcHJvY2Vzc29yIHRoaXMgdGV4dCBiZWxvbmdzIHRvLicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICB0ZXh0LnNldFBsYWNlaG9sZGVyKCdFbnRlciBwcm9jZXNzb3IgbmFtZScpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnByb2Nlc3Nvck5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZSh2YWx1ZSA9PiB0aGlzLnByb2Nlc3Nvck5hbWUgPSB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgLmlucHV0RWwuc2V0QXR0cihcInJlcXVpcmVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbml0aWFsUHJvY2Vzc29yTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0LnNldERpc2FibGVkKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnSXMgYSBwcmltYXJ5IHByb2Nlc3Nvcj8nKVxuICAgICAgICAgICAgLnNldERlc2MoJ0VuYWJsZSB0aGlzIGlmIHlvdSBhcmUgaW5pdGlhdGluZyBhIHNlYXJjaCBvbiB0aGlzIHByb2Nlc3Nvci4gRGlzYWJsZSBpZiB5b3UgYXJlIGFkZGluZyBhIHN1YnByb2Nlc3NvciBvZiBhbm90aGVyIGVudGl0eS4nKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMuaXNQcmltYXJ5UHJvY2Vzc29yKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZSh2YWx1ZSA9PiB0aGlzLmlzUHJpbWFyeVByb2Nlc3NvciA9IHZhbHVlKSk7XG5cbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnUGFzdGUgdGhlIHN1YnByb2Nlc3NvciBsaXN0IHRleHQgYmVsb3c6JyB9KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRleHRBcmVhID0gbmV3IFRleHRBcmVhQ29tcG9uZW50KGNvbnRlbnRFbClcbiAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignUGFzdGUgdGV4dCBoZXJlLi4uJylcbiAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBhc3RlZFRleHQpXG4gICAgICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4gdGhpcy5wYXN0ZWRUZXh0ID0gdmFsdWUpO1xuICAgICAgICB0ZXh0QXJlYS5pbnB1dEVsLnJvd3MgPSAxMDtcbiAgICAgICAgdGV4dEFyZWEuaW5wdXRFbC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgdGV4dEFyZWEuaW5wdXRFbC5zZXRBdHRyKFwicmVxdWlyZWRcIiwgXCJ0cnVlXCIpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+XG4gICAgICAgICAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoJ1Byb2Nlc3MgVGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi4gdmFsaWRhdGlvbiBjaGVja3MgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU3VibWl0KHRoaXMucHJvY2Vzc29yTmFtZSwgdGhpcy5wYXN0ZWRUZXh0LCB0aGlzLmlzUHJpbWFyeVByb2Nlc3Nvcik7IC8vIDwtLSBQYXNzIHRoZSBuZXcgZmxhZ1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jb250ZW50RWwuZW1wdHkoKTtcbiAgICB9XG59XG5cbmNsYXNzIEZvcmNlTWVyZ2VNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgICBmaWxlczogVEZpbGVbXTtcbiAgICBvblN1Ym1pdDogKHN1cnZpdm9yOiBURmlsZSwgZHVwbGljYXRlczogVEZpbGVbXSkgPT4gdm9pZDtcbiAgICBwcml2YXRlIHN1cnZpdm9yOiBURmlsZSB8IG51bGwgPSBudWxsO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGZpbGVzOiBURmlsZVtdLCBvblN1Ym1pdDogKHN1cnZpdm9yOiBURmlsZSwgZHVwbGljYXRlczogVEZpbGVbXSkgPT4gdm9pZCkge1xuICAgICAgICBzdXBlcihhcHApO1xuICAgICAgICAvLyBFbnN1cmUgZmlsZXMgYXJlIHNvcnRlZCBhbHBoYWJldGljYWxseSBmb3IgdGhlIHVzZXJcbiAgICAgICAgdGhpcy5maWxlcyA9IGZpbGVzLnNvcnQoKGEsIGIpID0+IGEuYmFzZW5hbWUubG9jYWxlQ29tcGFyZShiLmJhc2VuYW1lKSk7XG4gICAgICAgIHRoaXMub25TdWJtaXQgPSBvblN1Ym1pdDtcbiAgICB9XG5cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnRm9yY2UgTWVyZ2UgUHJvY2Vzc29ycycgfSk7XG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogJ1NlbGVjdCB0aGUgZmlsZSB0byBrZWVwICh0aGUgXCJzdXJ2aXZvclwiKS4gQWxsIG90aGVyIHNlbGVjdGVkIGZpbGVzIHdpbGwgYmUgbWVyZ2VkIGludG8gaXQgYW5kIHRoZW4gZGVsZXRlZC4nIH0pO1xuICAgIFxuICAgICAgICBsZXQgbWVyZ2VCdXR0b246IEJ1dHRvbkNvbXBvbmVudDtcbiAgICBcbiAgICAgICAgY29uc3QgcmFkaW9Hcm91cCA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoKTtcbiAgICBcbiAgICAgICAgdGhpcy5maWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZyA9IG5ldyBTZXR0aW5nKHJhZGlvR3JvdXApXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoZmlsZS5iYXNlbmFtZSlcbiAgICAgICAgICAgICAgICAuc2V0RGVzYyhmaWxlLnBhdGgpO1xuICAgIFxuICAgICAgICAgICAgLy8gVGhpcyBjcmVhdGVzIGEgUkFESU8gQlVUVE9OIGZvciBzaW5nbGUgc2VsZWN0aW9uXG4gICAgICAgICAgICBjb25zdCByYWRpbyA9IGNyZWF0ZUVsKCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmFkaW8nLFxuICAgICAgICAgICAgICAgIGNsczogJ2ZvcmNlLW1lcmdlLXJhZGlvJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByYWRpby5uYW1lID0gXCJzdXJ2aXZvci1zZWxlY3Rpb25cIjtcbiAgICAgICAgICAgIHJhZGlvLnZhbHVlID0gZmlsZS5wYXRoO1xuICAgICAgICAgICAgcmFkaW8ub25jaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdXJ2aXZvciA9IGZpbGU7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb3JyZWN0bHkgZW5hYmxlcyB0aGUgbWVyZ2UgYnV0dG9uXG4gICAgICAgICAgICAgICAgbWVyZ2VCdXR0b24uc2V0RGlzYWJsZWQoZmFsc2UpLnNldEN0YSh0cnVlKTtcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBzZXR0aW5nLmNvbnRyb2xFbC5hcHBlbmRDaGlsZChyYWRpbyk7XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ0biA9PiBidG5cbiAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnQ2FuY2VsJylcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB0aGlzLmNsb3NlKCkpKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidG4gPT4ge1xuICAgICAgICAgICAgICAgIG1lcmdlQnV0dG9uID0gYnRuO1xuICAgICAgICAgICAgICAgIGJ0bi5zZXRCdXR0b25UZXh0KCdNZXJnZScpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdXJ2aXZvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cGxpY2F0ZXMgPSB0aGlzLmZpbGVzLmZpbHRlcihmID0+IGYucGF0aCAhPT0gdGhpcy5zdXJ2aXZvciEucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TdWJtaXQodGhpcy5zdXJ2aXZvciwgZHVwbGljYXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jb250ZW50RWwuZW1wdHkoKTtcbiAgICB9XG59XG5cbmNsYXNzIEZpbGVTZWxlY3Rvck1lcmdlTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gICAgZmlsZXM6IFRGaWxlW107XG4gICAgb25TdWJtaXQ6IChzZWxlY3RlZEZpbGVzOiBURmlsZVtdKSA9PiB2b2lkO1xuICAgIHByaXZhdGUgc2VsZWN0ZWRGaWxlUGF0aHM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGZpbGVzOiBURmlsZVtdLCBvblN1Ym1pdDogKHNlbGVjdGVkRmlsZXM6IFRGaWxlW10pID0+IHZvaWQpIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgdGhpcy5maWxlcyA9IGZpbGVzLnNvcnQoKGEsIGIpID0+IGEuYmFzZW5hbWUubG9jYWxlQ29tcGFyZShiLmJhc2VuYW1lKSk7XG4gICAgICAgIHRoaXMub25TdWJtaXQgPSBvblN1Ym1pdDtcbiAgICB9XG5cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnU2VsZWN0IEZpbGVzIHRvIE1lcmdlJyB9KTtcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiAnQ2hvb3NlIHR3byBvciBtb3JlIHByb2Nlc3NvciBmaWxlcyBmcm9tIHRoZSBsaXN0IGJlbG93LicgfSk7XG4gICAgXG4gICAgICAgIGxldCBuZXh0QnV0dG9uOiBCdXR0b25Db21wb25lbnQ7XG4gICAgXG4gICAgICAgIGNvbnN0IGNoZWNrYm94R3JvdXAgPSBjb250ZW50RWwuY3JlYXRlRGl2KCk7XG4gICAgICAgIGNoZWNrYm94R3JvdXAuYWRkQ2xhc3MoJ3Byb2Nlc3Nvci1maWxlLXNlbGVjdG9yLWxpc3QnKTtcbiAgICBcbiAgICAgICAgdGhpcy5maWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZyA9IG5ldyBTZXR0aW5nKGNoZWNrYm94R3JvdXApXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoZmlsZS5iYXNlbmFtZSlcbiAgICAgICAgICAgICAgICAuc2V0RGVzYyhmaWxlLnBhdGgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUaGlzIGNyZWF0ZXMgYSBDSEVDS0JPWCBmb3IgbXVsdGlwbGUgc2VsZWN0aW9uc1xuICAgICAgICAgICAgc2V0dGluZy5hZGRUb2dnbGUodG9nZ2xlID0+IHtcbiAgICAgICAgICAgICAgICB0b2dnbGUub25DaGFuZ2UodmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRGaWxlUGF0aHMuYWRkKGZpbGUucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRmlsZVBhdGhzLmRlbGV0ZShmaWxlLnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY29ycmVjdGx5IGVuYWJsZXMgdGhlIGJ1dHRvbiB3aGVuIDIgb3IgbW9yZSBhcmUgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgbmV4dEJ1dHRvbi5zZXREaXNhYmxlZCh0aGlzLnNlbGVjdGVkRmlsZVBhdGhzLnNpemUgPCAyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidG4gPT4gYnRuXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0NhbmNlbCcpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4gdGhpcy5jbG9zZSgpKSlcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnRuID0+IHtcbiAgICAgICAgICAgICAgICBuZXh0QnV0dG9uID0gYnRuO1xuICAgICAgICAgICAgICAgIGJ0bi5zZXRCdXR0b25UZXh0KCdOZXh0OiBTZWxlY3QgU3Vydml2b3InKVxuICAgICAgICAgICAgICAgICAgICAuc2V0Q3RhKClcbiAgICAgICAgICAgICAgICAgICAgLnNldERpc2FibGVkKHRydWUpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkRmlsZXMgPSB0aGlzLmZpbGVzLmZpbHRlcihmID0+IHRoaXMuc2VsZWN0ZWRGaWxlUGF0aHMuaGFzKGYucGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblN1Ym1pdChzZWxlY3RlZEZpbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIFBhc3RlRW52TW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gICAgcGFzdGVkVGV4dDogc3RyaW5nID0gJyc7XG4gICAgcGx1Z2luOiBQcm9jZXNzb3JQcm9jZXNzb3JQbHVnaW47XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBQcm9jZXNzb3JQcm9jZXNzb3JQbHVnaW4pIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgfVxuXG4gICAgb25PcGVuKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0NvbXBsZXRlIFBsdWdpbiBTZXR1cCcgfSk7XG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogJ1Bhc3RlIHRoZSBlbnRpcmUgYmxvY2sgb2YgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZyb20geW91ciBSaWdodEJyYWluIGRhc2hib2FyZCBiZWxvdy4gVGhpcyB3aWxsIHNhdmUgeW91ciBjcmVkZW50aWFscyBhbmQgdGhlbiBhdXRvbWF0aWNhbGx5IGNyZWF0ZSB0aGUgbmVjZXNzYXJ5IEFJIHRhc2tzIGluIHlvdXIgcHJvamVjdC4nIH0pO1xuXG4gICAgICAgIGNvbnN0IHRleHRBcmVhID0gbmV3IFRleHRBcmVhQ29tcG9uZW50KGNvbnRlbnRFbClcbiAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignUkJfT1JHX0lEPVwiLi4uXCJcXG5SQl9QUk9KRUNUX0lEPVwiLi4uXCInKVxuICAgICAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHRoaXMucGFzdGVkVGV4dCA9IHZhbHVlKTtcbiAgICAgICAgdGV4dEFyZWEuaW5wdXRFbC5yb3dzID0gMTI7XG4gICAgICAgIHRleHRBcmVhLmlucHV0RWwuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHRleHRBcmVhLmlucHV0RWwuc3R5bGUuZm9udEZhbWlseSA9ICdtb25vc3BhY2UnO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+XG4gICAgICAgICAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoJ0JlZ2luIFNldHVwJylcbiAgICAgICAgICAgICAgICAgICAgLnNldEN0YSgpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhc3RlZFRleHQudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBub3cgdHJpZ2dlcnMgdGhlIGVudGlyZSBzZXR1cCBmbG93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5GdWxsU2V0dXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJUZXh0IGFyZWEgaXMgZW1wdHkuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jb250ZW50RWwuZW1wdHkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIHBhc3RlZCB0ZXh0LCBzYXZlcyBjcmVkZW50aWFscywgdGhlbiBwcm9jZWVkcyB0byBzZXQgdXAgdGFza3MuXG4gICAgICovXG4gICAgYXN5bmMgcnVuRnVsbFNldHVwKCkge1xuICAgICAgICAvLyAtLS0gUGFydCAxOiBQYXJzZSBhbmQgU2F2ZSBDcmVkZW50aWFscyAtLS1cbiAgICAgICAgY29uc3QgbGluZXMgPSB0aGlzLnBhc3RlZFRleHQudHJpbSgpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3NUb1VwZGF0ZTogUGFydGlhbDxQcm9jZXNzb3JQcm9jZXNzb3JTZXR0aW5ncz4gPSB7fTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGtleU1hcDogeyBba2V5OiBzdHJpbmddOiBrZXlvZiBQcm9jZXNzb3JQcm9jZXNzb3JTZXR0aW5ncyB9ID0ge1xuICAgICAgICAgICAgJ1JCX09SR19JRCc6ICdyaWdodGJyYWluT3JnSWQnLFxuICAgICAgICAgICAgJ1JCX1BST0pFQ1RfSUQnOiAncmlnaHRicmFpblByb2plY3RJZCcsXG4gICAgICAgICAgICAnUkJfQ0xJRU5UX0lEJzogJ3JpZ2h0YnJhaW5DbGllbnRJZCcsXG4gICAgICAgICAgICAnUkJfQ0xJRU5UX1NFQ1JFVCc6ICdyaWdodGJyYWluQ2xpZW50U2VjcmV0JyxcbiAgICAgICAgICAgICdSQl9BUElfVVJMJzogJ3JpZ2h0YnJhaW5BcGlVcmwnLFxuICAgICAgICAgICAgJ1JCX09BVVRIMl9VUkwnOiAncmlnaHRicmFpbk9hdXRoMlVybCdcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoJz0nKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPCAyKSBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhcnRzWzBdLnRyaW0oKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHBhcnRzLnNsaWNlKDEpLmpvaW4oJz0nKS50cmltKCkucmVwbGFjZSgvW1wiJ10vZywgJycpO1xuICAgIFxuICAgICAgICAgICAgaWYgKGtleSBpbiBrZXlNYXAgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5nS2V5ID0ga2V5TWFwW2tleV07XG4gICAgICAgICAgICAgICAgKHNldHRpbmdzVG9VcGRhdGUgYXMgYW55KVtzZXR0aW5nS2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGZvdW5kIGFsbCB0aGUga2V5cyB3ZSBuZWVkXG4gICAgICAgIGlmICghc2V0dGluZ3NUb1VwZGF0ZS5yaWdodGJyYWluT3JnSWQgfHwgIXNldHRpbmdzVG9VcGRhdGUucmlnaHRicmFpblByb2plY3RJZCB8fCAhc2V0dGluZ3NUb1VwZGF0ZS5yaWdodGJyYWluQ2xpZW50SWQgfHwgIXNldHRpbmdzVG9VcGRhdGUucmlnaHRicmFpbkNsaWVudFNlY3JldCB8fCAhc2V0dGluZ3NUb1VwZGF0ZS5yaWdodGJyYWluQXBpVXJsIHx8ICFzZXR0aW5nc1RvVXBkYXRlLnJpZ2h0YnJhaW5PYXV0aDJVcmwpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJTZXR1cCBmYWlsZWQuIFBhc3RlZCB0ZXh0IGlzIG1pc3Npbmcgb25lIG9yIG1vcmUgcmVxdWlyZWQgdmFsdWVzLlwiLCA3MDAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHRoaXMucGx1Z2luLnNldHRpbmdzLCBzZXR0aW5nc1RvVXBkYXRlKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgIG5ldyBOb3RpY2UoYFN1Y2Nlc3NmdWxseSB1cGRhdGVkIGNyZWRlbnRpYWxzLmApO1xuICAgIFxuICAgICAgICAvLyAtLS0gUGFydCAyOiBDYWxsIHRoZSBUYXNrIFNldHVwIExvZ2ljIHdpdGggdGhlIG5ldyB2YWx1ZXMgLS0tXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBQYXNzIHRoZSBuZXdseSBwYXJzZWQgY3JlZGVudGlhbHMgZGlyZWN0bHkgdG8gdGhlIHNldHVwIGZ1bmN0aW9uXG4gICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNldHVwUmlnaHRCcmFpblRhc2tzKHtcbiAgICAgICAgICAgIGFwaVVybDogc2V0dGluZ3NUb1VwZGF0ZS5yaWdodGJyYWluQXBpVXJsLFxuICAgICAgICAgICAgb2F1dGhVcmw6IHNldHRpbmdzVG9VcGRhdGUucmlnaHRicmFpbk9hdXRoMlVybCxcbiAgICAgICAgICAgIGNsaWVudElkOiBzZXR0aW5nc1RvVXBkYXRlLnJpZ2h0YnJhaW5DbGllbnRJZCxcbiAgICAgICAgICAgIGNsaWVudFNlY3JldDogc2V0dGluZ3NUb1VwZGF0ZS5yaWdodGJyYWluQ2xpZW50U2VjcmV0LFxuICAgICAgICAgICAgb3JnSWQ6IHNldHRpbmdzVG9VcGRhdGUucmlnaHRicmFpbk9yZ0lkLFxuICAgICAgICAgICAgcHJvamVjdElkOiBzZXR0aW5nc1RvVXBkYXRlLnJpZ2h0YnJhaW5Qcm9qZWN0SWRcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cbi8vIC0tLS0tIFNFVFRJTkdTIFRBQiBDTEFTUyAtLS0tLVxuY2xhc3MgUHJvY2Vzc29yUHJvY2Vzc29yU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICAgIHBsdWdpbjogUHJvY2Vzc29yUHJvY2Vzc29yUGx1Z2luO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogUHJvY2Vzc29yUHJvY2Vzc29yUGx1Z2luKSB7XG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgfVxuXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnUHJvY2Vzc29yIFByb2Nlc3NvciBTZXR0aW5ncycgfSk7XG5cbiAgICAgICAgLy8gLS0tIEFQSSBLZXlzICYgQ3JlZGVudGlhbHMgLS0tXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ0FQSSBLZXlzICYgQ3JlZGVudGlhbHMnIH0pO1xuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdTZXJwQVBJIEtleScpXG4gICAgICAgICAgICAuc2V0RGVzYygnWW91ciBTZXJwQVBJIEtleSBmb3IgR29vZ2xlIHNlYXJjaCBmdW5jdGlvbmFsaXR5LicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHlvdXIgU2VycEFQSSBrZXknKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZXJwQXBpS2V5KVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VycEFwaUtleSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICAvLyAtLS0gUmlnaHRCcmFpbiBDb25maWd1cmF0aW9uIC0tLVxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdSaWdodEJyYWluIFRhc2sgQ29uZmlndXJhdGlvbicgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUkIgRXh0cmFjdCBFbnRpdGllczogSW5wdXQgRmllbGQgTmFtZScpXG4gICAgICAgICAgICAuc2V0RGVzYygnVGhlIHBhcmFtZXRlciBuYW1lIHlvdXIgUkIgRXh0cmFjdCBFbnRpdGllcyB0YXNrIGV4cGVjdHMgZm9yIHRoZSBpbnB1dCB0ZXh0IChlLmcuLCBcInBhZ2VfdGV4dFwiLCBcImRvY3VtZW50X2NvbnRlbnRcIikuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yaWdodGJyYWluRXh0cmFjdElucHV0RmllbGQpXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdlLmcuLCBwYWdlX3RleHQnKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmlnaHRicmFpbkV4dHJhY3RJbnB1dEZpZWxkID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1JCIEV4dHJhY3QgRW50aXRpZXM6IE91dHB1dCBGaWVsZCAoVGhpcmQtUGFydHkpJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgZmllbGQgbmFtZSBpbiB5b3VyIFJCIEV4dHJhY3QgRW50aXRpZXMgdGFza1xcJ3MgSlNPTiBvdXRwdXQgZm9yIHRoZSBsaXN0IG9mIHRoaXJkLXBhcnR5IHN1YnByb2Nlc3NvcnMgKGUuZy4sIFwidGhpcmRfcGFydHlfc3VicHJvY2Vzc29yc1wiKS4nKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnJpZ2h0YnJhaW5FeHRyYWN0T3V0cHV0VGhpcmRQYXJ0eUZpZWxkKVxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignZS5nLiwgdGhpcmRfcGFydHlfc3VicHJvY2Vzc29ycycpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5yaWdodGJyYWluRXh0cmFjdE91dHB1dFRoaXJkUGFydHlGaWVsZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUkIgRXh0cmFjdCBFbnRpdGllczogT3V0cHV0IEZpZWxkIChPd24gRW50aXRpZXMpJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgZmllbGQgbmFtZSBpbiB5b3VyIFJCIEV4dHJhY3QgRW50aXRpZXMgdGFza1xcJ3MgSlNPTiBvdXRwdXQgZm9yIHRoZSBsaXN0IG9mIG93bi9hZmZpbGlhdGVkIGVudGl0aWVzIChlLmcuLCBcIm93bl9lbnRpdGllc1wiKS4nKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnJpZ2h0YnJhaW5FeHRyYWN0T3V0cHV0T3duRW50aXRpZXNGaWVsZClcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ2UuZy4sIG93bl9lbnRpdGllcycpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5yaWdodGJyYWluRXh0cmFjdE91dHB1dE93bkVudGl0aWVzRmllbGQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG5cbiAgICAgICAgLy8gLS0tIEdlbmVyYWwgU2V0dGluZ3MgLS0tXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ0dlbmVyYWwgU2V0dGluZ3MnIH0pO1xuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdDcmVhdGUgUGFnZXMgZm9yIE93biBFbnRpdGllcycpXG4gICAgICAgICAgICAuc2V0RGVzYygnSWYgZW5hYmxlZCwgc2VwYXJhdGUgTWFya2Rvd24gcGFnZXMgd2lsbCBhbHNvIGJlIGNyZWF0ZWQgZm9yIFwib3duIGVudGl0aWVzXCIgaWRlbnRpZmllZCBkdXJpbmcgcHJvY2Vzc2luZywgbm90IGp1c3QgdGhpcmQtcGFydHkgc3VicHJvY2Vzc29ycy4nKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmNyZWF0ZVBhZ2VzRm9yT3duRW50aXRpZXMpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jcmVhdGVQYWdlc0Zvck93bkVudGl0aWVzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1ZlcmJvc2UgRGVidWcgTG9nZ2luZycpXG4gICAgICAgICAgICAuc2V0RGVzYygnRW5hYmxlIGRldGFpbGVkIGxvZ2dpbmcgdG8gdGhlIGRldmVsb3BlciBjb25zb2xlIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuJylcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy52ZXJib3NlRGVidWcpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy52ZXJib3NlRGVidWcgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICBcbiAgICAgICAgLy8gbWF4UmVzdWx0c1BlclByb2Nlc3NvciBpcyBub3QgdHlwaWNhbGx5IHVzZXItY29uZmlndXJhYmxlIGlmIGl0J3MgZml4ZWQgZm9yIFwic3RvcCBvbiBmaXJzdCB0cnVlL3RydWVcIiBsb2dpY1xuICAgICAgICAvLyBJZiBpdCB3ZXJlLCBpdCB3b3VsZCBiZSBhbiBhZGRUZXh0IG9yIGFkZFNsaWRlclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdNYXggUmVzdWx0cyBQZXIgUHJvY2Vzc29yIChEaXNjb3ZlcnkpJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdNYXhpbXVtIHNlYXJjaCByZXN1bHRzIHRvIHByb2Nlc3MgZm9yIGVhY2ggcHJvY2Vzc29yIGR1cmluZyBpbml0aWFsIGRpc2NvdmVyeS4gQ3VycmVudGx5LCB0aGUgbG9naWMgc3RvcHMgb24gdGhlIGZpcnN0IHZlcmlmaWVkIGxpc3QsIGVmZmVjdGl2ZWx5IG1ha2luZyB0aGlzIDEuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5tYXhSZXN1bHRzUGVyUHJvY2Vzc29yLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgLnNldERpc2FibGVkKHRydWUpIC8vIFNpbmNlIHRoZSBsb2dpYyBpcyBoYXJkY29kZWQgdG8gc3RvcCBvbiBmaXJzdCB2ZXJpZmllZFxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzZXR0aW5nIGlzIG1vc3RseSBpbmZvcm1hdGlvbmFsIGR1ZSB0byBjdXJyZW50IGxvZ2ljXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IG51bSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKCFpc05hTihudW0pICYmIG51bSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm1heFJlc3VsdHNQZXJQcm9jZXNzb3IgPSBudW07XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdNYXBwaW5nIERlcHRoJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdTZXQgdGhlIG1heGltdW0gZGVwdGggZm9yIHRoZSBNYXAgU3VicHJvY2Vzc29yIFJlbGF0aW9uc2hpcHMgZnVuY3Rpb24gKGUuZy4sIDItNSkuIEhpZ2hlciBudW1iZXJzIHdpbGwgdGFrZSBtdWNoIGxvbmdlciBhbmQgdXNlIG1vcmUgQVBJIGNhbGxzLicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ2UuZy4sIDMnKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5tYXhSZWN1cnNpdmVEZXB0aC50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKG51bSkgJiYgbnVtID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubWF4UmVjdXJzaXZlRGVwdGggPSBudW07XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgICAgICAgICAgLnNldE5hbWUoJ0Rpc2NvdmVyeSBDYWNoZSBEdXJhdGlvbiAoRGF5cyknKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RGVzYygnSG93IG1hbnkgZGF5cyB0byBjb25zaWRlciBhIHByb2Nlc3NvclxcJ3MgZGF0YSBcImZyZXNoXCIuIEEgcHJvY2Vzc29yIHdpdGggYSBcImNvbXBsZXRlXCIgc3RhdHVzIGRpc2NvdmVyZWQgd2l0aGluIHRoaXMgcGVyaW9kIHdpbGwgYmUgc2tpcHBlZCBkdXJpbmcgcmVjdXJzaXZlIHJ1bnMuJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ2UuZy4sIDMwJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kaXNjb3ZlcnlDYWNoZURheXMudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBudW0gPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihudW0pICYmIG51bSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRpc2NvdmVyeUNhY2hlRGF5cyA9IG51bTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1Byb2Nlc3NvcnMgRm9sZGVyIFBhdGgnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSBwcm9jZXNzb3IgYW5kIHN1YnByb2Nlc3NvciBub3RlcyB3aWxsIGJlIHN0b3JlZCAoZS5nLiwgXCJUaGlyZCBQYXJ0aWVzL1Byb2Nlc3NvcnNcIikuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignZS5nLiwgUHJvY2Vzc29ycycpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2Nlc3NvcnNGb2xkZXJQYXRoKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvY2Vzc29yc0ZvbGRlclBhdGggPSB2YWx1ZSB8fCBERUZBVUxUX1NFVFRJTkdTLnByb2Nlc3NvcnNGb2xkZXJQYXRoO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnQW5hbHlzaXMgTG9ncyBGb2xkZXIgUGF0aCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIGFuYWx5c2lzIGxvZyBub3RlcyBmb3IgZWFjaCBwcm9jZXNzb3Igd2lsbCBiZSBzdG9yZWQgKGUuZy4sIFwiQ29tcGxpYW5jZS9Mb2dzXCIpLicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ2UuZy4sIEFuYWx5c2lzIExvZ3MnKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5hbmFseXNpc0xvZ3NGb2xkZXJQYXRoKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYW5hbHlzaXNMb2dzRm9sZGVyUGF0aCA9IHZhbHVlIHx8IERFRkFVTFRfU0VUVElOR1MuYW5hbHlzaXNMb2dzRm9sZGVyUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgIH1cbn1cbiIsICJbXG4gIHtcbiAgICBcIm5hbWVcIjogXCJWZXJpZnkgU3VicHJvY2Vzc29yIExpc3QgVVJMXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkNoZWNrcyBpZiBhIFVSTCBwb2ludHMgdG8gYSBjdXJyZW50IGFuZCB2YWxpZCBzdWJwcm9jZXNzb3IgbGlzdCBmb3IgYSBzcGVjaWZpYyBjb21wYW55LlwiLFxuICAgIFwic3lzdGVtX3Byb21wdFwiOiBcIllvdSBhcmUgYW4gZXhwZXJ0IGluIGRhdGEgcHJpdmFjeSBhbmQgY29tcGxpYW5jZSBkb2N1bWVudGF0aW9uIGFuYWx5c2lzLlwiLFxuICAgIFwidXNlcl9wcm9tcHRcIjogXCJHb2FsOiBZb3VyIHByaW1hcnkgZ29hbCBpcyB0byBkZXRlcm1pbmUgaWYgdGhlIHByb3ZpZGVkIHRleHQgZnJvbSB7dXJsX2NvbnRlbnR9IGlzIGEgc3VicHJvY2Vzc29yIGxpc3QgdGhhdCBiZWxvbmdzIHRvIHRoZSB7ZXhwZWN0ZWRfcHJvY2Vzc29yX25hbWV9IGFuZCBpcyB0aGUgY3VycmVudCwgYWN0aXZlIHZlcnNpb24uXFxuXFxuSW5wdXQgUGFyYW1ldGVyczpcXG5cXG57dXJsX2NvbnRlbnR9OiBUaGUgdGV4dCBjb250ZW50IGZyb20gYSBVUkwuXFxuXFxue2V4cGVjdGVkX3Byb2Nlc3Nvcl9uYW1lfTogVGhlIG5hbWUgb2YgdGhlIGNvbXBhbnkgZm9yIHdob20geW91IGFyZSB0cnlpbmcgdG8gZmluZCB0aGUgc3VicHJvY2Vzc29yIGxpc3QuXFxuXFxuQ1JJVElDQUwgUlVMRTogVGhlIHBhZ2UgbXVzdCBiZWxvbmcgdG8gdGhlIHtleHBlY3RlZF9wcm9jZXNzb3JfbmFtZX0gYXMgdGhlIHByaW1hcnkgY29tcGFueS4gRG8gTk9UIHJldHVybiAnaXNDb3JyZWN0UHJvY2Vzc29yOiB0cnVlJyBpZiB7ZXhwZWN0ZWRfcHJvY2Vzc29yX25hbWV9IGlzIG9ubHkgbWVudGlvbmVkIGFzIGEgc3ViLXByb2Nlc3NvciBvZiBhbm90aGVyIGNvbXBhbnkuIEZvciBleGFtcGxlLCBpZiBzZWFyY2hpbmcgZm9yICdBcHBsZScgYW5kIHlvdSBmaW5kIGEgbGlzdCBvd25lZCBieSAnQ29tbWFuZCBBbGtvbicgdGhhdCBsaXN0cyBBcHBsZSBhcyBvbmUgb2YgaXRzIHN1YnByb2Nlc3NvcnMsICdpc0NvcnJlY3RQcm9jZXNzb3InIE1VU1QgYmUgZmFsc2UuXFxuXFxuUHJvY2Vzc2luZyBTdGVwczpcXG5cXG4xLiBJcyBpdCBhIFN1YnByb2Nlc3NvciBMaXN0P1xcbi0gU2NhbiBmb3IgZXhwbGljaXQgdGl0bGVzIChlLmcuLCBcXFwiU3VicHJvY2Vzc29yIExpc3RcXFwiKS5cXG4tIExvb2sgZm9yIGEgc3RydWN0dXJlZCBsaXN0L3RhYmxlIG9mIG11bHRpcGxlIGRpc3RpbmN0IGNvbXBhbnkgbmFtZXMuXFxuLSBJZiBpdCBpcyBub3QgYSBzdWJwcm9jZXNzb3IgbGlzdCwgYWxsIG90aGVyIGNoZWNrcyBhcmUgaXJyZWxldmFudC5cXG5cXG4yLiBJcyBpdCBmb3IgdGhlIENvcnJlY3QgQ29tcGFueT9cXG4tIE9OTFkgaWYgaXQgaXMgYSBzdWJwcm9jZXNzb3IgbGlzdCwgYW5hbHl6ZSB0aGUgcGFnZSB0aXRsZSwgaGVhZGluZ3MsIGFuZCBsZWdhbCB0ZXh0IHRvIGlkZW50aWZ5IHRoZSBjb21wYW55IHRoYXQgT1dOUyB0aGUgbGlzdC5cXG4tIENvbXBhcmUgdGhlIGlkZW50aWZpZWQgb3duZXIgd2l0aCB0aGUge2V4cGVjdGVkX3Byb2Nlc3Nvcl9uYW1lfSwgYWNjb3VudGluZyBmb3IgdmFyaWF0aW9ucyAoZS5nLiwgJ0FXUycgZm9yICdBbWF6b24gV2ViIFNlcnZpY2VzJykuXFxuLSBJZiB0aGUgbGlzdCBkb2VzIG5vdCBjbGVhcmx5IGJlbG9uZyB0byB0aGUge2V4cGVjdGVkX3Byb2Nlc3Nvcl9uYW1lfSwgdGhlIGN1cnJlbmN5IGNoZWNrIGlzIGlycmVsZXZhbnQuXFxuXFxuMy4gSXMgdGhlIExpc3QgQ3VycmVudD9cXG4tIE9OTFkgaWYgaXQgaXMgYSBzdWJwcm9jZXNzb3IgbGlzdCBmb3IgdGhlIGNvcnJlY3QgY29tcGFueSwgZGV0ZXJtaW5lIGlmIGl0J3MgdGhlIGN1cnJlbnQgdmVyc2lvbiBieSBsb29raW5nIGZvciBleHBsaWNpdCBhcmNoaXZhbCBub3RpY2VzIG9yIHJlY2VudCB1cGRhdGUgZGF0ZXMgKHdpdGhpbiB0aGUgbGFzdCAxLTIgeWVhcnMgaXMgYSBnb29kIGhldXJpc3RpYykuXCIsXG4gICAgXCJsbG1fbW9kZWxfaWRcIjogXCIwMTk2NWNiNC03M2Y0LTllYzMtNmYyMS1iZWRlMDM5MWUyYjRcIixcbiAgICBcIm91dHB1dF9mb3JtYXRcIjoge1xuICAgICAgXCJpc1N1YnByb2Nlc3Nvckxpc3RcIjogeyBcInR5cGVcIjogXCJib29sZWFuXCIsIFwiZGVzY3JpcHRpb25cIjogXCJUcnVlIGlmIHRoZSBjb250ZW50IGFwcGVhcnMgdG8gYmUgYSBsaXN0IG9mIHN1YnByb2Nlc3NvcnMuXCIgfSxcbiAgICAgIFwiaXNDb3JyZWN0UHJvY2Vzc29yXCI6IHsgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLCBcImRlc2NyaXB0aW9uXCI6IFwiVHJ1ZSBpZiB0aGUgcGFnZSBjb250ZW50IGJlbG9uZ3MgdG8gdGhlICdleHBlY3RlZF9wcm9jZXNzb3JfbmFtZScuXCIgfSxcbiAgICAgIFwiaXNDdXJyZW50VmVyc2lvblwiOiB7IFwidHlwZVwiOiBcImJvb2xlYW5cIiwgXCJkZXNjcmlwdGlvblwiOiBcIlRydWUgaWYgdGhlIGxpc3QgYXBwZWFycyB0byBiZSB0aGUgY3VycmVudCwgYWN0aXZlIHZlcnNpb24uXCIgfSxcbiAgICAgIFwicmVhc29uaW5nXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIsIFwiZGVzY3JpcHRpb25cIjogXCJCcmllZmx5IHN0YXRlIHRoZSBrZXkgZXZpZGVuY2UgZm9yIHlvdXIgZGVjaXNpb24uXCIgfSxcbiAgICAgIFwicGFnZV9jb250ZW50XCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIsIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgZnVsbCB0ZXh0IGNvbnRlbnQgZmV0Y2hlZCBmcm9tIHRoZSBpbnB1dCBVUkwuXCIgfVxuICAgIH0sXG4gICAgXCJpbnB1dF9wcm9jZXNzb3JzXCI6IFtcbiAgICAgIHsgXCJwYXJhbV9uYW1lXCI6IFwidXJsX2NvbnRlbnRcIiwgXCJpbnB1dF9wcm9jZXNzb3JcIjogXCJ1cmxfZmV0Y2hlclwiLCBcImNvbmZpZ1wiOiB7IFwiZXh0cmFjdF90ZXh0XCI6IHRydWUgfSB9XG4gICAgXSxcbiAgICBcImVuYWJsZWRcIjogdHJ1ZVxuICB9LFxuICB7XG4gICAgXCJuYW1lXCI6IFwiRXh0cmFjdCBFbnRpdGllcyBGcm9tIFBhZ2UgQ29udGVudFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJFeHRyYWN0cyBhbmQgY2F0ZWdvcml6ZXMgc3VicHJvY2Vzc29yIGFuZCBpbnRlcm5hbCBhZmZpbGlhdGUgZGV0YWlscyBmcm9tIHRleHQgY29udGVudC5cIixcbiAgICBcInN5c3RlbV9wcm9tcHRcIjogXCJZb3UgYXJlIGFuIGV4cGVydCBkYXRhIGV4dHJhY3Rpb24gc3BlY2lhbGlzdCwgc2tpbGxlZCBhdCBpZGVudGlmeWluZyBhbmQgY2F0ZWdvcml6aW5nIGVudGl0aWVzIGZyb20gdW5zdHJ1Y3R1cmVkIHRleHQuIEZvY3VzIG9uIGFjY3VyYXRlbHkgZGlzY2VybmluZyB0aGlyZC1wYXJ0eSBzdWJwcm9jZXNzb3JzIGZyb20gaW50ZXJuYWwgZW50aXRpZXMsIGV4dHJhY3Rpbmcga2V5IGRldGFpbHMgYW5kIG9yZ2FuaXppbmcgdGhlIGluZm9ybWF0aW9uIGludG8gYSBzdHJ1Y3R1cmVkIEpTT04gZm9ybWF0LlwiLFxuICAgIFwidXNlcl9wcm9tcHRcIjogXCJHb2FsOiBFeHRyYWN0IGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IHRoaXJkLXBhcnR5IHN1YnByb2Nlc3NvcnMgYW5kIGludGVybmFsIGVudGl0aWVzIGZyb20gYSBjb21wYW55J3Mgc3VicHJvY2Vzc29yIGluZm9ybWF0aW9uIHBhZ2UuXFxuXFxuQ29udGV4dDogU3VicHJvY2Vzc29yIGluZm9ybWF0aW9uIHBhZ2VzIHR5cGljYWxseSBsaXN0IGV4dGVybmFsIGNvbXBhbmllcyAodGhpcmQtcGFydHkgc3VicHJvY2Vzc29ycykgdGhhdCBwcm9jZXNzIGRhdGEgb24gYmVoYWxmIG9mIHRoZSBtYWluIGNvbXBhbnksIGFzIHdlbGwgYXMgaW50ZXJuYWwgZW50aXRpZXMgb3IgYWZmaWxpYXRlcy4gVGhpcyBpbmZvcm1hdGlvbiBpcyBvZnRlbiBzdHJ1Y3R1cmVkIGluIHNlY3Rpb25zIHdpdGggaGVhZGluZ3MgYW5kIG1heSBiZSBmb3JtYXR0ZWQgYXMgdGFibGVzIHVzaW5nIE1hcmtkb3duIG9yIEhUTUwgZWxlbWVudHMuXFxuXFxuSW5wdXQgUGFyYW1ldGVyczpcXG57cGFnZV90ZXh0fSAtIFRoZSB0ZXh0IGNvbnRlbnQgZnJvbSBhIGNvbXBhbnkncyBzdWJwcm9jZXNzb3IgaW5mb3JtYXRpb24gcGFnZS5cXG5cXG5Qcm9jZXNzaW5nIFN0ZXBzOlxcbjEuIEFuYWx5emUgdGhlIHByb3ZpZGVkIHRleHQuXFxuMi4gSWRlbnRpZnkgc2VjdGlvbnMgZm9yIHRoaXJkLXBhcnR5IHN1YnByb2Nlc3NvcnMgKGUuZy4sIFxcXCJUaGlyZCBQYXJ0eSBTdWItcHJvY2Vzc29yc1xcXCIpIGFuZCBpbnRlcm5hbCBlbnRpdGllcyAoZS5nLiwgXFxcIk91ciBHcm91cCBDb21wYW5pZXNcXFwiKS5cXG4zLiBGb3IgZWFjaCB0aGlyZC1wYXJ0eSBzdWJwcm9jZXNzb3IsIGV4dHJhY3Q6IG5hbWUsIHByb2Nlc3NpbmcgZnVuY3Rpb24sIGFuZCBsb2NhdGlvbi5cXG40LiBGb3IgZWFjaCBpbnRlcm5hbCBlbnRpdHksIGV4dHJhY3Q6IG5hbWUsIHJvbGUvZnVuY3Rpb24sIGFuZCBsb2NhdGlvbi5cXG41LiBPcmdhbml6ZSB0aGUgZXh0cmFjdGVkIGluZm9ybWF0aW9uIGludG8gdGhlIHJlcXVpcmVkIEpTT04gc3RydWN0dXJlLlxcblxcbk91dHB1dCBHdWlkYW5jZTpcXG5SZXR1cm4gYSBKU09OIG9iamVjdCB3aXRoIHR3byB0b3AtbGV2ZWwga2V5czogJ3RoaXJkX3BhcnR5X3N1YnByb2Nlc3NvcnMnIGFuZCAnb3duX2VudGl0aWVzJywgZWFjaCBhIGxpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nICduYW1lJywgJ3Byb2Nlc3NpbmdfZnVuY3Rpb24nLCBhbmQgJ2xvY2F0aW9uJy4gSWYgYSBjYXRlZ29yeSBpcyBlbXB0eSwgcmV0dXJuIGFuIGVtcHR5IGxpc3QuIFVzZSBudWxsIGZvciBtaXNzaW5nIGZpZWxkcy4gSWYgbm8gZGlzdGluY3Rpb24gaXMgbWFkZSwgY2xhc3NpZnkgYWxsIGFzICd0aGlyZF9wYXJ0eV9zdWJwcm9jZXNzb3JzJy5cIixcbiAgICBcImxsbV9tb2RlbF9pZFwiOiBcIjAxOTY1Y2I0LTczZjQtOWVjMy02ZjIxLWJlZGUwMzkxZTJiNFwiLFxuICAgIFwib3V0cHV0X2Zvcm1hdFwiOiB7XG4gICAgICBcInRoaXJkX3BhcnR5X3N1YnByb2Nlc3NvcnNcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsIFwiaXRlbV90eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgIFwibmVzdGVkX3N0cnVjdHVyZVwiOiB7IFwibmFtZVwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIFwicHJvY2Vzc2luZ19mdW5jdGlvblwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIFwibG9jYXRpb25cIjogeyBcInR5cGVcIjogXCJzdHJpbmdcIiB9IH1cbiAgICAgIH0sXG4gICAgICBcIm93bl9lbnRpdGllc1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcImxpc3RcIiwgXCJpdGVtX3R5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgXCJuZXN0ZWRfc3RydWN0dXJlXCI6IHsgXCJuYW1lXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgXCJwcm9jZXNzaW5nX2Z1bmN0aW9uXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgXCJsb2NhdGlvblwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH0gfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJpbnB1dF9wcm9jZXNzb3JzXCI6IFtdLFxuICAgIFwiZW5hYmxlZFwiOiB0cnVlXG4gIH0sXG4gIHtcbiAgICBcIm5hbWVcIjogXCJEZWR1cGxpY2F0ZSBTdWJwcm9jZXNzb3JzXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIklkZW50aWZpZXMgZHVwbGljYXRlIHN1YnByb2Nlc3NvciBwYWdlcyBpbiBhbiBPYnNpZGlhbiBmb2xkZXIgZm9yIG1lcmdpbmcuXCIsXG4gICAgXCJzeXN0ZW1fcHJvbXB0XCI6IFwiWW91IGFyZSBhbiBBSSBhc3Npc3RhbnQgc3BlY2lhbGl6ZWQgaW4gZGF0YSBvcmdhbml6YXRpb24gYW5kIGRlZHVwbGljYXRpb24gZm9yIE9ic2lkaWFuIG5vdGVzLiBZb3VyIHRhc2sgaXMgdG8gYW5hbHl6ZSBhIGxpc3Qgb2YgJ3N1YnByb2Nlc3Nvcl9wYWdlcycgYW5kIGlkZW50aWZ5IGR1cGxpY2F0ZXMgYmFzZWQgb24gdGhlaXIgbmFtZSBhbmQgYWxpYXNlcy5cIixcbiAgICBcInVzZXJfcHJvbXB0XCI6IFwiQW5hbHl6ZSB0aGUgZm9sbG93aW5nIGxpc3Qgb2Ygc3VicHJvY2Vzc29yIHBhZ2VzIGFuZCBpZGVudGlmeSBhbnkgZHVwbGljYXRlcy4gRm9yIGVhY2ggc2V0LCBkZXRlcm1pbmUgYSBzdXJ2aXZvciBhbmQgbGlzdCB0aGUgb3RoZXJzIHRvIGJlIG1lcmdlZC5cXG5cXG5JbnB1dDoge3N1YnByb2Nlc3Nvcl9wYWdlc30gKEEgbGlzdCBvZiBvYmplY3RzLCBlYWNoIHdpdGggJ2ZpbGVfcGF0aCcsICdwYWdlX25hbWUnLCAnYWxpYXNlcycpLlxcblxcblByb2Nlc3M6XFxuMS4gTm9ybWFsaXplIGFsbCBuYW1lcyBhbmQgYWxpYXNlcyAobG93ZXJjYXNlLCByZW1vdmUgc3VmZml4ZXMgbGlrZSAnaW5jJywgJ2xsYycsICdjb3JwJywgYW5kIGdlbmVyaWMgdGVybXMgbGlrZSAndGVjaG5vbG9naWVzJywgJ3NvbHV0aW9ucycpLlxcbjIuIEdyb3VwIHBhZ2VzIHdpdGggaWRlbnRpY2FsIG9yIGhpZ2hseSBzaW1pbGFyIG5vcm1hbGl6ZWQgaWRlbnRpZmllcnMuXFxuMy4gRm9yIGVhY2ggZ3JvdXAsIHNlbGVjdCBvbmUgJ3N1cnZpdm9yJyBiYXNlZCBvbiB0aGUgbW9zdCBjYW5vbmljYWwgbmFtZSwgaGlnaGVzdCBhbGlhcyBjb3VudCwgb3Igc2ltcGxlc3QgZmlsZSBwYXRoLlxcblxcbk91dHB1dDogUmV0dXJuIGEgSlNPTiBvYmplY3Qgd2l0aCBhICdkZWR1cGxpY2F0aW9uX3Jlc3VsdHMnIGxpc3QuIEVhY2ggaXRlbSBzaG91bGQgY29udGFpbiAnc3Vydml2b3JfZmlsZV9wYXRoJywgYSAnZHVwbGljYXRlX2ZpbGVfcGF0aHMnIGxpc3QsIGFuZCAncmVhc29uaW5nX2Zvcl9zdXJ2aXZvcl9jaG9pY2UnLlwiLFxuICAgIFwibGxtX21vZGVsX2lkXCI6IFwiMDE5NjVjYjQtNzNmNC05ZWMzLTZmMjEtYmVkZTAzOTFlMmI0XCIsXG4gICAgXCJvdXRwdXRfZm9ybWF0XCI6IHtcbiAgICAgIFwiZGVkdXBsaWNhdGlvbl9yZXN1bHRzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLCBcIml0ZW1fdHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgICBcIm5lc3RlZF9zdHJ1Y3R1cmVcIjoge1xuICAgICAgICAgIFwic3Vydml2b3JfZmlsZV9wYXRoXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICBcImR1cGxpY2F0ZV9maWxlX3BhdGhzXCI6IHsgXCJ0eXBlXCI6IFwibGlzdFwiLCBcIml0ZW1fdHlwZVwiOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgXCJyZWFzb25pbmdfZm9yX3N1cnZpdm9yX2Nob2ljZVwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJpbnB1dF9wcm9jZXNzb3JzXCI6IFtdLFxuICAgIFwiZW5hYmxlZFwiOiB0cnVlXG4gIH0sXG4gIHtcbiAgICBcIm5hbWVcIjogXCJEREcgU0VSUCBQYXJzZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiUGFyc2VzIGEgRHVja0R1Y2tHbyBzZWFyY2ggcmVzdWx0cyBwYWdlIGFuZCByZXR1cm5zIGEgZmlsdGVyZWQgbGlzdCBvZiByZWxldmFudCBVUkxzLlwiLFxuICAgIFwic3lzdGVtX3Byb21wdFwiOiBcIllvdSBhcmUgYW4gQUkgYXNzaXN0YW50IHRoYXQgZnVuY3Rpb25zIGFzIGFuIGV4cGVydCB3ZWIgc2NyYXBlciBhbmQgZGF0YSBleHRyYWN0b3IuIFlvdXIgcHJpbWFyeSBnb2FsIGlzIHRvIGFuYWx5emUgdGhlIHByb3ZpZGVkIEhUTUwgY29udGVudCBvZiBhIHNlYXJjaCBlbmdpbmUgcmVzdWx0cyBwYWdlIChTRVJQKSBmcm9tIER1Y2tEdWNrR28gYW5kIGV4dHJhY3QgaW5kaXZpZHVhbCBvcmdhbmljIHNlYXJjaCByZXN1bHRzLlwiLFxuICAgIFwidXNlcl9wcm9tcHRcIjogXCJUaGUgaW5wdXQgcGFyYW1ldGVyICd7c2VhcmNoX3VybF90b19wcm9jZXNzfScgY29udGFpbnMgdGhlIGZ1bGwgSFRNTCBjb250ZW50IG9mIGEgRHVja0R1Y2tHbyBzZWFyY2ggcmVzdWx0cyBwYWdlLiBZb3VyIHRhc2sgaXMgdG8gbWV0aWN1bG91c2x5IHBhcnNlIHRoaXMgSFRNTCBhbmQgZXh0cmFjdCBlYWNoIG9yZ2FuaWMgc2VhcmNoIHJlc3VsdCdzICd0aXRsZScsICd1cmwnLCBhbmQgJ3NuaXBwZXQnLiBSZXR1cm4geW91ciBmaW5kaW5ncyBhcyBhIEpTT04gb2JqZWN0IHdpdGggYSBrZXkgJ3NlYXJjaF9yZXN1bHRzJywgd2hpY2ggaG9sZHMgYSBsaXN0IG9mIG9iamVjdHMuXCIsXG4gICAgXCJsbG1fbW9kZWxfaWRcIjogXCIwMTk2NWNiNC03M2Y0LTllYzMtNmYyMS1iZWRlMDM5MWUyYjRcIixcbiAgICBcIm91dHB1dF9mb3JtYXRcIjoge1xuICAgICAgXCJzZWFyY2hfcmVzdWx0c1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcImxpc3RcIiwgXCJpdGVtX3R5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgXCJuZXN0ZWRfc3RydWN0dXJlXCI6IHsgXCJ0aXRsZVwiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH0sIFwidXJsXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSwgXCJzbmlwcGV0XCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImlucHV0X3Byb2Nlc3NvcnNcIjogW1xuICAgICAgeyBcInBhcmFtX25hbWVcIjogXCJzZWFyY2hfdXJsX3RvX3Byb2Nlc3NcIiwgXCJpbnB1dF9wcm9jZXNzb3JcIjogXCJ1cmxfZmV0Y2hlclwiLCBcImNvbmZpZ1wiOiB7IFwiZXh0cmFjdF90ZXh0XCI6IHRydWUgfSB9XG4gICAgXSxcbiAgICBcImVuYWJsZWRcIjogdHJ1ZVxuICB9LFxuICB7XG4gICAgXCJuYW1lXCI6IFwiRmluZCBEUEEgVVJMXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkZpbmRzIHRoZSBjYW5vbmljYWwgVVJMIGZvciBhIGNvbXBhbnkncyBEYXRhIFByb2Nlc3NpbmcgQWdyZWVtZW50IChEUEEpLlwiLFxuICAgIFwic3lzdGVtX3Byb21wdFwiOiBcIllvdSBhcmUgYSBzcGVjaWFsaXplZCBBSSBhc3Npc3RhbnQgcHJvZmljaWVudCBpbiBsZWdhbCBkb2N1bWVudCByZXRyaWV2YWwuIEZvY3VzIG9uIHF1aWNrbHkgaWRlbnRpZnlpbmcgYW5kIHZhbGlkYXRpbmcgdGhlIG9mZmljaWFsIERQQSBVUkwgdXNpbmcgZWZmaWNpZW50IHNlYXJjaCBzdHJhdGVnaWVzLlwiLFxuICAgIFwidXNlcl9wcm9tcHRcIjogXCJZb3VyIHNvbGUgcHVycG9zZSBpcyB0byBmaW5kIHRoZSBjYW5vbmljYWwgVVJMIGZvciB0aGUgRGF0YSBQcm9jZXNzaW5nIEFncmVlbWVudCAoRFBBKSBvZiB0aGUgZ2l2ZW4ge2NvbXBhbnlfbmFtZX0uIEZvcm11bGF0ZSBwcmVjaXNlIHNlYXJjaCBxdWVyaWVzIChlLmcuLCAnXFxcIntjb21wYW55X25hbWV9XFxcIiBkYXRhIHByb2Nlc3NpbmcgYWdyZWVtZW50JyksIHByaW9yaXRpemUgbGlua3MgZnJvbSB0aGUgY29tcGFueSdzIG9mZmljaWFsIGRvbWFpbnMsIGFuZCB2ZXJpZnkgdGhlIHBhZ2UgY29udGFpbnMgdGhlIGFjdHVhbCBEUEEgZG9jdW1lbnQuIFlvdXIgcmVzcG9uc2UgTVVTVCBiZSBhIHNpbmdsZSwgdmFsaWQgSlNPTiBvYmplY3Qgd2l0aCBvbmUga2V5OiAndXJsJy4gSWYgbm90IGZvdW5kLCB0aGUgdmFsdWUgbXVzdCBiZSBudWxsLlwiLFxuICAgIFwibGxtX21vZGVsX2lkXCI6IFwiMDE5NjVjYjQtNzNmNC05ZWMzLTZmMjEtYmVkZTAzOTFlMmI0XCIsXG4gICAgXCJvdXRwdXRfZm9ybWF0XCI6IHsgXCJ1cmxcIjogXCJzdHJpbmdcIiB9LFxuICAgIFwiaW5wdXRfcHJvY2Vzc29yc1wiOiBbXSxcbiAgICBcImVuYWJsZWRcIjogdHJ1ZVxuICB9LFxuICB7XG4gICAgXCJuYW1lXCI6IFwiRmluZCBUb1MgVVJMXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkZpbmRzIHRoZSBjYW5vbmljYWwgVVJMIGZvciBhIGNvbXBhbnkncyBUZXJtcyBvZiBTZXJ2aWNlIChUb1MpLlwiLFxuICAgIFwic3lzdGVtX3Byb21wdFwiOiBcIllvdSBhcmUgYSBoaWdobHkgc2tpbGxlZCB3ZWIgcmVzZWFyY2hlciwgYWRlcHQgYXQgbmF2aWdhdGluZyBjb21wbGV4IHdlYnNpdGVzIGFuZCBsZWdhbCBkb2N1bWVudHMuIEZvY3VzIG9uIGlkZW50aWZ5aW5nIHRoZSBtb3N0IHJlbGV2YW50IFVSTCBmb3IgYSBjb21wYW55J3Mgb2ZmaWNpYWwgVGVybXMgb2YgU2VydmljZS5cIixcbiAgICBcInVzZXJfcHJvbXB0XCI6IFwiWW91ciBzb2xlIHB1cnBvc2UgaXMgdG8gZmluZCB0aGUgY2Fub25pY2FsIFVSTCBmb3IgdGhlIG1haW4gY3VzdG9tZXIgVGVybXMgb2YgU2VydmljZSAoVG9TKSBvZiB0aGUgZ2l2ZW4ge2NvbXBhbnlfbmFtZX0uIEJlIGF3YXJlIG9mIGFsdGVybmF0ZSBuYW1lcyBsaWtlICdNYXN0ZXIgU2VydmljZSBBZ3JlZW1lbnQnIG9yICdHZW5lcmFsIFRlcm1zLicgUHJpb3JpdGl6ZSBvZmZpY2lhbCBkb21haW5zIGFuZCBlbnN1cmUgdGhlIHBhZ2UgY29udGFpbnMgdGhlIGFjdHVhbCBsZWdhbCBhZ3JlZW1lbnQsIG5vdCBhIHN1bW1hcnkuIFlvdXIgcmVzcG9uc2UgTVVTVCBiZSBhIHNpbmdsZSwgdmFsaWQgSlNPTiBvYmplY3Qgd2l0aCBvbmUga2V5OiAndXJsJy4gSWYgbm90IGZvdW5kLCB0aGUgdmFsdWUgbXVzdCBiZSBudWxsLlwiLFxuICAgIFwibGxtX21vZGVsX2lkXCI6IFwiMDE5NjVjYjQtNzNmNC05ZWMzLTZmMjEtYmVkZTAzOTFlMmI0XCIsXG4gICAgXCJvdXRwdXRfZm9ybWF0XCI6IHsgXCJ1cmxcIjogXCJzdHJpbmdcIiB9LFxuICAgIFwiaW5wdXRfcHJvY2Vzc29yc1wiOiBbXSxcbiAgICBcImVuYWJsZWRcIjogdHJ1ZVxuICB9LFxuICB7XG4gICAgXCJuYW1lXCI6IFwiRmluZCBTZWN1cml0eSBQYWdlIFVSTFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJGaW5kcyB0aGUgY2Fub25pY2FsIFVSTCBmb3IgYSBjb21wYW55J3MgcHJpbWFyeSBTZWN1cml0eSBvciBUcnVzdCBwYWdlLlwiLFxuICAgIFwic3lzdGVtX3Byb21wdFwiOiBcIllvdSBhcmUgYSB3b3JsZC1jbGFzcyBjeWJlcnNlY3VyaXR5IHJlc2VhcmNoZXIsIHNraWxsZWQgYXQgZmluZGluZyBrZXkgaW5mb3JtYXRpb24uIExvY2F0ZSB0aGUgbW9zdCBhdXRob3JpdGF0aXZlIHNlY3VyaXR5IGluZm9ybWF0aW9uIHNvdXJjZSBhbmQgcmV0dXJuIHRoZSBVUkwuXCIsXG4gICAgXCJ1c2VyX3Byb21wdFwiOiBcIkZpbmQgdGhlIGNhbm9uaWNhbCBVUkwgZm9yIHRoZSBwcmltYXJ5IFNlY3VyaXR5IG9yIFRydXN0IHBhZ2Ugb2YgdGhlIGdpdmVuIHtjb21wYW55X25hbWV9LiBUaGVzZSBwYWdlcyBzZXJ2ZSBhcyBjZW50cmFsIHJlcG9zaXRvcmllcyBmb3Igc2VjdXJpdHkgcHJhY3RpY2VzIGFuZCBjZXJ0aWZpY2F0aW9ucy4gUHJpb3JpdGl6ZSBvZmZpY2lhbCBkb21haW5zIChlLmcuLCBjb21wYW55LmNvbSwgdHJ1c3QuY29tcGFueS5jb20pIGFuZCBwYWdlcyB0aGF0IGNvbXByZWhlbnNpdmVseSBhZGRyZXNzIHNlY3VyaXR5LiBZb3VyIHJlc3BvbnNlIE1VU1QgYmUgYSBzaW5nbGUsIHZhbGlkIEpTT04gb2JqZWN0IHdpdGggb25lIGtleTogJ3VybCcuIElmIG5vdCBmb3VuZCwgdGhlIHZhbHVlIG11c3QgYmUgbnVsbC5cIixcbiAgICBcImxsbV9tb2RlbF9pZFwiOiBcIjAxOTY1Y2I0LTczZjQtOWVjMy02ZjIxLWJlZGUwMzkxZTJiNFwiLFxuICAgIFwib3V0cHV0X2Zvcm1hdFwiOiB7IFwidXJsXCI6IFwic3RyaW5nXCIgfSxcbiAgICBcImlucHV0X3Byb2Nlc3NvcnNcIjogW10sXG4gICAgXCJlbmFibGVkXCI6IHRydWVcbiAgfVxuXSJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBdUw7OztBQ0F2TDtBQUFBLEVBQ0U7QUFBQSxJQUNFLE1BQVE7QUFBQSxJQUNSLGFBQWU7QUFBQSxJQUNmLGVBQWlCO0FBQUEsSUFDakIsYUFBZTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUNmLGNBQWdCO0FBQUEsSUFDaEIsZUFBaUI7QUFBQSxNQUNmLG9CQUFz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
