/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ProcessorProcessorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var SUBPROCESSOR_URL_KEYWORDS = [
  "subprocessor",
  "sub-processor",
  "sub_processor",
  "vendor-list",
  "vendorlist",
  "third-party-list",
  "thirdpartylist",
  "service-providers",
  "serviceproviders",
  "dpa-exhibit",
  "dpa/exhibit",
  "data-processing-addendum/exhibit",
  "trust-center/sub",
  "legal/subprocessors"
];
var DEFAULT_SETTINGS = {
  serpApiKey: "",
  rightbrainClientId: "",
  rightbrainClientSecret: "",
  rightbrainOrgId: "",
  rightbrainProjectId: "",
  rightbrainApiUrl: "https://app.rightbrain.ai/api/v1",
  rightbrainOauth2Url: "https://oauth.rightbrain.ai",
  rightbrainVerifyUrlTaskId: "",
  rightbrainExtractEntitiesTaskId: "",
  rightbrainExtractInputField: "page_text",
  rightbrainExtractOutputThirdPartyField: "third_party_subprocessors",
  rightbrainExtractOutputOwnEntitiesField: "own_entities",
  rightbrainDeduplicateSubprocessorsTaskId: "",
  rightbrainDuckDuckGoSearchTaskId: "",
  createPagesForOwnEntities: false,
  verboseDebug: false,
  maxResultsPerProcessor: 1,
  maxRecursiveDepth: 2,
  discoveryCacheDays: 30,
  processorsFolderPath: "Processors",
  analysisLogsFolderPath: "Analysis Logs",
  rightbrainFindDpaTaskId: "",
  rightbrainFindTosTaskId: "",
  rightbrainFindSecurityTaskId: "",
  autoSynchronizeTasks: true,
  llmModelList: [],
  llmModelListLastUpdated: 0,
  verifyUrlModelId: "",
  // We'll leave these blank and handle defaults in the UI
  extractEntitiesModelId: "",
  deduplicateSubprocessorsModelId: "",
  duckDuckGoSearchModelId: "",
  findDpaModelId: "",
  findTosModelId: "",
  findSecurityModelId: ""
};
var ProcessorProcessorPlugin = class extends import_obsidian.Plugin {
  async onload() {
    this.processedInCurrentRecursiveSearch = /* @__PURE__ */ new Set();
    await this.loadSettings();
    this.updateLlmModelList(false);
    if (this.settings.autoSynchronizeTasks) {
      setTimeout(() => this.synchronizeRightBrainTasks(), 1e3);
    }
    this.addRibbonIcon("link", "Manually Add Subprocessor List URL", (evt) => {
      new ManualInputModal(this.app, async (processorName, listUrl, isPrimary) => {
        if (processorName && listUrl) {
          new import_obsidian.Notice(`Processing manual URL input for: ${processorName}`);
          const processorFile = await this.ensureProcessorFile(processorName, true, isPrimary);
          if (processorFile) {
            const searchData = await this.fetchDataFromDirectUrl(processorName, listUrl);
            if (searchData) {
              await this.persistSubprocessorInfo(processorName, processorFile, searchData, isPrimary);
              if (searchData.flaggedCandidateUrlCount > 0) {
                new import_obsidian.Notice(`${searchData.flaggedCandidateUrlCount} URL(s) looked promising but couldn't be verified. Check logs.`);
              }
            } else {
              new import_obsidian.Notice(`Could not process data from direct URL for ${processorName}.`);
            }
          } else {
            new import_obsidian.Notice(`Could not create or find file for ${processorName} in ${this.settings.processorsFolderPath}`);
          }
        }
      }).open();
    });
    this.addRibbonIcon("paste", "Input Subprocessor List from Text", (evt) => {
      this.openManualTextEntryModal();
    });
    this.addCommand({
      id: "run-processor-search-global",
      name: "Search for Subprocessors (Discover)",
      callback: () => {
        new SearchModal(this.app, this.settings, async (processorName) => {
          if (processorName) {
            new import_obsidian.Notice(`Starting discovery search for: ${processorName}`);
            const processorFile = await this.ensureProcessorFile(processorName, true);
            if (processorFile) {
              await this.discoverAndProcessProcessorPage(processorName, processorFile);
            } else {
              new import_obsidian.Notice(`Could not create or find file for ${processorName} in ${this.settings.processorsFolderPath}`);
            }
          }
        }).open();
      }
    });
    this.addCommand({
      id: "input-subprocessor-list-from-text",
      name: "Input Subprocessor List from Text",
      callback: () => {
        this.openManualTextEntryModal();
      }
    });
    this.addCommand({
      id: "run-processor-search-recursive",
      // New ID
      name: "Search for Subprocessors (Recursive Discover)",
      callback: () => {
        new SearchModal(this.app, this.settings, async (processorName) => {
          if (processorName) {
            await this.discoverRecursively(processorName, void 0, this.settings.maxRecursiveDepth);
          }
        }).open();
      }
    });
    this.addCommand({
      id: "force-merge-processors-from-palette",
      name: "Force Merge processor files...",
      callback: () => {
        this.openFileSelectorMergeModal();
      }
    });
    this.addCommand({
      id: "synchronize-rightbrain-tasks",
      name: "Synchronize RightBrain Tasks",
      callback: () => {
        this.synchronizeRightBrainTasks();
      }
    });
    this.addCommand({
      id: "complete-first-time-setup",
      name: "Complete First-Time Setup (Credentials & Tasks)",
      callback: () => {
        new PasteEnvModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "apply-recommended-graph-settings",
      name: "Apply Recommended Graph Settings",
      callback: () => {
        this.applyRecommendedGraphSettings();
      }
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, fileOrFolder, source) => {
        if (fileOrFolder instanceof import_obsidian.TFolder) {
          const folder = fileOrFolder;
          if (folder.path === this.settings.processorsFolderPath) {
            menu.addItem((item) => {
              item.setTitle("Deduplicate Subprocessor Pages").setIcon("git-pull-request-draft").onClick(async () => {
                if (!this.settings.rightbrainDeduplicateSubprocessorsTaskId) {
                  new import_obsidian.Notice("Deduplication Task ID not set in plugin settings.");
                  return;
                }
                new import_obsidian.Notice(`Starting deduplication for folder: ${folder.path}`);
                await this.runDeduplicationForFolder(folder);
              });
            });
          }
        } else if (fileOrFolder instanceof import_obsidian.TFile && fileOrFolder.extension === "md") {
          const file = fileOrFolder;
          if (file.path.startsWith(this.settings.processorsFolderPath + "/")) {
            const fileCache = this.app.metadataCache.getFileCache(file);
            const frontmatter = fileCache == null ? void 0 : fileCache.frontmatter;
            const originalProcessorName = (frontmatter == null ? void 0 : frontmatter.aliases) && Array.isArray(frontmatter.aliases) && frontmatter.aliases.length > 0 ? frontmatter.aliases[0] : file.basename;
            menu.addItem((item) => {
              item.setTitle("Map Subprocessor Relationships").setIcon("chevrons-down-up").onClick(async () => {
                new import_obsidian.Notice(`Starting recursive discovery from: ${originalProcessorName}`);
                await this.discoverRecursively(originalProcessorName, file, this.settings.maxRecursiveDepth);
              });
            });
            menu.addItem((item) => {
              item.setTitle("Discover Subprocessor List").setIcon("wand").onClick(async () => {
                new import_obsidian.Notice(`Discovering subprocessor list for: ${originalProcessorName}`);
                await this.discoverAndProcessProcessorPage(originalProcessorName, file);
              });
            });
            menu.addItem((item) => {
              item.setTitle("Enrich Processor Documentation").setIcon("book-plus").onClick(async () => {
                new import_obsidian.Notice(`Enriching documentation for: ${originalProcessorName}`);
                await this.enrichProcessorFile(originalProcessorName, file);
              });
            });
            menu.addItem((item) => {
              item.setTitle("Add Subprocessor List URL").setIcon("plus-circle").onClick(async () => {
                new ManualInputModal(this.app, async (pName, listUrl, isPrimary) => {
                  if (listUrl) {
                    new import_obsidian.Notice(`Processing manual URL input for: ${originalProcessorName} using URL: ${listUrl}`);
                    const searchData = await this.fetchDataFromDirectUrl(originalProcessorName, listUrl);
                    if (searchData) {
                      await this.persistSubprocessorInfo(originalProcessorName, file, searchData, isPrimary);
                      if (searchData.flaggedCandidateUrlCount > 0) {
                        new import_obsidian.Notice(`${searchData.flaggedCandidateUrlCount} URL(s) looked promising but couldn't be verified. Check logs.`);
                      }
                    } else {
                      new import_obsidian.Notice(`Could not process data from direct URL for ${originalProcessorName}.`);
                    }
                  }
                }, originalProcessorName).open();
              });
            });
            menu.addItem((item) => {
              item.setTitle("Input Subprocessor List from Text").setIcon("file-input").onClick(async () => {
                this.openManualTextEntryModal(originalProcessorName);
              });
            });
          }
        }
      })
    );
    this.addSettingTab(new ProcessorProcessorSettingTab(this.app, this));
    console.log("Processor Processor plugin loaded.");
  }
  onunload() {
    console.log("Processor Processor plugin unloaded.");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Fetches the list of available LLM models from the Rightbrain API.
   * @returns A promise that resolves to an array of LlmModel objects.
   */
  async fetchLlmModels() {
    const rbToken = await this.getRightBrainAccessToken();
    if (!rbToken) {
      console.error("Cannot fetch LLM models without an access token.");
      return [];
    }
    const modelsUrl = `${this.settings.rightbrainApiUrl}/org/${this.settings.rightbrainOrgId}/project/${this.settings.rightbrainProjectId}/model`;
    const headers = { "Authorization": `Bearer ${rbToken}` };
    try {
      const response = await (0, import_obsidian.requestUrl)({ url: modelsUrl, method: "GET", headers, throw: false });
      if (response.status === 200 && Array.isArray(response.json)) {
        return response.json.map((model) => ({
          id: model.id,
          alias: model.alias
        }));
      } else {
        console.error("Failed to list RightBrain LLM models:", response.status, response.text);
        return [];
      }
    } catch (error) {
      console.error("Error fetching RightBrain LLM models:", error);
      return [];
    }
  }
  /**
   * Updates the cached list of LLM models if the cache is stale or if forced.
   * @param force - If true, bypasses the cache check.
   */
  async updateLlmModelList(force = false) {
    const now = Date.now();
    const cacheDuration = 24 * 60 * 60 * 1e3;
    const hasCredentials = this.settings.rightbrainClientId && this.settings.rightbrainOrgId && this.settings.rightbrainProjectId;
    if (!force && this.settings.llmModelList.length > 0 && now - this.settings.llmModelListLastUpdated < cacheDuration) {
      return;
    }
    if (!hasCredentials) {
      return;
    }
    try {
      const models = await this.fetchLlmModels();
      if (models.length > 0) {
        this.settings.llmModelList = models;
        this.settings.llmModelListLastUpdated = now;
        await this.saveSettings();
        if (force) {
          new import_obsidian.Notice("LLM model list has been updated.");
        }
      }
    } catch (error) {
      console.error("Failed to update LLM model list:", error);
      if (force) {
        new import_obsidian.Notice("Failed to update LLM model list. Check console.");
      }
    }
  }
  openManualTextEntryModal(initialProcessorName) {
    if (!this.settings.rightbrainExtractEntitiesTaskId) {
      new import_obsidian.Notice("RightBrain Task ID for entity extraction is not configured. Please set it in plugin settings.");
      return;
    }
    new ManualTextEntryModal(this.app, async (processorName, pastedText, isPrimary) => {
      if (processorName && pastedText) {
        new import_obsidian.Notice(`Processing pasted text for: ${processorName}`);
        const processorFile = await this.ensureProcessorFile(processorName, true, isPrimary);
        if (processorFile) {
          const searchData = await this.fetchDataFromPastedText(processorName, pastedText);
          if (searchData) {
            await this.persistSubprocessorInfo(processorName, processorFile, searchData, isPrimary);
          } else {
            new import_obsidian.Notice(`Could not process data from pasted text for ${processorName}.`);
          }
        } else {
          new import_obsidian.Notice(`Could not create or find file for ${processorName} in ${this.settings.processorsFolderPath}`);
        }
      }
    }, initialProcessorName).open();
  }
  sanitizeNameForFilePathAndAlias(entityName) {
    const originalName = (entityName || "Unknown Entity").trim();
    let baseNameForFile = originalName;
    const dbaRegex = /^(.*?)\s+(?:dba|d\/b\/a|doing business as)\s+(.*)$/i;
    const dbaMatch = originalName.match(dbaRegex);
    if (dbaMatch && dbaMatch[2]) {
      baseNameForFile = dbaMatch[2].trim();
    }
    let filePathName = baseNameForFile.replace(/,/g, "");
    filePathName = filePathName.replace(/[\\/:*?"<>|]/g, "").trim();
    if (!filePathName) {
      filePathName = originalName.replace(/[\\/:*?"<>|,]/g, "").replace(/\s+/g, "_") || "Sanitized_Entity";
    }
    if (!filePathName) {
      filePathName = "Sanitized_Entity_" + Date.now();
    }
    return {
      filePathName,
      originalNameAsAlias: originalName
      // The original full name is always used as an alias
    };
  }
  scrubHyperlinks(text) {
    if (!text) return "N/A";
    let scrubbedText = String(text);
    scrubbedText = scrubbedText.replace(/\[(.*?)\]\((?:.*?)\)/g, "$1");
    scrubbedText = scrubbedText.replace(/<a[^>]*>(.*?)<\/a>/gi, "$1");
    scrubbedText = scrubbedText.replace(/<[^>]+>/g, "");
    scrubbedText = scrubbedText.replace(/\s+/g, " ").trim();
    return scrubbedText || "N/A";
  }
  addRelationship(collectedRelationships, seenRelationships, processorName, entity, type, sourceUrl, verificationReasoning) {
    var _a;
    const originalEntityName = (_a = entity.name) == null ? void 0 : _a.trim();
    if (!originalEntityName) return 0;
    const subprocessorNameToStore = originalEntityName;
    if (processorName.toLowerCase() === "openai" && type === "is_own_entity") {
      const openaiAffiliates = ["openai global", "openai, opco", "openai ireland", "openai uk", "openai japan", "openaiglobal", "openai opco", "openai llc"];
      if (openaiAffiliates.some((aff) => originalEntityName.toLowerCase().includes(aff)) || originalEntityName.toLowerCase() === "openai") {
        return 0;
      }
    }
    const relTuple = `${processorName}|${subprocessorNameToStore}|${type}`;
    if (!seenRelationships.has(relTuple)) {
      collectedRelationships.push({
        PrimaryProcessor: processorName,
        SubprocessorName: subprocessorNameToStore,
        // Store the original name
        ProcessingFunction: this.scrubHyperlinks(entity.processing_function),
        Location: this.scrubHyperlinks(entity.location),
        RelationshipType: type,
        SourceURL: sourceUrl,
        VerificationReasoning: this.scrubHyperlinks(verificationReasoning)
      });
      seenRelationships.add(relTuple);
      return 1;
    }
    return 0;
  }
  async discoverAndProcessProcessorPage(processorName, processorFile) {
    new import_obsidian.Notice(`Processing (discovery): ${processorName}...`);
    const searchData = await this.fetchProcessorSearchDataWithDiscovery(processorName);
    if (searchData) {
      await this.persistSubprocessorInfo(processorName, processorFile, searchData);
      if (searchData.flaggedCandidateUrlCount > 0) {
        new import_obsidian.Notice(`${searchData.flaggedCandidateUrlCount} URL(s) looked promising but couldn't be verified. Check Analysis Log for details and consider using the 'Input from Text' feature.`);
      }
    } else {
      new import_obsidian.Notice(`Failed to fetch data via discovery for ${processorName}.`);
    }
  }
  async enrichProcessorFile(processorName, file) {
    var _a;
    new import_obsidian.Notice(`Fetching compliance documents for ${processorName}...`, 5e3);
    const rbToken = await this.getRightBrainAccessToken();
    if (!rbToken) {
      new import_obsidian.Notice("Failed to get RightBrain token. Aborting enrichment.");
      return;
    }
    const documentTypes = [
      { type: "DPA", taskId: this.settings.rightbrainFindDpaTaskId, title: "Data Processing Agreement" },
      { type: "ToS", taskId: this.settings.rightbrainFindTosTaskId, title: "Terms of Service" },
      { type: "Security", taskId: this.settings.rightbrainFindSecurityTaskId, title: "Security Documentation" }
    ];
    const foundDocuments = [];
    for (const doc of documentTypes) {
      if (!doc.taskId) {
        if (this.settings.verboseDebug) console.log(`Skipping ${doc.type} search for ${processorName}, no Task ID set.`);
        continue;
      }
      const taskInputPayload = { "company_name": processorName };
      const taskResult = await this.callRightBrainTask(doc.taskId, taskInputPayload, rbToken);
      if (((_a = taskResult == null ? void 0 : taskResult.response) == null ? void 0 : _a.url) && this.isValidUrl(taskResult.response.url)) {
        foundDocuments.push({ title: doc.title, url: taskResult.response.url });
        if (this.settings.verboseDebug) console.log(`Found ${doc.type} for ${processorName}: ${taskResult.response.url}`);
      } else {
        if (this.settings.verboseDebug) console.warn(`Could not find valid URL for ${doc.type} for ${processorName}. Result:`, taskResult);
      }
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
    if (foundDocuments.length === 0) {
      new import_obsidian.Notice(`No new compliance documents found for ${processorName}.`);
      return;
    }
    let markdownContent = "\n";
    foundDocuments.forEach((doc) => {
      markdownContent += `- **${doc.title}:** [${doc.url}](${doc.url})
`;
    });
    const heading = "Compliance Documentation";
    await this.app.vault.process(file, (content) => {
      return this.ensureHeadingAndSection(content, heading, markdownContent, null, null, true);
    });
    new import_obsidian.Notice(`Successfully added ${foundDocuments.length} document link(s) to ${processorName}.`);
  }
  async synchronizeRightBrainTasks() {
    var _a;
    new import_obsidian.Notice("Starting RightBrain task synchronization...", 4e3);
    const creds = {
      apiUrl: this.settings.rightbrainApiUrl,
      oauthUrl: this.settings.rightbrainOauth2Url,
      clientId: this.settings.rightbrainClientId,
      clientSecret: this.settings.rightbrainClientSecret,
      orgId: this.settings.rightbrainOrgId,
      projectId: this.settings.rightbrainProjectId
    };
    const rbToken = await this.getRightBrainAccessToken(creds);
    if (!rbToken) {
      new import_obsidian.Notice("Task sync failed: Could not get RightBrain Access Token.", 1e4);
      return;
    }
    let localTaskDefs;
    try {
      const adapter = this.app.vault.adapter;
      const filePath = `${this.manifest.dir}/task_definitions.json`;
      if (!await adapter.exists(filePath)) {
        new import_obsidian.Notice("Task sync failed: task_definitions.json not found.", 1e4);
        return;
      }
      localTaskDefs = JSON.parse(await adapter.read(filePath));
    } catch (error) {
      new import_obsidian.Notice("Task sync failed: Could not read task_definitions.json. Check console.", 1e4);
      console.error("ProcessorProcessor: Failed to load local task definitions:", error);
      return;
    }
    const serverTasksArray = await this.listAllRightBrainTasks(rbToken, creds);
    if (serverTasksArray === null) {
      new import_obsidian.Notice("Task sync failed: Could not retrieve tasks from RightBrain.", 1e4);
      return;
    }
    const serverTasksMap = new Map(serverTasksArray.map((task) => [task.name, task]));
    for (const localDef of localTaskDefs) {
      const serverTask = serverTasksMap.get(localDef.name);
      const modelSettingKeyMap = {
        "rightbrainVerifyUrlTaskId": "verifyUrlModelId",
        "rightbrainExtractEntitiesTaskId": "extractEntitiesModelId",
        "rightbrainDeduplicateSubprocessorsTaskId": "deduplicateSubprocessorsModelId",
        "rightbrainDuckDuckGoSearchTaskId": "duckDuckGoSearchModelId",
        "rightbrainFindDpaTaskId": "findDpaModelId",
        "rightbrainFindTosTaskId": "findTosModelId",
        "rightbrainFindSecurityTaskId": "findSecurityModelId"
      };
      const modelSettingKey = modelSettingKeyMap[localDef.setting_key];
      const userSelectedModelId = modelSettingKey ? this.settings[modelSettingKey] : null;
      const newRevisionPayload = {
        system_prompt: localDef.system_prompt,
        user_prompt: localDef.user_prompt,
        output_format: localDef.output_format,
        input_processors: localDef.input_processors || [],
        enabled: localDef.enabled,
        llm_model_id: userSelectedModelId || localDef.llm_model_id
      };
      if (!serverTask) {
        if (this.settings.verboseDebug) console.log(`Task '${localDef.name}' not found on server. Creating...`);
        const createTaskPayload = { ...newRevisionPayload, name: localDef.name, description: localDef.description };
        await this.createRightBrainTask(rbToken, createTaskPayload, creds);
      } else {
        const latestRevision = (_a = serverTask.task_revisions) == null ? void 0 : _a.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())[0];
        const needsUpdate = !latestRevision || latestRevision.system_prompt !== newRevisionPayload.system_prompt || latestRevision.user_prompt !== newRevisionPayload.user_prompt || latestRevision.llm_model_id !== newRevisionPayload.llm_model_id || JSON.stringify(latestRevision.output_format) !== JSON.stringify(newRevisionPayload.output_format);
        if (needsUpdate) {
          if (this.settings.verboseDebug) console.log(`Task '${localDef.name}' has updates. Creating new revision...`);
          await this.updateRightBrainTask(rbToken, serverTask.id, newRevisionPayload, localDef.name, creds);
        }
      }
    }
    const finalServerTasks = await this.listAllRightBrainTasks(rbToken, creds);
    if (finalServerTasks === null) {
      new import_obsidian.Notice("Task sync failed: Could not fetch final task list to save IDs.", 1e4);
      return;
    }
    const finalTaskMap = new Map(finalServerTasks.map((task) => [task.name, task.id]));
    let tasksPopulated = 0;
    for (const localDef of localTaskDefs) {
      const settingKey = localDef.setting_key;
      if (settingKey && finalTaskMap.has(localDef.name)) {
        this.settings[settingKey] = finalTaskMap.get(localDef.name);
        tasksPopulated++;
      }
    }
    await this.saveSettings();
    new import_obsidian.Notice(`RightBrain tasks synchronized successfully. ${tasksPopulated} tasks configured.`, 1e4);
  }
  async setupRightBrainTasks(creds) {
    new import_obsidian.Notice("Step 1: Verifying tasks on RightBrain...", 4e3);
    const rbToken = await this.getRightBrainAccessToken(creds);
    if (!rbToken) {
      new import_obsidian.Notice("Setup failed: Could not get RightBrain Access Token.");
      return;
    }
    let taskDefs;
    try {
      const adapter = this.app.vault.adapter;
      const pluginDir = this.manifest.dir;
      const filePath = `${pluginDir}/task_definitions.json`;
      if (!await adapter.exists(filePath)) {
        new import_obsidian.Notice("Error: task_definitions.json not found in plugin folder.", 7e3);
        return;
      }
      const fileContent = await adapter.read(filePath);
      taskDefs = JSON.parse(fileContent);
    } catch (error) {
      new import_obsidian.Notice("Error reading or parsing task_definitions.json. Check console.", 7e3);
      console.error("ProcessorProcessor: Failed to load task definitions from file:", error);
      return;
    }
    const existingTasks = await this.listAllRightBrainTasks(rbToken, creds);
    if (existingTasks === null) {
      new import_obsidian.Notice("Setup failed: Could not retrieve existing tasks from RightBrain.");
      return;
    }
    const existingTaskNames = new Set(existingTasks.map((task) => task.name));
    for (const taskDef of taskDefs) {
      if (!existingTaskNames.has(taskDef.name)) {
        new import_obsidian.Notice(`Creating missing task: '${taskDef.name}'...`);
        await this.createRightBrainTask(rbToken, taskDef, creds);
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
    }
    new import_obsidian.Notice("Step 2: Fetching all task IDs...", 4e3);
    const allServerTasks = await this.listAllRightBrainTasks(rbToken, creds);
    if (allServerTasks === null) {
      new import_obsidian.Notice("Error: Could not fetch the final list of tasks to save their IDs.");
      return;
    }
    const serverTaskMap = new Map(allServerTasks.map((task) => [task.name, task.id]));
    let tasksPopulated = 0;
    for (const taskDef of taskDefs) {
      const settingKey = taskDef.setting_key;
      if (settingKey && serverTaskMap.has(taskDef.name)) {
        const taskId = serverTaskMap.get(taskDef.name);
        if (taskId) {
          this.settings[settingKey] = taskId;
          tasksPopulated++;
        }
      } else {
        console.warn(`Could not find a matching task on the server for local definition: "${taskDef.name}"`);
      }
    }
    await this.saveSettings();
    if (tasksPopulated === taskDefs.length) {
      new import_obsidian.Notice(`Success! All ${tasksPopulated} task IDs have been configured and saved.`);
    } else {
      new import_obsidian.Notice(`Setup finished, but only ${tasksPopulated} of ${taskDefs.length} task IDs could be saved.`);
    }
  }
  /**
   * Fetches a list of all tasks from the configured RightBrain project.
   * @param rbToken The RightBrain access token.
   * @returns An array of task objects or null if an error occurs.
   */
  async listAllRightBrainTasks(rbToken, creds) {
    const tasksUrl = `${creds.apiUrl}/org/${creds.orgId}/project/${creds.projectId}/task`;
    const headers = { "Authorization": `Bearer ${rbToken}` };
    try {
      const response = await (0, import_obsidian.requestUrl)({ url: tasksUrl, method: "GET", headers, throw: false });
      if (response.status === 200) {
        return response.json.results || [];
      } else {
        console.error("Failed to list RightBrain tasks:", response.status, response.text);
        return null;
      }
    } catch (error) {
      console.error("Error fetching RightBrain tasks:", error);
      return null;
    }
  }
  /**
   * Creates a single new task in RightBrain using a provided definition.
   * @param rbToken The RightBrain access token.
   * @param taskDefinition An object containing the full configuration for the new task.
   * @returns The created task object or null if an error occurs.
   */
  async createRightBrainTask(rbToken, taskDefinition, creds) {
    const createUrl = `${creds.apiUrl}/org/${creds.orgId}/project/${creds.projectId}/task`;
    const headers = {
      "Authorization": `Bearer ${rbToken}`,
      "Content-Type": "application/json"
    };
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: createUrl,
        method: "POST",
        headers,
        body: JSON.stringify(taskDefinition),
        throw: false
      });
      if (response.status === 201 || response.status === 200) {
        new import_obsidian.Notice(`Successfully created task: '${taskDefinition.name}'`);
        return response.json;
      } else {
        new import_obsidian.Notice(`Failed to create task '${taskDefinition.name}': ${response.status}`, 7e3);
        console.error(`Error creating task '${taskDefinition.name}':`, response.status, response.text);
        return null;
      }
    } catch (error) {
      console.error(`Network error creating task '${taskDefinition.name}':`, error);
      return null;
    }
  }
  async persistSubprocessorInfo(processorName, processorFile, searchData, isTopLevelProcessor = true, mergeDecisions = []) {
    new import_obsidian.Notice(`Persisting info for: ${processorName}...`);
    await this.ensureFolderExists(this.settings.processorsFolderPath);
    await this.ensureFolderExists(this.settings.analysisLogsFolderPath);
    const { collectedRelationships, processedUrlDetails } = searchData;
    await this.updateProcessorFile(processorFile, processorName, collectedRelationships, isTopLevelProcessor);
    const uniqueTargetEntityOriginalNames = Array.from(new Set(collectedRelationships.map((r) => r.SubprocessorName)));
    const createdPagesForThisRun = /* @__PURE__ */ new Set();
    for (const targetEntityOriginalName of uniqueTargetEntityOriginalNames) {
      const { filePathName: targetEntityFilePathName } = this.sanitizeNameForFilePathAndAlias(targetEntityOriginalName);
      if (createdPagesForThisRun.has(targetEntityFilePathName)) {
        continue;
      }
      const relationsWhereThisEntityIsTarget = collectedRelationships.filter((r) => r.SubprocessorName === targetEntityOriginalName);
      if (relationsWhereThisEntityIsTarget.length === 0) {
        continue;
      }
      const isEverUsedAsSubprocessor = relationsWhereThisEntityIsTarget.some((r) => r.RelationshipType === "uses_subprocessor");
      const isOwnEntityOfCurrentPrimaryProcessor = relationsWhereThisEntityIsTarget.some(
        (r) => r.PrimaryProcessor === processorName && r.RelationshipType === "is_own_entity"
      );
      let shouldCreatePage = false;
      if (isEverUsedAsSubprocessor) {
        shouldCreatePage = true;
      } else if (isOwnEntityOfCurrentPrimaryProcessor) {
        if (this.settings.createPagesForOwnEntities) {
          shouldCreatePage = true;
        } else {
        }
      }
      if (shouldCreatePage) {
        const clientRelationshipsForTargetEntityPage = collectedRelationships.filter(
          (r) => r.SubprocessorName === targetEntityOriginalName && r.RelationshipType === "uses_subprocessor"
        );
        await this.createOrUpdateSubprocessorFile(
          targetEntityOriginalName,
          // The name of the subprocessor/own_entity itself
          processorName,
          // The primary processor context (for logging/tracking, not for content of subprocessor's page directly)
          clientRelationshipsForTargetEntityPage
          // Relationships where this entity is the subprocessor
        );
        createdPagesForThisRun.add(targetEntityFilePathName);
      }
    }
    await this.updateAnalysisLogPage(processorName, processedUrlDetails, collectedRelationships, mergeDecisions);
    new import_obsidian.Notice(`Finished persisting info for ${processorName}.`);
  }
  async searchViaRightBrainDuckDuckGo(processorName, rbToken) {
    var _a;
    if (!this.settings.rightbrainDuckDuckGoSearchTaskId) {
      new import_obsidian.Notice("DuckDuckGo Search Task ID is not configured. Please run the setup command or configure it in settings.", 1e4);
      return [];
    }
    const searchTaskId = this.settings.rightbrainDuckDuckGoSearchTaskId;
    const searchQueries = this.generateSearchQueries(processorName);
    const allResults = [];
    const queriesToProcess = searchQueries.slice(0, Math.min(searchQueries.length, 2));
    new import_obsidian.Notice(`Performing up to ${queriesToProcess.length} DuckDuckGo searches for ${processorName}...`, 5e3);
    for (const query of queriesToProcess) {
      const duckDuckGoUrl = `https://duckduckgo.com/?q=${encodeURIComponent(query)}&ia=web&kl=us-en&kp=-2`;
      const taskInputPayload = {
        search_url_to_process: duckDuckGoUrl,
        target_company_name: processorName
      };
      if (this.settings.verboseDebug) {
        console.log(`Calling RightBrain Task ${searchTaskId} for DDG search. URL: ${duckDuckGoUrl}, Target: ${processorName}`);
      }
      const taskRunResult = await this.callRightBrainTask(searchTaskId, taskInputPayload, rbToken);
      if (this.settings.verboseDebug && taskRunResult) {
        console.log(`Full RightBrain Response for DDG search query "${query}":`, JSON.stringify(taskRunResult, null, 2));
      }
      if (((_a = taskRunResult == null ? void 0 : taskRunResult.response) == null ? void 0 : _a.search_results) && Array.isArray(taskRunResult.response.search_results)) {
        const resultsList = taskRunResult.response.search_results;
        for (const result of resultsList) {
          if (result.url && result.title && (String(result.url).startsWith("http://") || String(result.url).startsWith("https://"))) {
            allResults.push({
              processorName,
              searchQuery: query,
              title: String(result.title),
              url: String(result.url),
              snippet: String(result.snippet || ""),
              documentType: "duckduckgo_rb_search_result"
            });
          }
        }
        if (this.settings.verboseDebug) {
          console.log(`Successfully processed ${resultsList.length} search results for query "${query}"`);
        }
      } else {
        new import_obsidian.Notice(`DDG search via RB for "${query.substring(0, 20)}..." yielded no valid results.`, 3e3);
        if (this.settings.verboseDebug) {
          console.warn(`RB Task for DDG Search for query "${query}" did not return expected '{ "search_results": [...] }' array or failed. Full taskRunResult:`, taskRunResult);
        }
      }
      await new Promise((resolve) => setTimeout(resolve, 700 + Math.random() * 500));
    }
    if (this.settings.verboseDebug) console.log(`searchViaRightBrainDuckDuckGo collected ${allResults.length} filtered candidates for ${processorName}`);
    return allResults;
  }
  async fetchProcessorSearchDataWithDiscovery(processorName) {
    const collectedRelationships = [];
    const seenRelationshipsInCurrentSearch = /* @__PURE__ */ new Set();
    const processedUrlDetails = [];
    let candidateUrlsInfo = [];
    let flaggedCandidateUrlCount = 0;
    const rbToken = await this.getRightBrainAccessToken();
    if (!rbToken) {
      new import_obsidian.Notice("Could not get RightBrain Access Token. Aborting discovery.", 7e3);
      return null;
    }
    if (this.settings.serpApiKey) {
      new import_obsidian.Notice(`Using SerpAPI for primary search for: ${processorName}`, 5e3);
      const searchQueries = this.generateSearchQueries(processorName);
      const serpApiResults = await this.searchSerpApiForDpas(processorName, searchQueries, this.settings.maxResultsPerProcessor);
      candidateUrlsInfo.push(...serpApiResults);
    } else if (this.settings.rightbrainOrgId && this.settings.rightbrainProjectId) {
      new import_obsidian.Notice(`SerpAPI key not configured. Using DuckDuckGo (Filtered Extractor Task) via RightBrain for: ${processorName}`, 5e3);
      candidateUrlsInfo = await this.searchViaRightBrainDuckDuckGo(processorName, rbToken);
    } else {
      new import_obsidian.Notice("No search method configured (SerpAPI or RightBrain for DDG). Aborting discovery.", 7e3);
    }
    const hardcodedTestUrls = {
      // "openai": [{ title: "Test OpenAI SubP List", url: "https://example.com/openai-subp", snippet: "", processorName: "openai", documentType: "hardcoded_test" }],
    };
    if (this.settings.verboseDebug && hardcodedTestUrls[processorName.toLowerCase()]) {
      if (this.settings.verboseDebug) console.log(`Adding hardcoded test URLs for ${processorName}`);
      candidateUrlsInfo.push(...hardcodedTestUrls[processorName.toLowerCase()]);
    }
    const additionalUrlsFromCandidatePages = [];
    const pagesToScanForMoreLinks = candidateUrlsInfo.filter(
      (item) => item.documentType === "dpa_or_subprocessor_list" || SUBPROCESSOR_URL_KEYWORDS.some((kw) => item.url.toLowerCase().includes(kw))
    );
    for (const pageItem of pagesToScanForMoreLinks) {
      const extracted = await this.extractUrlsFromDpaPage(pageItem.url, processorName, pageItem.title);
      additionalUrlsFromCandidatePages.push(...extracted);
    }
    candidateUrlsInfo.push(...additionalUrlsFromCandidatePages);
    const uniqueCandidateUrls = /* @__PURE__ */ new Map();
    candidateUrlsInfo.forEach((item) => {
      if (item.url && (item.url.startsWith("http://") || item.url.startsWith("https://")) && !uniqueCandidateUrls.has(item.url.replace(/\/$/, ""))) {
        uniqueCandidateUrls.set(item.url.replace(/\/$/, ""), item);
      }
    });
    const uniqueUrlsToProcess = Array.from(uniqueCandidateUrls.values());
    if (this.settings.verboseDebug) console.log(`Total unique URLs to verify for ${processorName}: ${uniqueUrlsToProcess.length}`);
    if (uniqueUrlsToProcess.length === 0 && candidateUrlsInfo.length > 0) {
      if (this.settings.verboseDebug) console.warn(`All candidate URLs were invalid or duplicates for ${processorName}. Original count: ${candidateUrlsInfo.length}`);
    } else if (uniqueUrlsToProcess.length === 0) {
      new import_obsidian.Notice(`No candidate URLs found to process for ${processorName}.`);
    }
    for (const urlInfo of uniqueUrlsToProcess) {
      if (processedUrlDetails.some((p) => p.url.replace(/\/$/, "") === urlInfo.url.replace(/\/$/, ""))) {
        if (this.settings.verboseDebug) console.log(`URL ${urlInfo.url} already processed in processedUrlDetails, skipping re-verification.`);
        continue;
      }
      let currentUrlExtractedCount = 0;
      let currentProcessedUrlInfo = { ...urlInfo, documentType: urlInfo.documentType || "duckduckgo_rb_search_result" };
      const verificationResult = await this.verifySubprocessorListUrl(urlInfo.url, processorName, rbToken);
      currentProcessedUrlInfo = {
        ...currentProcessedUrlInfo,
        verificationMethod: "rightbrain",
        isList: (verificationResult == null ? void 0 : verificationResult.isList) || false,
        isCurrent: (verificationResult == null ? void 0 : verificationResult.isCurrent) || false,
        verificationReasoning: (verificationResult == null ? void 0 : verificationResult.reasoning) || "N/A"
      };
      if ((verificationResult == null ? void 0 : verificationResult.isList) && verificationResult.isCurrent && verificationResult.isCorrectProcessor) {
        currentProcessedUrlInfo.documentType = "verified_current_subprocessor_list";
        if (verificationResult.pageContent) {
          const extractionResult = await this.extractEntitiesFromPageContent(verificationResult.pageContent, rbToken);
          if (extractionResult) {
            const { thirdPartySubprocessors, ownEntities } = extractionResult;
            thirdPartySubprocessors.forEach((e) => {
              currentUrlExtractedCount += this.addRelationship(collectedRelationships, seenRelationshipsInCurrentSearch, processorName, e, "uses_subprocessor", urlInfo.url, verificationResult.reasoning);
            });
            ownEntities.forEach((e) => {
              currentUrlExtractedCount += this.addRelationship(collectedRelationships, seenRelationshipsInCurrentSearch, processorName, e, "is_own_entity", urlInfo.url, verificationResult.reasoning);
            });
          } else {
            currentProcessedUrlInfo.documentType = "verified_current_subprocessor_list (rb_extraction_failed)";
          }
        } else {
          currentProcessedUrlInfo.documentType = "verified_current_subprocessor_list (no_content_for_extraction)";
        }
        currentProcessedUrlInfo.extractedSubprocessorsCount = currentUrlExtractedCount;
        processedUrlDetails.push(currentProcessedUrlInfo);
        if (currentUrlExtractedCount > 0) {
          if (this.settings.verboseDebug) console.log(`Found and processed a valid subprocessor list at ${urlInfo.url}. Stopping search.`);
          new import_obsidian.Notice(`Found valid list for ${processorName}. Finishing process.`);
          break;
        }
      } else {
        const urlLower = urlInfo.url.toLowerCase();
        const containsKeyword = SUBPROCESSOR_URL_KEYWORDS.some((keyword) => urlLower.includes(keyword));
        if (!(verificationResult == null ? void 0 : verificationResult.isList) && containsKeyword) {
          currentProcessedUrlInfo.documentType = "keyword_match_not_verified_list";
          flaggedCandidateUrlCount++;
        } else if ((verificationResult == null ? void 0 : verificationResult.isList) && !verificationResult.isCorrectProcessor) {
          currentProcessedUrlInfo.documentType = "verified_list_for_wrong_processor";
          flaggedCandidateUrlCount++;
        } else if (verificationResult == null ? void 0 : verificationResult.isList) {
          currentProcessedUrlInfo.documentType = "verified_subprocessor_list (not_current)";
        } else {
          currentProcessedUrlInfo.documentType = "not_a_subprocessor_list";
        }
        currentProcessedUrlInfo.extractedSubprocessorsCount = 0;
        processedUrlDetails.push(currentProcessedUrlInfo);
      }
    }
    return { collectedRelationships, processedUrlDetails, flaggedCandidateUrlCount };
  }
  async fetchDataFromDirectUrl(processorName, listUrl) {
    if (this.settings.verboseDebug) console.log(`Fetching data from direct URL for ${processorName}: ${listUrl}`);
    if (!this.isValidUrl(listUrl, processorName)) {
      new import_obsidian.Notice(`The provided URL for ${processorName} is not valid: ${listUrl}`);
      return null;
    }
    const collectedRelationships = [];
    const seenRelationshipsInCurrentSearch = /* @__PURE__ */ new Set();
    const processedUrlDetails = [];
    let flaggedCandidateUrlCount = 0;
    const directUrlInfoBase = {
      // Base info for this manually provided URL
      title: `Manually Provided List for ${processorName}`,
      url: listUrl,
      snippet: "Manually provided URL",
      processorName,
      documentType: "direct_input_list"
    };
    let currentProcessedUrlInfo = { ...directUrlInfoBase, url: listUrl, documentType: "direct_input_list" };
    const rbToken = await this.getRightBrainAccessToken();
    if (!rbToken) {
      new import_obsidian.Notice("Could not obtain RightBrain token for direct URL processing.");
      currentProcessedUrlInfo.verificationMethod = "N/A (No RB Token)";
      processedUrlDetails.push(currentProcessedUrlInfo);
      return { collectedRelationships, processedUrlDetails, flaggedCandidateUrlCount };
    }
    let currentUrlExtractedCount = 0;
    const verificationResult = await this.verifySubprocessorListUrl(listUrl, processorName, rbToken);
    currentProcessedUrlInfo.verificationMethod = "rightbrain";
    currentProcessedUrlInfo.isList = (verificationResult == null ? void 0 : verificationResult.isList) || false;
    currentProcessedUrlInfo.isCurrent = (verificationResult == null ? void 0 : verificationResult.isCurrent) || false;
    currentProcessedUrlInfo.verificationReasoning = (verificationResult == null ? void 0 : verificationResult.reasoning) || "N/A";
    if (verificationResult && verificationResult.isList && verificationResult.isCurrent) {
      new import_obsidian.Notice(`Verified manual URL: ${listUrl} as current list.`);
      currentProcessedUrlInfo.documentType = "verified_current_subprocessor_list (manual_url_input)";
      if (verificationResult.pageContent) {
        const extractionResult = await this.extractEntitiesFromPageContent(verificationResult.pageContent, rbToken);
        if (extractionResult) {
          const { thirdPartySubprocessors, ownEntities } = extractionResult;
          thirdPartySubprocessors.forEach((e) => {
            currentUrlExtractedCount += this.addRelationship(collectedRelationships, seenRelationshipsInCurrentSearch, processorName, e, "uses_subprocessor", listUrl, verificationResult.reasoning);
          });
          ownEntities.forEach((e) => {
            currentUrlExtractedCount += this.addRelationship(collectedRelationships, seenRelationshipsInCurrentSearch, processorName, e, "is_own_entity", listUrl, verificationResult.reasoning);
          });
        } else {
          currentProcessedUrlInfo.documentType = "verified_current_subprocessor_list (manual_url_input_rb_extraction_failed)";
        }
      } else {
        currentProcessedUrlInfo.documentType = "verified_current_subprocessor_list (manual_url_input_no_content)";
      }
    } else {
      const urlLower = listUrl.toLowerCase();
      const containsKeyword = SUBPROCESSOR_URL_KEYWORDS.some((keyword) => urlLower.includes(keyword));
      if (!(verificationResult == null ? void 0 : verificationResult.isList) && containsKeyword) {
        currentProcessedUrlInfo.documentType = "keyword_match_not_verified_list (manual_url_input)";
        flaggedCandidateUrlCount++;
        new import_obsidian.Notice(`Manual URL ${listUrl} looks like a subprocessor list but couldn't be verified. Reason: ${this.scrubHyperlinks(verificationResult == null ? void 0 : verificationResult.reasoning) || "Details unavailable."}`);
        if (this.settings.verboseDebug) console.log(`Flagged Manual URL (keyword match, not verified): ${listUrl}`);
      } else if (verificationResult == null ? void 0 : verificationResult.isList) {
        currentProcessedUrlInfo.documentType = "verified_subprocessor_list (manual_url_input_not_current)";
        new import_obsidian.Notice(`Manual URL ${listUrl} verified as a list, but not current. Reason: ${this.scrubHyperlinks(verificationResult == null ? void 0 : verificationResult.reasoning) || "Details unavailable."}`);
      } else {
        currentProcessedUrlInfo.documentType = "not_a_subprocessor_list (manual_url_input)";
        new import_obsidian.Notice(`Manual URL ${listUrl} could not be verified as a list. Reason: ${this.scrubHyperlinks(verificationResult == null ? void 0 : verificationResult.reasoning) || "Details unavailable."}`);
      }
    }
    currentProcessedUrlInfo.extractedSubprocessorsCount = currentUrlExtractedCount;
    processedUrlDetails.push(currentProcessedUrlInfo);
    return { collectedRelationships, processedUrlDetails, flaggedCandidateUrlCount };
  }
  async fetchDataFromPastedText(processorName, pastedText) {
    if (this.settings.verboseDebug) console.log(`Fetching data from pasted text for ${processorName}`);
    if (!this.settings.rightbrainExtractEntitiesTaskId) {
      new import_obsidian.Notice("RightBrain Task ID for entity extraction is not configured. Please set it in plugin settings.");
      return null;
    }
    const collectedRelationships = [];
    const seenRelationshipsInCurrentSearch = /* @__PURE__ */ new Set();
    const processedUrlDetails = [];
    const rbToken = await this.getRightBrainAccessToken();
    if (!rbToken) {
      new import_obsidian.Notice("Could not obtain RightBrain token for pasted text processing.");
      processedUrlDetails.push({
        url: `text_input_for_${this.sanitizeNameForFilePathAndAlias(processorName).filePathName}`,
        // Placeholder URL for logging
        title: `Pasted Text for ${processorName}`,
        documentType: "manual_text_submission_failed (no_rb_token)"
        // No verification details applicable here as the process couldn't start
      });
      return { collectedRelationships, processedUrlDetails, flaggedCandidateUrlCount: 0 };
    }
    const taskInput = { [this.settings.rightbrainExtractInputField]: pastedText };
    const extractionResult = await this.callRightBrainTask(this.settings.rightbrainExtractEntitiesTaskId, taskInput, rbToken);
    let currentUrlExtractedCount = 0;
    const sourcePlaceholder = `manual_text_input:${processorName}`;
    if (extractionResult && typeof extractionResult.response === "object" && extractionResult.response !== null) {
      const rbResponse = extractionResult.response;
      const thirdParty = rbResponse[this.settings.rightbrainExtractOutputThirdPartyField] || [];
      const own = rbResponse[this.settings.rightbrainExtractOutputOwnEntitiesField] || [];
      thirdParty.forEach((e) => {
        currentUrlExtractedCount += this.addRelationship(collectedRelationships, seenRelationshipsInCurrentSearch, processorName, e, "uses_subprocessor", sourcePlaceholder, "Processed from manually pasted text.");
      });
      own.forEach((e) => {
        currentUrlExtractedCount += this.addRelationship(collectedRelationships, seenRelationshipsInCurrentSearch, processorName, e, "is_own_entity", sourcePlaceholder, "Processed from manually pasted text.");
      });
      processedUrlDetails.push({
        url: sourcePlaceholder,
        title: `Pasted Text for ${processorName}`,
        documentType: "manual_text_submission_processed",
        verificationMethod: "rightbrain_text_task",
        extractedSubprocessorsCount: currentUrlExtractedCount,
        verificationReasoning: `Extracted ${currentUrlExtractedCount} entities from pasted text.`
      });
    } else {
      new import_obsidian.Notice(`Failed to extract entities from pasted text for ${processorName}. Check console.`);
      console.error(`ProcessorProcessor: RB Extract From Text task did not return expected 'response' object or failed. Full task result:`, JSON.stringify(extractionResult).substring(0, 500));
      processedUrlDetails.push({
        url: sourcePlaceholder,
        title: `Pasted Text for ${processorName}`,
        documentType: "manual_text_submission_failed (rb_task_error)",
        verificationMethod: "rightbrain_text_task",
        verificationReasoning: "RightBrain task for text processing failed or returned an unexpected response."
      });
    }
    return { collectedRelationships, processedUrlDetails, flaggedCandidateUrlCount: 0 };
  }
  async ensureFolderExists(folderPath) {
    try {
      const normalizedPath = folderPath.startsWith("/") ? folderPath.substring(1) : folderPath;
      if (normalizedPath === "") return;
      const abstractFolderPath = this.app.vault.getAbstractFileByPath(normalizedPath);
      if (!abstractFolderPath) {
        await this.app.vault.createFolder(normalizedPath);
        if (this.settings.verboseDebug) console.log(`Folder created: ${normalizedPath}`);
      }
    } catch (e) {
      console.error(`Error ensuring folder ${folderPath} exists:`, e);
      new import_obsidian.Notice(`Error creating folder: ${folderPath}`);
    }
  }
  async ensureProcessorFile(originalProcessorName, addFrontmatter = false, isTopLevelProcessor = true) {
    var _a;
    await this.ensureFolderExists(this.settings.processorsFolderPath);
    const { filePathName, originalNameAsAlias } = this.sanitizeNameForFilePathAndAlias(originalProcessorName);
    const folder = this.settings.processorsFolderPath.startsWith("/") ? this.settings.processorsFolderPath.substring(1) : this.settings.processorsFolderPath;
    const filePath = `${folder}/${filePathName}.md`;
    let file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file) {
      try {
        let initialContent = "";
        if (addFrontmatter) {
          const tag = isTopLevelProcessor ? "processor" : "subprocessor";
          const aliasForFrontmatter = originalNameAsAlias.replace(/[:\[\],"]/g, "");
          initialContent = `---
tags: [${tag}]
aliases: ["${aliasForFrontmatter}"]
---

# ${originalNameAsAlias}

`;
        } else {
          initialContent = `# ${originalNameAsAlias}

`;
        }
        file = await this.app.vault.create(filePath, initialContent);
      } catch (e) {
        if ((_a = e.message) == null ? void 0 : _a.toLowerCase().includes("file already exists")) {
          file = this.app.vault.getAbstractFileByPath(filePath);
          if (!file) {
            console.error(`Failed to get file ${filePath} after 'already exists' error.`);
            return null;
          }
        } else {
          console.error(`Error creating processor file ${filePath}:`, e);
          return null;
        }
      }
    }
    if (file && addFrontmatter) {
      const tag = isTopLevelProcessor ? "processor" : "subprocessor";
      const aliasForFrontmatter = originalNameAsAlias.replace(/[:\[\],"]/g, "");
      await this.app.vault.process(file, (content) => {
        let newContent = this.updateFrontmatter(content, { tags: [tag], aliases: [aliasForFrontmatter] }, originalNameAsAlias);
        if (!newContent.trim().includes(`# ${originalNameAsAlias}`)) {
          const bodyStartIndex = newContent.indexOf("\n---") > 0 ? newContent.indexOf("\n---", newContent.indexOf("\n---") + 3) + 4 : 0;
          const body = newContent.substring(bodyStartIndex);
          const frontmatterPart = newContent.substring(0, bodyStartIndex);
          newContent = frontmatterPart + (frontmatterPart.endsWith("\n") ? "" : "\n") + `# ${originalNameAsAlias}

` + body.trimStart();
        }
        return newContent;
      });
    }
    return file;
  }
  async updateProcessorFile(file, originalProcessorName, relationships, isTopLevelProcessor) {
    const subprocessorsHeading = "Subprocessors";
    let tableMd = `| Subprocessor Entity Name | Processing Function | Location |
`;
    tableMd += `|---|---|---|
`;
    const relevantRelationships = relationships.filter((r) => r.RelationshipType === "uses_subprocessor" && r.PrimaryProcessor === originalProcessorName);
    relevantRelationships.forEach((rel) => {
      const { filePathName: subFilePathName, originalNameAsAlias: subOriginalName } = this.sanitizeNameForFilePathAndAlias(rel.SubprocessorName);
      const markdownAlias = subOriginalName.replace(/\n/g, " ").replace(/[\[\]()|]/g, "");
      const processorsFolder = this.settings.processorsFolderPath;
      const markdownLinkTarget = encodeURI(`${processorsFolder}/${subFilePathName}.md`);
      const subprocessorPageLink = `[${markdownAlias}](${markdownLinkTarget})`;
      const processingFunctionDisplay = (rel.ProcessingFunction || "N/A").replace(/\n/g, "<br>").replace(/\|/g, "\\|");
      const locationDisplay = (rel.Location || "N/A").replace(/\n/g, "<br>").replace(/\|/g, "\\|");
      tableMd += `| ${subprocessorPageLink} | ${processingFunctionDisplay} | ${locationDisplay} |
`;
    });
    const analysisLogsHeading = "Analysis Logs";
    const { filePathName: logFilePathNamePart } = this.sanitizeNameForFilePathAndAlias(originalProcessorName);
    const analysisLogsFolder = this.settings.analysisLogsFolderPath;
    const logFileName = `${logFilePathNamePart} Subprocessor Logs.md`;
    const logFileLinkTarget = encodeURI(`${analysisLogsFolder}/${logFileName}`);
    const logFileLink = `[[${analysisLogsFolder}/${logFileName}|${originalProcessorName} Subprocessor Logs]]`;
    const analysisLogSection = `
- ${logFileLink}
`;
    await this.app.vault.process(file, (content) => {
      const tag = isTopLevelProcessor ? "processor" : "subprocessor";
      let newContent = this.updateFrontmatter(content, { tags: [tag], aliases: [originalProcessorName.replace(/[:\[\],"]/g, "")] }, originalProcessorName);
      if (!newContent.trim().includes(`# ${originalProcessorName}`)) {
        const bodyStartIndex = newContent.indexOf("\n---") > 0 ? newContent.indexOf("\n---", newContent.indexOf("\n---") + 3) + 4 : 0;
        const body = newContent.substring(bodyStartIndex);
        const frontmatterPart = newContent.substring(0, bodyStartIndex);
        newContent = frontmatterPart + (frontmatterPart.endsWith("\n") ? "" : "\n") + `# ${originalProcessorName}

` + body.trimStart();
      }
      newContent = this.ensureHeadingAndSection(newContent, subprocessorsHeading, tableMd, null, null);
      newContent = this.ensureHeadingAndSection(newContent, analysisLogsHeading, analysisLogSection, null, null, true);
      return newContent;
    });
  }
  async createOrUpdateSubprocessorFile(originalSubprocessorName, originalPrimaryProcessorNameForContext, newClientRelationships) {
    var _a;
    await this.ensureFolderExists(this.settings.processorsFolderPath);
    const { filePathName: subFilePathName, originalNameAsAlias: subOriginalNameAsAlias } = this.sanitizeNameForFilePathAndAlias(originalSubprocessorName);
    const folder = this.settings.processorsFolderPath.startsWith("/") ? this.settings.processorsFolderPath.substring(1) : this.settings.processorsFolderPath;
    const subFilePath = `${folder}/${subFilePathName}.md`;
    let file = this.app.vault.getAbstractFileByPath(subFilePath);
    if (!file) {
      const aliasForFrontmatter = subOriginalNameAsAlias.replace(/[:\[\],"]/g, "");
      const initialContent = `---
tags: [subprocessor]
aliases: ["${aliasForFrontmatter}"]
---

# ${subOriginalNameAsAlias}

## Used By

`;
      try {
        file = await this.app.vault.create(subFilePath, initialContent);
      } catch (e) {
        if ((_a = e.message) == null ? void 0 : _a.toLowerCase().includes("file already exists")) {
          file = this.app.vault.getAbstractFileByPath(subFilePath);
          if (!file) {
            console.error(`Failed to get subprocessor file ${subFilePath} after 'already exists' error.`);
            return;
          }
        } else {
          console.error(`Error creating subprocessor file ${subFilePath}:`, e);
          return;
        }
      }
    }
    if (!file) return;
    await this.app.vault.process(file, (content) => {
      let newContent = this.updateFrontmatter(content, { tags: ["subprocessor"], aliases: [subOriginalNameAsAlias.replace(/[:\[\],"]/g, "")] }, subOriginalNameAsAlias);
      if (!newContent.trim().includes(`# ${subOriginalNameAsAlias}`)) {
        const bodyStartIndex = newContent.indexOf("\n---") > 0 ? newContent.indexOf("\n---", newContent.indexOf("\n---") + 3) + 4 : 0;
        const body = newContent.substring(bodyStartIndex);
        const frontmatterPart = newContent.substring(0, bodyStartIndex);
        newContent = frontmatterPart + (frontmatterPart.endsWith("\n") ? "" : "\n") + `# ${subOriginalNameAsAlias}

` + body.trimStart();
      }
      const usedByHeading = "Used By";
      const existingRows = this.extractClientTableRows(content);
      const allRows = new Set(existingRows);
      newClientRelationships.forEach((rel) => {
        const { originalNameAsAlias: primaryOriginalName } = this.sanitizeNameForFilePathAndAlias(rel.PrimaryProcessor);
        const primaryProcessorPlainText = primaryOriginalName.replace(/\|/g, "\\|");
        const processingFunctionDisplay = (rel.ProcessingFunction || "N/A").replace(/\n/g, "<br>").replace(/\|/g, "\\|");
        const locationDisplay = (rel.Location || "N/A").replace(/\n/g, "<br>").replace(/\|/g, "\\|");
        const sourceUrlLink = rel.SourceURL.startsWith("http") ? `[Source](${rel.SourceURL})` : rel.SourceURL;
        const rowContent = ` ${primaryProcessorPlainText} | ${processingFunctionDisplay} | ${locationDisplay} | ${sourceUrlLink} `;
        allRows.add(rowContent);
      });
      let clientTableMd = `| Primary Processor | Processing Function | Location | Source URL |
`;
      clientTableMd += `|---|---|---|---|
`;
      allRows.forEach((row) => {
        clientTableMd += `|${row}|
`;
      });
      newContent = this.ensureHeadingAndSection(newContent, usedByHeading, clientTableMd, null, null);
      return newContent;
    });
  }
  updateFrontmatter(content, updates, pageNameForAlias) {
    let fm = {};
    const fmRegex = /^---\s*\n([\s\S]*?)\n---\s*\n/;
    const match = content.match(fmRegex);
    let body = content;
    if (match && match[1]) {
      try {
        const yamlLines = match[1].split("\n");
        yamlLines.forEach((line) => {
          const parts = line.split(":");
          if (parts.length >= 2) {
            const key = parts[0].trim();
            const value = parts.slice(1).join(":").trim();
            if (key === "tags" || key === "aliases") {
              if (value.startsWith("[") && value.endsWith("]")) {
                fm[key] = value.substring(1, value.length - 1).split(",").map((s) => s.trim().replace(/^["']|["']$/g, ""));
              } else {
                fm[key] = [value.replace(/^["']|["']$/g, "")];
              }
            } else {
              fm[key] = value.replace(/^["']|["']$/g, "");
            }
          }
        });
      } catch (e) {
        console.warn("ProcessorProcessor: Could not parse existing frontmatter, will overwrite relevant keys.", e);
        fm = {};
      }
      body = content.substring(match[0].length);
    }
    if (updates.tags) {
      const currentTags = new Set(Array.isArray(fm.tags) ? fm.tags.map((t) => String(t).toLowerCase()) : []);
      updates.tags.forEach((tag) => currentTags.add(String(tag).toLowerCase()));
      fm.tags = Array.from(currentTags);
    }
    if (updates.aliases) {
      const currentAliases = new Set(Array.isArray(fm.aliases) ? fm.aliases.map((a) => String(a)) : []);
      updates.aliases.forEach((alias) => {
        const sanitizedAlias = String(alias).replace(/[:\[\],"]/g, "");
        if (sanitizedAlias) currentAliases.add(sanitizedAlias);
      });
      const sanitizedPageNameAlias = String(pageNameForAlias).replace(/[:\[\],"]/g, "");
      if (sanitizedPageNameAlias) currentAliases.add(sanitizedPageNameAlias);
      fm.aliases = Array.from(currentAliases);
    }
    let fmString = "---\n";
    for (const key in fm) {
      if (fm.hasOwnProperty(key)) {
        if (Array.isArray(fm[key])) {
          if (fm[key].length > 0) {
            fmString += `${key}: [${fm[key].map((item) => `"${item}"`).join(", ")}]
`;
          }
        } else {
          fmString += `${key}: "${fm[key]}"
`;
        }
      }
    }
    fmString += "---\n";
    if (fmString === "---\n---\n" && !match) {
      return body;
    }
    return fmString + body;
  }
  async updateAnalysisLogPage(processorName, processedUrls, relationships, mergeDecisions) {
    await this.ensureFolderExists(this.settings.analysisLogsFolderPath);
    const { filePathName: sanitizedProcessorNameForLogFile } = this.sanitizeNameForFilePathAndAlias(processorName);
    const logsFolder = this.settings.analysisLogsFolderPath;
    const logFileName = `${sanitizedProcessorNameForLogFile} Subprocessor Logs.md`;
    const logFilePath = `${logsFolder}/${logFileName}`;
    const logEntryContent = this.formatResultsForObsidianLog(processorName, relationships, processedUrls, mergeDecisions);
    await this.writeResultsToObsidianNote(logFilePath, logEntryContent, "ensure_exists_and_append", processorName);
  }
  ensureHeadingAndSection(content, headingText, sectionNewContent, startMarker = null, endMarker = null, appendUnderHeadingIfNoMarkers = false) {
    const headingRegex = new RegExp(`^(#+)\\s*${headingText.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}(\\s*\\n|$)`, "im");
    const headingMatch = content.match(headingRegex);
    const sectionWithHeading = `
## ${headingText}
${sectionNewContent.trim()}
`;
    if (startMarker && endMarker) {
      const startIdx = content.indexOf(startMarker);
      const endIdx = content.indexOf(endMarker);
      if (startIdx !== -1 && endIdx !== -1 && startIdx < endIdx) {
        return content.substring(0, startIdx + startMarker.length) + `
${sectionNewContent.trim()}
` + // Ensure new content is on new lines
        content.substring(endIdx);
      }
    }
    if (headingMatch) {
      const headingLevel = headingMatch[1].length;
      const nextHeadingRegex = new RegExp(`^#{1,${headingLevel}}\\s+.*(\\s*\\n|$)`, "im");
      let startIndexAfterHeading = headingMatch.index + headingMatch[0].length;
      let contentAfterHeading = content.substring(startIndexAfterHeading);
      let endIndex = content.length;
      const nextMatch = contentAfterHeading.match(nextHeadingRegex);
      if (nextMatch) {
        endIndex = startIndexAfterHeading + nextMatch.index;
      }
      if (appendUnderHeadingIfNoMarkers) {
        return content.substring(0, endIndex) + // Content up to where next section would start (or end of doc)
        `
${sectionNewContent.trim()}
` + // Append new stuff
        content.substring(endIndex);
      } else {
        return content.substring(0, startIndexAfterHeading) + `${sectionNewContent.trim()}
` + content.substring(endIndex);
      }
    } else {
      return content.trimEnd() + "\n\n" + sectionWithHeading.trimStart();
    }
  }
  formatResultsForObsidianLog(processorName, relationships, processedUrls, mergeDecisions = []) {
    let logContent = `
---
### Log Entry: ${(/* @__PURE__ */ new Date()).toISOString()} for ${processorName}

`;
    if (mergeDecisions.length > 0) {
      logContent += `#### Proactive Deduplication Decisions (${mergeDecisions.length}):
`;
      mergeDecisions.forEach((decision) => {
        logContent += `- ${decision}
`;
      });
      logContent += "\n";
    }
    logContent += `#### Processed URLs (${processedUrls.length}):
`;
    if (processedUrls.length === 0) {
      logContent += "- No URLs were processed.\n";
    } else {
      logContent += "| URL | Title | Type | Verified List? | Current? | Extracted # | Reasoning |\n";
      logContent += "|---|---|---|---|---|---|---|\n";
      processedUrls.forEach((url) => {
        const titleDisplay = this.scrubHyperlinks(url.title || "N/A").substring(0, 70);
        const urlLink = url.url.startsWith("http") ? `[Link](${url.url})` : url.url;
        const reasoningDisplay = this.scrubHyperlinks(url.verificationReasoning || "N/A").substring(0, 100);
        logContent += `| ${urlLink} | ${titleDisplay}... | ${url.documentType || "N/A"} | ${url.isList ? "Yes" : "No"} | ${url.isCurrent ? "Yes" : "No"} | ${url.extractedSubprocessorsCount || 0} | ${reasoningDisplay}... |
`;
      });
    }
    logContent += "\n";
    logContent += `#### Extracted Relationships (${relationships.length}):
`;
    if (relationships.length === 0) {
      logContent += "- No new relationships were extracted in this run.\n";
    } else {
      logContent += "| Primary Processor | Target Entity | Type | Function | Location | Source URL |\n";
      logContent += "|---|---|---|---|---|---|\n";
      relationships.forEach((rel) => {
        const targetEntityDisplay = this.scrubHyperlinks(rel.SubprocessorName).substring(0, 50);
        const primaryProcDisplay = this.scrubHyperlinks(rel.PrimaryProcessor).substring(0, 50);
        const funcDisplay = this.scrubHyperlinks(rel.ProcessingFunction).substring(0, 70);
        const locDisplay = this.scrubHyperlinks(rel.Location).substring(0, 50);
        const sourceUrlLink = rel.SourceURL.startsWith("http") ? `[Source](${rel.SourceURL})` : rel.SourceURL;
        logContent += `| ${primaryProcDisplay} | ${targetEntityDisplay} | ${rel.RelationshipType} | ${funcDisplay}... | ${locDisplay}... | ${sourceUrlLink} |
`;
      });
    }
    logContent += "\n";
    return logContent;
  }
  async writeResultsToObsidianNote(filePath, contentToAppendOrInitial, mode = "ensure_exists_and_append", processorNameForLogTitle) {
    var _a;
    let file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file && (mode === "ensure_exists_and_append" || mode === "overwrite")) {
      let initialContent = "";
      if (processorNameForLogTitle) {
        initialContent += `# Analysis Log: ${processorNameForLogTitle}

`;
      }
      initialContent += contentToAppendOrInitial;
      try {
        file = await this.app.vault.create(filePath, initialContent);
        if (this.settings.verboseDebug) console.log(`Log file created: ${filePath}`);
      } catch (e) {
        if ((_a = e.message) == null ? void 0 : _a.toLowerCase().includes("file already exists")) {
          file = this.app.vault.getAbstractFileByPath(filePath);
          if (!file) {
            console.error(`Failed to get log file ${filePath} after 'already exists' error.`);
            return;
          }
        } else {
          console.error(`Error creating log file ${filePath}:`, e);
          new import_obsidian.Notice(`Error creating log file: ${filePath}`);
          return;
        }
      }
      if (file && mode === "ensure_exists_and_append") {
        return;
      }
    }
    if (file) {
      if (mode === "overwrite") {
        let newContent = "";
        if (processorNameForLogTitle) {
          newContent += `# Analysis Log: ${processorNameForLogTitle}

`;
        }
        newContent += contentToAppendOrInitial;
        await this.app.vault.modify(file, newContent);
        if (this.settings.verboseDebug) console.log(`Log file overwritten: ${filePath}`);
      } else if (mode === "append" || mode === "ensure_exists_and_append" && file) {
        await this.app.vault.append(file, contentToAppendOrInitial);
        if (this.settings.verboseDebug) console.log(`Content appended to log file: ${filePath}`);
      }
    } else if (mode === "append") {
      new import_obsidian.Notice(`Log file ${filePath} not found. Cannot append.`);
      if (this.settings.verboseDebug) console.log(`Log file not found for append: ${filePath}`);
    }
  }
  async getRightBrainAccessToken(creds) {
    const clientId = (creds == null ? void 0 : creds.clientId) || this.settings.rightbrainClientId;
    const clientSecret = (creds == null ? void 0 : creds.clientSecret) || this.settings.rightbrainClientSecret;
    const oauthUrl = (creds == null ? void 0 : creds.oauthUrl) || this.settings.rightbrainOauth2Url;
    if (!clientId || !clientSecret) {
      new import_obsidian.Notice("RightBrain Client ID or Secret not configured.");
      return null;
    }
    if (this._rbToken && this._rbTokenExpiry > Date.now()) {
      if (this.settings.verboseDebug) console.log("Using cached RightBrain token.");
      return this._rbToken;
    }
    const tokenUrl = `${oauthUrl}/oauth2/token`;
    const bodyParams = new URLSearchParams();
    bodyParams.append("grant_type", "client_credentials");
    const credentials = `${clientId}:${clientSecret}`;
    const encodedCredentials = btoa(credentials);
    const headers = {
      "Authorization": `Basic ${encodedCredentials}`,
      "Content-Type": "application/x-www-form-urlencoded",
      "User-Agent": `ObsidianProcessorProcessorPlugin/${this.manifest.version}`
    };
    try {
      if (this.settings.verboseDebug) console.log("Requesting new RightBrain token.");
      const response = await (0, import_obsidian.requestUrl)({
        url: tokenUrl,
        method: "POST",
        headers,
        body: bodyParams.toString(),
        throw: false
      });
      if (response.status === 200 && response.json && response.json.access_token) {
        if (this.settings.verboseDebug) console.log("Successfully obtained new RightBrain token.");
        this._rbToken = response.json.access_token;
        this._rbTokenExpiry = Date.now() + (response.json.expires_in || 3600) * 1e3 - 6e5;
        return response.json.access_token;
      } else {
        console.error("ProcessorProcessor: Failed to get RightBrain token.", response.status, response.text);
        new import_obsidian.Notice(`Failed to get RightBrain token: ${response.status}.`);
        this._rbToken = null;
        this._rbTokenExpiry = 0;
        return null;
      }
    } catch (error) {
      console.error("ProcessorProcessor: Network error fetching RightBrain token:", error);
      new import_obsidian.Notice("Network error fetching RightBrain token.");
      this._rbToken = null;
      this._rbTokenExpiry = 0;
      return null;
    }
  }
  generateSearchQueries(processorName) {
    const cleanedName = processorName.replace(/\b(?:inc\.?|llc\.?|ltd\.?|corp\.?|gmbh\.?|incorporated|limited|corporation)\b/gi, "").replace(/[,.]/g, "").trim();
    return [
      `"${cleanedName}" sub-processor list`,
      `"${cleanedName}" subprocessors`,
      `"${cleanedName}" data processing addendum exhibit`,
      `"${cleanedName}" DPA subprocessors`,
      `"${cleanedName}" third-party vendors`,
      `"${cleanedName}" service providers list`,
      // More generic but sometimes useful for finding portals
      `"${cleanedName}" trust center subprocessors`,
      `"${cleanedName}" legal subprocessors`
      // If the name is short, broad searches might be too noisy.
      // Consider adding quotes around cleanedName if it contains spaces.
    ];
  }
  async searchSerpApiForDpas(processorName, queries, maxResultsSetting) {
    var _a, _b, _c;
    if (!this.settings.serpApiKey) {
      new import_obsidian.Notice("SerpAPI key not set. Cannot perform SerpAPI search.");
      return [];
    }
    const allResults = [];
    const processedUrls = /* @__PURE__ */ new Set();
    const queriesToRun = queries.slice(0, Math.min(queries.length, 3));
    new import_obsidian.Notice(`Searching SerpAPI for ${processorName} using ${queriesToRun.length} queries...`, 3e3);
    for (const query of queriesToRun) {
      if (allResults.length >= maxResultsSetting && maxResultsSetting > 0) {
        break;
      }
      const params = new URLSearchParams({
        api_key: this.settings.serpApiKey,
        q: query,
        engine: "google",
        // Or other engines like 'bing'
        num: "10"
        // Number of results per query (max 100 for Google, usually 10-20 is fine)
        // You can add other params like 'location', 'gl' (country), 'hl' (language) if needed
      });
      const serpApiUrl = `https://serpapi.com/search?${params.toString()}`;
      try {
        const response = await (0, import_obsidian.requestUrl)({ url: serpApiUrl, method: "GET", throw: false });
        if (response.status === 200 && response.json && response.json.organic_results) {
          const organicResults = response.json.organic_results;
          for (const result of organicResults) {
            if (result.link && !processedUrls.has(result.link)) {
              const urlLower = result.link.toLowerCase();
              const titleLower = ((_a = result.title) == null ? void 0 : _a.toLowerCase()) || "";
              const snippetLower = ((_b = result.snippet) == null ? void 0 : _b.toLowerCase()) || "";
              const isRelevant = SUBPROCESSOR_URL_KEYWORDS.some(
                (keyword) => urlLower.includes(keyword) || titleLower.includes(keyword) || snippetLower.includes(keyword)
              );
              if (isRelevant) {
                allResults.push({
                  processorName,
                  title: result.title || "No Title",
                  url: result.link,
                  snippet: result.snippet || "No Snippet",
                  searchQuery: query,
                  documentType: "serpapi_dpa_or_subprocessor_list_candidate"
                  // Mark as potential candidate
                });
                processedUrls.add(result.link);
                if (allResults.length >= maxResultsSetting && maxResultsSetting > 0) break;
              }
            }
          }
        } else {
          console.error(`SerpAPI error for query "${query}": ${response.status}`, (_c = response.text) == null ? void 0 : _c.substring(0, 200));
          new import_obsidian.Notice(`SerpAPI query failed for "${query.substring(0, 20)}...". Status: ${response.status}`);
        }
      } catch (error) {
        console.error(`Network error during SerpAPI search for query "${query}":`, error);
        new import_obsidian.Notice(`Network error during SerpAPI search for "${query.substring(0, 20)}...".`);
      }
      await new Promise((resolve) => setTimeout(resolve, 500 + Math.random() * 300));
    }
    if (this.settings.verboseDebug) console.log(`SerpAPI search for ${processorName} found ${allResults.length} relevant candidates.`);
    return allResults;
  }
  getCompanyDomain(processorName) {
    let name = processorName.toLowerCase();
    name = name.replace(/\b(?:inc\.?|llc\.?|ltd\.?|corp\.?|gmbh\.?)\b/g, "").trim();
    name = name.replace(/[,.]/g, "");
    try {
      if (name.includes(".") && !name.includes(" ")) {
        const url = new URL(name.startsWith("http") ? name : `http://${name}`);
        return url.hostname.replace(/^www\./, "");
      }
    } catch (e) {
    }
    const parts = name.split(/\s+/);
    if (parts.length > 1) {
      return "";
    }
    return name;
  }
  isValidUrl(url, processorNameContext = "") {
    if (!url || typeof url !== "string") return false;
    try {
      const parsedUrl = new URL(url);
      if (!["http:", "https:"].includes(parsedUrl.protocol)) {
        return false;
      }
      if (processorNameContext) {
        const processorDomain = this.getCompanyDomain(processorNameContext);
        if (processorDomain && !parsedUrl.hostname.toLowerCase().includes(processorDomain.replace(/^www\./, ""))) {
        }
      }
      return true;
    } catch (e) {
      return false;
    }
  }
  async extractUrlsFromDpaPage(pageUrl, processorNameContext, sourcePageTitle) {
    var _a;
    if (!this.settings.rightbrainVerifyUrlTaskId) {
      return [];
    }
    const rbToken = await this.getRightBrainAccessToken();
    if (!rbToken) return [];
    const extractedLinks = [];
    let pageContent = "";
    try {
      const response = await (0, import_obsidian.requestUrl)({ url: pageUrl, method: "GET", throw: false });
      if (response.status === 200) {
        pageContent = response.text;
      } else {
        return [];
      }
    } catch (e) {
      return [];
    }
    if (!pageContent) return [];
    const linkRegex = /<a\s+(?:[^>]*?\s+)?href="([^"]*)"/gi;
    let match;
    while ((match = linkRegex.exec(pageContent)) !== null) {
      let href = match[1].trim();
      if (href && !href.startsWith("#") && !href.startsWith("mailto:") && !href.startsWith("javascript:")) {
        try {
          const absoluteUrl = new URL(href, pageUrl).toString();
          if (this.isValidUrl(absoluteUrl, processorNameContext)) {
            const urlLower = absoluteUrl.toLowerCase();
            const titleOrTextLower = (((_a = match[0].match(/>(.*?)</)) == null ? void 0 : _a[1]) || "").toLowerCase();
            const isPotentialSubprocessorList = SUBPROCESSOR_URL_KEYWORDS.some(
              (keyword) => urlLower.includes(keyword) || titleOrTextLower.includes(keyword)
            );
            if (isPotentialSubprocessorList) {
              extractedLinks.push({
                processorName: processorNameContext,
                title: `Linked from: ${sourcePageTitle || pageUrl}`,
                url: absoluteUrl,
                snippet: `Found on page: ${pageUrl}`,
                documentType: "linked_subprocessor_list_candidate",
                sourceDpaUrl: pageUrl
              });
            }
          }
        } catch (e) {
        }
      }
    }
    return extractedLinks;
  }
  async callRightBrainTask(taskId, taskVariables, rbToken) {
    if (!taskId) {
      new import_obsidian.Notice("RightBrain Task ID is missing for the call.");
      console.error("ProcessorProcessor: Attempted to call RightBrain task with no Task ID.");
      return null;
    }
    if (!this.settings.rightbrainOrgId || !this.settings.rightbrainProjectId) {
      new import_obsidian.Notice("RightBrain Org ID or Project ID not set. Cannot call task.");
      console.error("ProcessorProcessor: RB OrgID or ProjectID missing for task call.");
      return null;
    }
    const taskRunUrl = `${this.settings.rightbrainApiUrl}/org/${this.settings.rightbrainOrgId}/project/${this.settings.rightbrainProjectId}/task/${taskId}/run`;
    const headers = {
      "Authorization": `Bearer ${rbToken}`,
      "Content-Type": "application/json",
      "User-Agent": `ObsidianProcessorProcessorPlugin/${this.manifest.version}`
    };
    const payload = {
      task_input: taskVariables
    };
    if (this.settings.verboseDebug) {
      console.log(`[callRightBrainTask] Sending Request to Task ID ${taskId.substring(0, 8)}... Payload:`, JSON.stringify(payload, null, 2));
    }
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: taskRunUrl,
        method: "POST",
        headers,
        body: JSON.stringify(payload),
        // Send the newly constructed payload
        throw: false
      });
      if (response.json && (response.status === 200 || response.status === 201)) {
        if (this.settings.verboseDebug) {
          console.log(`[callRightBrainTask] Success for Task ID ${taskId.substring(0, 8)}... Full Response:`, JSON.stringify(response.json, null, 2));
        }
        return response.json;
      } else {
        new import_obsidian.Notice(`RightBrain Task ${taskId.substring(0, 8)}... failed: ${response.status}. Check console.`, 7e3);
        console.error(`RB Task Call [${taskId}] Error: ${response.status}`, response.text ? response.text.substring(0, 1e3) : "No body", "Payload Sent:", payload);
        return null;
      }
    } catch (error) {
      new import_obsidian.Notice(`Network error calling RightBrain Task ${taskId.substring(0, 8)}.... Check console.`, 7e3);
      console.error(`RB Task Call [${taskId}] Network Error:`, error, "Payload Sent:", payload);
      return null;
    }
  }
  async verifySubprocessorListUrl(urlToVerify, processorName, rbToken) {
    if (!this.settings.rightbrainVerifyUrlTaskId) {
      new import_obsidian.Notice("RightBrain Verify URL Task ID is not configured. Cannot verify URL.");
      return null;
    }
    const taskInput = {
      "url_content": urlToVerify,
      "expected_processor_name": processorName
    };
    if (this.settings.verboseDebug) console.log(`Verifying URL ${urlToVerify} with RB Task ${this.settings.rightbrainVerifyUrlTaskId}. Input:`, JSON.stringify(taskInput));
    const taskResult = await this.callRightBrainTask(this.settings.rightbrainVerifyUrlTaskId, taskInput, rbToken);
    if (this.settings.verboseDebug) {
      console.log(`RB Verify Task [${this.settings.rightbrainVerifyUrlTaskId}] Full Result for URL ${urlToVerify}:`, JSON.stringify(taskResult, null, 2));
    }
    if (taskResult && typeof taskResult.response === "object" && taskResult.response !== null) {
      const rbResponse = taskResult.response;
      const isList = String(rbResponse.isSubprocessorList).toLowerCase() === "true";
      const isCorrectProcessor = String(rbResponse.isCorrectProcessor).toLowerCase() === "true";
      const isCurrent = String(rbResponse.isCurrentVersion).toLowerCase() === "true";
      const reasoning = rbResponse.reasoning || "N/A";
      let pageContent = void 0;
      if (taskResult.run_data && taskResult.run_data.submitted && typeof taskResult.run_data.submitted.url_content === "string" && taskResult.run_data.submitted.url_content.toLowerCase().includes("<html")) {
        pageContent = taskResult.run_data.submitted.url_content;
        if (this.settings.verboseDebug) console.log("Retrieved pageContent from run_data.submitted.url_content for verify task");
      } else if (typeof rbResponse.fetched_page_html === "string") {
        pageContent = rbResponse.fetched_page_html;
        if (this.settings.verboseDebug) console.log("Retrieved pageContent from rbResponse.fetched_page_html for verify task");
      } else if (typeof rbResponse.page_content === "string") {
        pageContent = rbResponse.page_content;
        if (this.settings.verboseDebug) console.log("Retrieved pageContent from rbResponse.page_content (fallback) for verify task");
      }
      if (this.settings.verboseDebug) {
        console.log(`RB Verify for ${urlToVerify}: List=${isList}, Current=${isCurrent}, Content available: ${!!pageContent}, Content snippet: ${pageContent ? pageContent.substring(0, 100) + "..." : "N/A"}`);
      }
      return { isList, isCurrent: isList && isCurrent, isCorrectProcessor, reasoning, pageContent };
    }
    if (this.settings.verboseDebug) {
      console.warn(`RB Verify task for ${urlToVerify} failed or returned unexpected response format. TaskResult:`, taskResult);
    }
    return null;
  }
  async extractEntitiesFromPageContent(pageContent, rbToken) {
    if (!this.settings.rightbrainExtractEntitiesTaskId) {
      new import_obsidian.Notice("RB Extract Entities Task ID missing. Cannot extract from content.");
      return null;
    }
    if (!pageContent.trim()) {
      return { thirdPartySubprocessors: [], ownEntities: [] };
    }
    const taskInput = { [this.settings.rightbrainExtractInputField]: pageContent };
    const taskResult = await this.callRightBrainTask(this.settings.rightbrainExtractEntitiesTaskId, taskInput, rbToken);
    if (taskResult && typeof taskResult.response === "object" && taskResult.response !== null) {
      const rbResponse = taskResult.response;
      const thirdPartySubprocessors = rbResponse[this.settings.rightbrainExtractOutputThirdPartyField] || [];
      const ownEntities = rbResponse[this.settings.rightbrainExtractOutputOwnEntitiesField] || [];
      return {
        thirdPartySubprocessors: Array.isArray(thirdPartySubprocessors) ? thirdPartySubprocessors : [],
        ownEntities: Array.isArray(ownEntities) ? ownEntities : []
      };
    }
    return null;
  }
  async updateDiscoveryStatus(file, status) {
    if (!file) return;
    await this.app.vault.process(file, (content) => {
      const updates = {
        "discovery-status": status
      };
      if (status === "complete") {
        updates["last-discovered"] = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      }
      return this.updateFrontmatter(content, updates, file.basename);
    });
  }
  async buildAliasMap() {
    var _a;
    const aliasMap = /* @__PURE__ */ new Map();
    const processorsFolder = this.app.vault.getAbstractFileByPath(this.settings.processorsFolderPath);
    if (!(processorsFolder == null ? void 0 : processorsFolder.children)) return aliasMap;
    for (const file of processorsFolder.children) {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        const cache = this.app.metadataCache.getFileCache(file);
        const frontmatter = (cache == null ? void 0 : cache.frontmatter) || {};
        const canonicalName = ((_a = frontmatter.aliases) == null ? void 0 : _a[0]) || file.basename;
        const aliases = (frontmatter.aliases || []).map((a) => String(a).toLowerCase());
        aliases.push(file.basename.toLowerCase());
        for (const alias of new Set(aliases)) {
          if (alias) {
            aliasMap.set(alias, { path: file.path, canonicalName });
          }
        }
      }
    }
    return aliasMap;
  }
  /**
  * Updates an existing RightBrain task by creating a new revision.
  * @param rbToken The RightBrain access token.
  * @param taskId The ID of the task to update.
  * @param taskDefinition An object containing the new configuration for the task revision.
  * @param creds Your RightBrain credentials.
  * @returns The updated task object or null if an error occurs.
  */
  async updateRightBrainTask(rbToken, taskId, newRevisionPayload, taskName, creds) {
    var _a;
    const taskUrl = `${creds.apiUrl}/org/${creds.orgId}/project/${creds.projectId}/task/${taskId}`;
    const headers = {
      "Authorization": `Bearer ${rbToken}`,
      "Content-Type": "application/json"
    };
    try {
      const createRevisionResponse = await (0, import_obsidian.requestUrl)({
        url: taskUrl,
        method: "POST",
        headers,
        body: JSON.stringify(newRevisionPayload),
        throw: false
      });
      if (createRevisionResponse.status !== 200) {
        new import_obsidian.Notice(`Error creating task revision for '${taskName}': ${createRevisionResponse.status} ${createRevisionResponse.text.substring(0, 100)}`, 1e4);
        console.error(`Error creating task revision for '${taskName}':`, createRevisionResponse.status, createRevisionResponse.text);
        return null;
      }
      const updatedTaskData = createRevisionResponse.json;
      const latestRevision = (_a = updatedTaskData.revisions) == null ? void 0 : _a.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())[0];
      if (!latestRevision) {
        new import_obsidian.Notice(`Could not find the new revision for '${taskName}' in the API response.`, 7e3);
        console.error("Could not find 'revisions' array in the response from creating a revision:", updatedTaskData);
        return null;
      }
      const activationPayload = {
        active_revisions: [{
          task_revision_id: latestRevision.id,
          weight: 1
        }]
      };
      const activateRevisionResponse = await (0, import_obsidian.requestUrl)({
        url: taskUrl,
        method: "POST",
        headers,
        body: JSON.stringify(activationPayload),
        throw: false
      });
      if (activateRevisionResponse.status === 200) {
        new import_obsidian.Notice(`Successfully updated and activated task: '${taskName}'`);
        return activateRevisionResponse.json;
      } else {
        new import_obsidian.Notice(`Failed to activate new revision for '${taskName}': ${activateRevisionResponse.status}`, 7e3);
        console.error(`Error activating revision for '${taskName}':`, activateRevisionResponse.status, activateRevisionResponse.text);
        return null;
      }
    } catch (error) {
      console.error(`Network error updating task '${taskName}':`, error);
      return null;
    }
  }
  async runDeduplicationForFolder(folder) {
    new import_obsidian.Notice(`Preparing to deduplicate pages in ${folder.path}...`);
    if (!this.settings.rightbrainDeduplicateSubprocessorsTaskId) {
      new import_obsidian.Notice("Deduplication Task ID not set. Cannot proceed.");
      return;
    }
    const rbToken = await this.getRightBrainAccessToken();
    if (!rbToken) {
      new import_obsidian.Notice("Could not get RightBrain token for deduplication.");
      return;
    }
    const files = folder.children.filter((f) => f instanceof import_obsidian.TFile && f.extension === "md");
    if (files.length < 2) {
      new import_obsidian.Notice("Not enough Markdown files in the folder to perform deduplication.");
      return;
    }
    const subprocessorPagesInfo = [];
    for (const file of files) {
      const fileCache = this.app.metadataCache.getFileCache(file);
      const frontmatter = fileCache == null ? void 0 : fileCache.frontmatter;
      const aliases = (frontmatter == null ? void 0 : frontmatter.aliases) && Array.isArray(frontmatter.aliases) ? frontmatter.aliases.map(String) : [];
      if (frontmatter == null ? void 0 : frontmatter.company_name) aliases.push(String(frontmatter.company_name));
      aliases.push(file.basename);
      subprocessorPagesInfo.push({
        file_path: file.path,
        page_name: file.basename,
        // Or a more canonical name from frontmatter if available
        aliases: Array.from(new Set(aliases.filter((a) => a)))
        // Unique, non-empty aliases
      });
    }
    if (subprocessorPagesInfo.length < 2) {
      new import_obsidian.Notice("Not enough processable pages with aliases found for deduplication.");
      return;
    }
    const taskInputPayload = {
      subprocessor_pages: subprocessorPagesInfo
      // Optional: Add a threshold or other parameters if your RB task supports them
      // "similarity_threshold": 0.8 
    };
    new import_obsidian.Notice(`Sending ${subprocessorPagesInfo.length} pages to RightBrain for deduplication analysis... This may take a while.`);
    const taskResult = await this.callRightBrainTask(this.settings.rightbrainDeduplicateSubprocessorsTaskId, taskInputPayload, rbToken);
    if (taskResult && taskResult.response && Array.isArray(taskResult.response.deduplication_results)) {
      const deduplicationResults = taskResult.response.deduplication_results;
      if (deduplicationResults.length === 0) {
        new import_obsidian.Notice("No duplicates found by RightBrain task.");
        return;
      }
      new import_obsidian.Notice(`Deduplication analysis complete. Found ${deduplicationResults.length} potential duplicate sets. Processing merges...`);
      await this.processDeduplicationResults(deduplicationResults);
    } else {
      new import_obsidian.Notice("Deduplication task failed or returned an unexpected response. Check console.");
      console.error("Deduplication task error. Response:", taskResult);
    }
  }
  async processDeduplicationResults(results) {
    var _a, _b, _c;
    let mergeCount = 0;
    for (const resultSet of results) {
      if (!resultSet.survivor_file_path || resultSet.duplicate_file_paths.length === 0) {
        if (this.settings.verboseDebug) console.warn("Skipping invalid deduplication result set:", resultSet);
        continue;
      }
      const survivorFile = this.app.vault.getAbstractFileByPath(resultSet.survivor_file_path);
      if (!survivorFile) {
        if (this.settings.verboseDebug) console.warn(`Survivor file not found: ${resultSet.survivor_file_path}`);
        continue;
      }
      const originalSurvivorContent = await this.app.vault.read(survivorFile);
      const survivorCache = this.app.metadataCache.getFileCache(survivorFile);
      const allAliases = new Set((((_a = survivorCache == null ? void 0 : survivorCache.frontmatter) == null ? void 0 : _a.aliases) || []).map(String));
      allAliases.add(survivorFile.basename);
      const allRows = new Set(this.extractClientTableRows(originalSurvivorContent));
      const archiveFolderPath = `${this.settings.processorsFolderPath}/_Archive`;
      await this.ensureFolderExists(archiveFolderPath);
      for (const dupFilePath of resultSet.duplicate_file_paths) {
        if (dupFilePath === survivorFile.path) continue;
        const dupFile = this.app.vault.getAbstractFileByPath(dupFilePath);
        if (dupFile) {
          const dupContent = await this.app.vault.read(dupFile);
          const dupCache = this.app.metadataCache.getFileCache(dupFile);
          (((_b = dupCache == null ? void 0 : dupCache.frontmatter) == null ? void 0 : _b.aliases) || []).map(String).forEach((alias) => allAliases.add(alias));
          allAliases.add(dupFile.basename);
          this.extractClientTableRows(dupContent).forEach((row) => allRows.add(row));
          try {
            const newPath = `${archiveFolderPath}/${dupFile.name}`;
            await this.app.vault.rename(dupFile, newPath);
          } catch (e) {
            console.error(`Failed to move duplicate file ${dupFilePath} to archive:`, e);
          }
        }
      }
      const fmRegex = /^---\s*\n([\s\S]*?)\n---\s*\n/;
      const match = originalSurvivorContent.match(fmRegex);
      let survivorBody = match ? originalSurvivorContent.substring(match[0].length) : originalSurvivorContent;
      const existingTags = new Set((((_c = survivorCache == null ? void 0 : survivorCache.frontmatter) == null ? void 0 : _c.tags) || []).map(String));
      existingTags.add("merged-processor");
      let newFmString = "---\n";
      newFmString += `aliases: [${Array.from(allAliases).map((a) => `"${a.replace(/"/g, '\\"')}"`).join(", ")}]
`;
      newFmString += `tags: [${Array.from(existingTags).map((t) => `"${t}"`).join(", ")}]
`;
      newFmString += "---\n";
      let clientTableMd = "";
      if (allRows.size > 0) {
        clientTableMd += `| Primary Processor | Processing Function | Location | Source URL |
`;
        clientTableMd += `|---|---|---|---|
`;
        allRows.forEach((row) => {
          clientTableMd += `|${row}|
`;
        });
      }
      const finalBody = this.ensureHeadingAndSection(survivorBody, "Used By", clientTableMd, null, null);
      let finalContent = newFmString + finalBody;
      const logDate = (/* @__PURE__ */ new Date()).toISOString();
      const survivorLogPath = `${this.settings.analysisLogsFolderPath}/${this.sanitizeNameForFilePathAndAlias(survivorFile.basename).filePathName} Subprocessor Logs.md`;
      let mergeLogContent = `
    ---
    ### Deduplication Merge Event
    **Date:** ${logDate}
    **Survivor:** [[${survivorFile.path}|${survivorFile.basename}]]
    **RightBrain Reasoning:** ${resultSet.reasoning || "No reasoning provided."}
    
    **Archived Files (${resultSet.duplicate_file_paths.length}):**
    `;
      for (const dupFilePath of resultSet.duplicate_file_paths) {
        const archivedPath = `${archiveFolderPath}/${dupFilePath.split("/").pop()}`;
        mergeLogContent += `- [[${archivedPath}]]
`;
      }
      await this.writeResultsToObsidianNote(survivorLogPath, mergeLogContent, "ensure_exists_and_append", survivorFile.basename);
      let mergeSummaryBlock = `
    <details>
    <summary>Merge History</summary>
    
    This note was the result of an automated deduplication event on ${(/* @__PURE__ */ new Date()).toLocaleDateString()}.
    - **RightBrain Reasoning:** ${resultSet.reasoning || "N/A"}
    - For a full audit, see the [[${survivorLogPath}|Analysis Log]].
    
    </details>
    `;
      finalContent += `

${mergeSummaryBlock}`;
      await this.app.vault.modify(survivorFile, finalContent);
      mergeCount++;
      new import_obsidian.Notice(`Merged ${resultSet.duplicate_file_paths.length} duplicate(s) into ${survivorFile.basename}.`);
    }
    if (mergeCount > 0) {
      new import_obsidian.Notice(`Deduplication finished. ${mergeCount} merge operations performed.`);
    } else {
      new import_obsidian.Notice("Deduplication process finished, but no actionable merges were made.");
    }
  }
  async processManualMerge(survivorFile, duplicateFiles) {
    var _a, _b, _c;
    if (!survivorFile || duplicateFiles.length === 0) {
      new import_obsidian.Notice("Merge cancelled: No survivor or duplicates selected.");
      return;
    }
    new import_obsidian.Notice(`Merging ${duplicateFiles.length} file(s) into ${survivorFile.basename}...`, 6e3);
    try {
      const originalSurvivorContent = await this.app.vault.read(survivorFile);
      const survivorCache = this.app.metadataCache.getFileCache(survivorFile);
      const allAliases = new Set((((_a = survivorCache == null ? void 0 : survivorCache.frontmatter) == null ? void 0 : _a.aliases) || []).map(String));
      allAliases.add(survivorFile.basename);
      const allRows = new Set(this.extractClientTableRows(originalSurvivorContent));
      for (const dupFile of duplicateFiles) {
        const dupContent = await this.app.vault.read(dupFile);
        const dupCache = this.app.metadataCache.getFileCache(dupFile);
        (((_b = dupCache == null ? void 0 : dupCache.frontmatter) == null ? void 0 : _b.aliases) || []).map(String).forEach((alias) => allAliases.add(alias));
        allAliases.add(dupFile.basename);
        this.extractClientTableRows(dupContent).forEach((row) => allRows.add(row));
      }
      const fmRegex = /^---\s*\n([\s\S]*?)\n---\s*\n/;
      const match = originalSurvivorContent.match(fmRegex);
      let survivorBody = match ? originalSurvivorContent.substring(match[0].length) : originalSurvivorContent;
      const existingTags = new Set((((_c = survivorCache == null ? void 0 : survivorCache.frontmatter) == null ? void 0 : _c.tags) || []).map(String));
      let newFmString = "---\n";
      newFmString += `aliases: [${Array.from(allAliases).map((a) => `"${a.replace(/"/g, '\\"')}"`).join(", ")}]
`;
      if (existingTags.size > 0) {
        newFmString += `tags: [${Array.from(existingTags).map((t) => `"${t}"`).join(", ")}]
`;
      }
      newFmString += "---\n";
      let clientTableMd = "";
      if (allRows.size > 0) {
        clientTableMd += `| Primary Processor | Processing Function | Location | Source URL |
`;
        clientTableMd += `|---|---|---|---|
`;
        allRows.forEach((row) => {
          clientTableMd += `|${row}|
`;
        });
      }
      const finalBody = this.ensureHeadingAndSection(survivorBody, "Used By", clientTableMd, null, null);
      const finalContent = newFmString + finalBody;
      await this.app.vault.modify(survivorFile, finalContent);
      for (const dupFile of duplicateFiles) {
        await this.app.vault.delete(dupFile);
      }
      new import_obsidian.Notice(`Successfully merged ${duplicateFiles.length} file(s) into ${survivorFile.basename}.`);
    } catch (error) {
      console.error("Error during manual merge:", error);
      new import_obsidian.Notice("An error occurred during the merge. Check the developer console.");
    }
  }
  extractClientTableRows(content) {
    const rows = [];
    const lines = content.split("\n");
    let inUsedBySection = false;
    let tableHasStarted = false;
    for (const line of lines) {
      if (line.match(/^##+\s*Used By\s*$/i)) {
        inUsedBySection = true;
        tableHasStarted = false;
        continue;
      }
      if (inUsedBySection) {
        const trimmedLine = line.trim();
        if (trimmedLine.startsWith("##")) {
          inUsedBySection = false;
          break;
        }
        if (trimmedLine.match(/^\|---\|/)) {
          tableHasStarted = true;
          continue;
        }
        if (tableHasStarted && trimmedLine.startsWith("|") && trimmedLine.endsWith("|")) {
          const match = trimmedLine.match(/^\|(.*)\|$/);
          if (match && match[1]) {
            if (!match[1].match(/^---\|/)) {
              rows.push(match[1]);
            }
          }
        } else if (tableHasStarted && trimmedLine !== "") {
          break;
        }
      }
    }
    return rows;
  }
  async discoverRecursively(initialProcessorName, initialProcessorFile, maxDepth = 3) {
    var _a, _b;
    new import_obsidian.Notice(`Starting smart recursive discovery for: ${initialProcessorName}. Max depth: ${maxDepth}`, 1e4);
    const aliasMap = await this.buildAliasMap();
    this.processedInCurrentRecursiveSearch = /* @__PURE__ */ new Set();
    const queue = [{ processorName: initialProcessorName, depth: 0 }];
    let discoveredCount = 0;
    let skippedCount = 0;
    while (queue.length > 0) {
      const current = queue.shift();
      if (!current) continue;
      let { processorName, depth } = current;
      const existingEntity = aliasMap.get(processorName.toLowerCase());
      let currentProcessorFile = existingEntity ? this.app.vault.getAbstractFileByPath(existingEntity.path) : null;
      if (currentProcessorFile) {
        const cache = this.app.metadataCache.getFileCache(currentProcessorFile);
        if (((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a["discovery-status"]) === "complete" && ((_b = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _b["last-discovered"])) {
          const lastRun = new Date(cache.frontmatter["last-discovered"]);
          const expiryDate = /* @__PURE__ */ new Date();
          expiryDate.setDate(expiryDate.getDate() - this.settings.discoveryCacheDays);
          if (lastRun > expiryDate) {
            if (this.settings.verboseDebug) console.log(`Skipping recently processed: ${processorName}`);
            skippedCount++;
            continue;
          }
        }
      }
      new import_obsidian.Notice(`Recursive (depth ${depth}): Processing ${processorName}...`);
      const { filePathName: sanitizedNameForTracking } = this.sanitizeNameForFilePathAndAlias(processorName);
      if (this.processedInCurrentRecursiveSearch.has(sanitizedNameForTracking)) continue;
      this.processedInCurrentRecursiveSearch.add(sanitizedNameForTracking);
      const isTopLevel = depth === 0;
      if (!currentProcessorFile) {
        currentProcessorFile = await this.ensureProcessorFile(processorName, true, isTopLevel);
      }
      if (!currentProcessorFile) continue;
      discoveredCount++;
      const searchData = await this.fetchProcessorSearchDataWithDiscovery(processorName);
      if (searchData == null ? void 0 : searchData.collectedRelationships) {
        const directSubNames = Array.from(new Set(searchData.collectedRelationships.filter((rel) => rel.PrimaryProcessor === processorName && rel.RelationshipType === "uses_subprocessor").map((rel) => rel.SubprocessorName.trim()).filter((name) => name)));
        const mergeDecisionsLog = [];
        if (depth < maxDepth - 1) {
          for (const subName of directSubNames) {
            const sanitizedSubNameForTracking = this.sanitizeNameForFilePathAndAlias(subName).filePathName;
            if (this.processedInCurrentRecursiveSearch.has(sanitizedSubNameForTracking)) continue;
            const existingMapping = aliasMap.get(subName.toLowerCase());
            let nameToQueue = subName;
            if (existingMapping) {
              nameToQueue = existingMapping.canonicalName;
              if (subName !== nameToQueue) {
                const decision = `Mapped discovered name "${subName}" to existing processor "${nameToQueue}".`;
                mergeDecisionsLog.push(decision);
              }
            } else {
              const { filePathName, originalNameAsAlias } = this.sanitizeNameForFilePathAndAlias(subName);
              const newPath = `${this.settings.processorsFolderPath}/${filePathName}.md`;
              aliasMap.set(subName.toLowerCase(), { path: newPath, canonicalName: originalNameAsAlias });
            }
            if (!queue.some((q) => q.processorName === nameToQueue)) {
              queue.push({ processorName: nameToQueue, depth: depth + 1 });
            }
          }
        }
        await this.persistSubprocessorInfo(processorName, currentProcessorFile, searchData, isTopLevel, mergeDecisionsLog);
        await this.updateDiscoveryStatus(currentProcessorFile, "complete");
      } else {
        await this.updateDiscoveryStatus(currentProcessorFile, "incomplete");
      }
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
    new import_obsidian.Notice(`Recursive discovery complete. Processed ${discoveredCount} entities, skipped ${skippedCount} recent ones.`, 1e4);
    this.processedInCurrentRecursiveSearch.clear();
  }
  openFileSelectorMergeModal() {
    const files = this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(this.settings.processorsFolderPath + "/"));
    if (files.length < 2) {
      new import_obsidian.Notice("There are not enough processor files to perform a merge.");
      return;
    }
    new FileSelectorMergeModal(this.app, files, (selectedFiles) => {
      new ForceMergeModal(this.app, selectedFiles, (survivor, duplicates) => {
        this.processManualMerge(survivor, duplicates);
      }).open();
    }).open();
  }
  /**
  * Writes a pre-defined configuration to the graph.json file.
  */
  async applyRecommendedGraphSettings() {
    const graphSettings = {
      "collapse-filter": true,
      "search": `path:"${this.settings.processorsFolderPath}" -path:"${this.settings.processorsFolderPath}/_Archive"`,
      "showTags": false,
      "showAttachments": false,
      "hideUnresolved": true,
      "showOrphans": false,
      "collapse-color-groups": true,
      "colorGroups": [
        {
          "query": "tag:#processor",
          "color": { "a": 1, "rgb": 14025728 }
          // Red
        },
        {
          "query": "tag:#subprocessor",
          "color": { "a": 1, "rgb": 6084182 }
          // Green
        },
        {
          "query": "tag:#merged-processor",
          "color": { "a": 1, "rgb": 6069962 }
          // Blue
        }
      ],
      "collapse-display": false,
      "showArrow": true,
      // Show link direction
      "textFadeMultiplier": -2.3,
      "nodeSizeMultiplier": 1.2,
      "lineSizeMultiplier": 1,
      "collapse-forces": false,
      "centerStrength": 0.5,
      "repelStrength": 12,
      "linkStrength": 1,
      "linkDistance": 250,
      "scale": 0.5,
      "close": false
    };
    const configPath = this.app.vault.configDir + "/graph.json";
    try {
      await this.app.vault.adapter.write(configPath, JSON.stringify(graphSettings, null, 2));
      new import_obsidian.Notice("Recommended graph settings have been applied. Please reopen the graph view to see the changes.");
    } catch (error) {
      console.error("Failed to write graph settings:", error);
      new import_obsidian.Notice("Error: Could not apply graph settings.");
    }
  }
};
var ManualInputModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit, initialProcessorName) {
    super(app);
    this.processorName = "";
    this.listUrl = "";
    this.isPrimaryProcessor = true;
    this.onSubmit = onSubmit;
    this.initialProcessorName = initialProcessorName;
    if (this.initialProcessorName) {
      this.processorName = this.initialProcessorName;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Manually Add Subprocessor List URL" });
    new import_obsidian.Setting(contentEl).setName("Processor Name").setDesc("Enter the name of the primary processor (e.g., OpenAI).").addText((text) => {
      text.setPlaceholder("Enter processor name").setValue(this.processorName).onChange((value) => this.processorName = value).inputEl.setAttr("required", "true");
      if (this.initialProcessorName) {
        text.setDisabled(true);
      }
    });
    new import_obsidian.Setting(contentEl).setName("Subprocessor List URL").setDesc("Enter the direct URL to the subprocessor list or DPA page.").addText((text) => text.setPlaceholder("https://example.com/subprocessors").setValue(this.listUrl).onChange((value) => this.listUrl = value).inputEl.setAttr("required", "true"));
    new import_obsidian.Setting(contentEl).setName("Is a primary processor?").setDesc("Enable this if you are initiating a search on this processor. Disable if you are adding a subprocessor of another entity.").addToggle((toggle) => toggle.setValue(this.isPrimaryProcessor).onChange((value) => this.isPrimaryProcessor = value));
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Process URL").setCta().onClick(() => {
      this.close();
      this.onSubmit(this.processorName, this.listUrl, this.isPrimaryProcessor);
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var SearchModal = class extends import_obsidian.Modal {
  constructor(app, settings, onSubmit) {
    super(app);
    this.processorName = "";
    this.settings = settings;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Discover Subprocessors" });
    let searchMethodNote = "Search will be performed using available configured methods.";
    if (this.settings.serpApiKey) {
      searchMethodNote = "Search will primarily use SerpAPI.";
    } else if (this.settings.rightbrainOrgId && this.settings.rightbrainProjectId && this.settings.rightbrainDuckDuckGoSearchTaskId) {
      searchMethodNote = "SerpAPI key not found. Search will use DuckDuckGo via RightBrain.";
    } else {
      searchMethodNote = "Neither SerpAPI nor RightBrain DuckDuckGo search is fully configured. Discovery might be limited.";
    }
    contentEl.createEl("p", { text: searchMethodNote });
    new import_obsidian.Setting(contentEl).setName("Processor Name").setDesc("Enter the name of the processor to search for (e.g., Stripe).").addText((text) => text.setPlaceholder("Enter processor name").setValue(this.processorName).onChange((value) => this.processorName = value).inputEl.setAttr("required", "true"));
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Start Discovery").setCta().onClick(() => {
      if (!this.processorName.trim()) {
        new import_obsidian.Notice("Processor Name is required.");
        return;
      }
      this.close();
      this.onSubmit(this.processorName);
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var ManualTextEntryModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit, initialProcessorName) {
    super(app);
    this.processorName = "";
    this.pastedText = "";
    this.isPrimaryProcessor = true;
    this.onSubmit = onSubmit;
    this.initialProcessorName = initialProcessorName;
    if (this.initialProcessorName) {
      this.processorName = this.initialProcessorName;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Input Subprocessor List from Text" });
    new import_obsidian.Setting(contentEl).setName("Processor Name").setDesc("Enter the name of the primary processor this text belongs to.").addText((text) => {
      text.setPlaceholder("Enter processor name").setValue(this.processorName).onChange((value) => this.processorName = value).inputEl.setAttr("required", "true");
      if (this.initialProcessorName) {
        text.setDisabled(true);
      }
    });
    new import_obsidian.Setting(contentEl).setName("Is a primary processor?").setDesc("Enable this if you are initiating a search on this processor. Disable if you are adding a subprocessor of another entity.").addToggle((toggle) => toggle.setValue(this.isPrimaryProcessor).onChange((value) => this.isPrimaryProcessor = value));
    contentEl.createEl("p", { text: "Paste the subprocessor list text below:" });
    const textArea = new import_obsidian.TextAreaComponent(contentEl).setPlaceholder("Paste text here...").setValue(this.pastedText).onChange((value) => this.pastedText = value);
    textArea.inputEl.rows = 10;
    textArea.inputEl.style.width = "100%";
    textArea.inputEl.setAttr("required", "true");
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Process Text").setCta().onClick(() => {
      this.close();
      this.onSubmit(this.processorName, this.pastedText, this.isPrimaryProcessor);
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var ForceMergeModal = class extends import_obsidian.Modal {
  constructor(app, files, onSubmit) {
    super(app);
    this.survivor = null;
    this.files = files.sort((a, b) => a.basename.localeCompare(b.basename));
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Force Merge Processors" });
    contentEl.createEl("p", { text: 'Select the file to keep (the "survivor"). All other selected files will be merged into it and then deleted.' });
    let mergeButton;
    const radioGroup = contentEl.createDiv();
    this.files.forEach((file) => {
      const setting = new import_obsidian.Setting(radioGroup).setName(file.basename).setDesc(file.path);
      const radio = createEl("input", {
        type: "radio",
        cls: "force-merge-radio"
      });
      radio.name = "survivor-selection";
      radio.value = file.path;
      radio.onchange = () => {
        this.survivor = file;
        mergeButton.setDisabled(false).setCta(true);
      };
      setting.controlEl.appendChild(radio);
    });
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close())).addButton((btn) => {
      mergeButton = btn;
      btn.setButtonText("Merge").setDisabled(true).onClick(() => {
        if (this.survivor) {
          const duplicates = this.files.filter((f) => f.path !== this.survivor.path);
          this.close();
          this.onSubmit(this.survivor, duplicates);
        }
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};
var FileSelectorMergeModal = class extends import_obsidian.Modal {
  constructor(app, files, onSubmit) {
    super(app);
    this.selectedFilePaths = /* @__PURE__ */ new Set();
    this.files = files.sort((a, b) => a.basename.localeCompare(b.basename));
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Select Files to Merge" });
    contentEl.createEl("p", { text: "Choose two or more processor files from the list below." });
    let nextButton;
    const checkboxGroup = contentEl.createDiv();
    checkboxGroup.addClass("processor-file-selector-list");
    this.files.forEach((file) => {
      const setting = new import_obsidian.Setting(checkboxGroup).setName(file.basename).setDesc(file.path);
      setting.addToggle((toggle) => {
        toggle.onChange((value) => {
          if (value) {
            this.selectedFilePaths.add(file.path);
          } else {
            this.selectedFilePaths.delete(file.path);
          }
          nextButton.setDisabled(this.selectedFilePaths.size < 2);
        });
      });
    });
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close())).addButton((btn) => {
      nextButton = btn;
      btn.setButtonText("Next: Select Survivor").setCta().setDisabled(true).onClick(() => {
        const selectedFiles = this.files.filter((f) => this.selectedFilePaths.has(f.path));
        this.close();
        this.onSubmit(selectedFiles);
      });
    });
  }
};
var PasteEnvModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.pastedText = "";
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Complete Plugin Setup" });
    contentEl.createEl("p", { text: "Paste the entire block of environment variables from your RightBrain dashboard below. This will save your credentials and then automatically create the necessary AI tasks in your project." });
    const textArea = new import_obsidian.TextAreaComponent(contentEl).setPlaceholder('RB_ORG_ID="..."\nRB_PROJECT_ID="..."').onChange((value) => this.pastedText = value);
    textArea.inputEl.rows = 12;
    textArea.inputEl.style.width = "100%";
    textArea.inputEl.style.fontFamily = "monospace";
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Begin Setup").setCta().onClick(() => {
      if (this.pastedText.trim()) {
        this.runFullSetup();
        this.close();
      } else {
        new import_obsidian.Notice("Text area is empty.");
      }
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
  /**
   * Parses the pasted text, saves credentials, then proceeds to set up tasks.
   */
  async runFullSetup() {
    const lines = this.pastedText.trim().split("\n");
    const settingsToUpdate = {};
    const keyMap = {
      "RB_ORG_ID": "rightbrainOrgId",
      "RB_PROJECT_ID": "rightbrainProjectId",
      "RB_CLIENT_ID": "rightbrainClientId",
      "RB_CLIENT_SECRET": "rightbrainClientSecret",
      "RB_API_URL": "rightbrainApiUrl",
      "RB_OAUTH2_URL": "rightbrainOauth2Url"
    };
    for (const line of lines) {
      const parts = line.split("=");
      if (parts.length < 2) continue;
      const key = parts[0].trim();
      let value = parts.slice(1).join("=").trim().replace(/["']/g, "");
      if (key in keyMap && value) {
        const settingKey = keyMap[key];
        settingsToUpdate[settingKey] = value;
      }
    }
    if (!settingsToUpdate.rightbrainOrgId || !settingsToUpdate.rightbrainProjectId || !settingsToUpdate.rightbrainClientId || !settingsToUpdate.rightbrainClientSecret || !settingsToUpdate.rightbrainApiUrl || !settingsToUpdate.rightbrainOauth2Url) {
      new import_obsidian.Notice("Setup failed. Pasted text is missing one or more required values.", 7e3);
      return;
    }
    this.plugin.settings = Object.assign(this.plugin.settings, settingsToUpdate);
    await this.plugin.saveSettings();
    new import_obsidian.Notice(`Credentials saved.`);
    await new Promise((resolve) => setTimeout(resolve, 1e3));
    await this.plugin.setupRightBrainTasks({
      apiUrl: settingsToUpdate.rightbrainApiUrl,
      oauthUrl: settingsToUpdate.rightbrainOauth2Url,
      clientId: settingsToUpdate.rightbrainClientId,
      clientSecret: settingsToUpdate.rightbrainClientSecret,
      orgId: settingsToUpdate.rightbrainOrgId,
      projectId: settingsToUpdate.rightbrainProjectId
    });
    await this.plugin.applyRecommendedGraphSettings();
  }
};
var ProcessorProcessorSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Processor Processor Settings" });
    containerEl.createEl("h3", { text: "API Keys & Credentials" });
    new import_obsidian.Setting(containerEl).setName("SerpAPI Key").setDesc("Your SerpAPI Key for Google search functionality.").addText((text) => text.setPlaceholder("Enter your SerpAPI key").setValue(this.plugin.settings.serpApiKey).onChange(async (value) => {
      this.plugin.settings.serpApiKey = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "RightBrain Task Configuration" });
    new import_obsidian.Setting(containerEl).setName("Automatically Synchronize Tasks on Load").setDesc("If enabled, the plugin will check for and apply updates from its local task definitions on startup. Disable this if you prefer to manage and customize your tasks directly in the RightBrain dashboard without them being overwritten.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSynchronizeTasks).onChange(async (value) => {
      this.plugin.settings.autoSynchronizeTasks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("RB Extract Entities: Input Field Name").setDesc('The parameter name your RB Extract Entities task expects for the input text (e.g., "page_text", "document_content").').addText((text) => text.setValue(this.plugin.settings.rightbrainExtractInputField).setPlaceholder("e.g., page_text").onChange(async (value) => {
      this.plugin.settings.rightbrainExtractInputField = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("RB Extract Entities: Output Field (Third-Party)").setDesc(`The field name in your RB Extract Entities task's JSON output for the list of third-party subprocessors (e.g., "third_party_subprocessors").`).addText((text) => text.setValue(this.plugin.settings.rightbrainExtractOutputThirdPartyField).setPlaceholder("e.g., third_party_subprocessors").onChange(async (value) => {
      this.plugin.settings.rightbrainExtractOutputThirdPartyField = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("RB Extract Entities: Output Field (Own Entities)").setDesc(`The field name in your RB Extract Entities task's JSON output for the list of own/affiliated entities (e.g., "own_entities").`).addText((text) => text.setValue(this.plugin.settings.rightbrainExtractOutputOwnEntitiesField).setPlaceholder("e.g., own_entities").onChange(async (value) => {
      this.plugin.settings.rightbrainExtractOutputOwnEntitiesField = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "General Settings" });
    new import_obsidian.Setting(containerEl).setName("Create Pages for Own Entities").setDesc('If enabled, separate Markdown pages will also be created for "own entities" identified during processing, not just third-party subprocessors.').addToggle((toggle) => toggle.setValue(this.plugin.settings.createPagesForOwnEntities).onChange(async (value) => {
      this.plugin.settings.createPagesForOwnEntities = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Verbose Debug Logging").setDesc("Enable detailed logging to the developer console for debugging purposes.").addToggle((toggle) => toggle.setValue(this.plugin.settings.verboseDebug).onChange(async (value) => {
      this.plugin.settings.verboseDebug = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Max Results Per Processor (Discovery)").setDesc("Maximum search results to process for each processor during initial discovery. Currently, the logic stops on the first verified list, effectively making this 1.").addText((text) => text.setValue(this.plugin.settings.maxResultsPerProcessor.toString()).setDisabled(true).onChange(async (value) => {
    }));
    new import_obsidian.Setting(containerEl).setName("Mapping Depth").setDesc("Set the maximum depth for the Map Subprocessor Relationships function (e.g., 2-5). Higher numbers will take much longer and use more API calls.").addText((text) => text.setPlaceholder("e.g., 3").setValue(this.plugin.settings.maxRecursiveDepth.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.maxRecursiveDepth = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Discovery Cache Duration (Days)").setDesc(`How many days to consider a processor's data "fresh". A processor with a "complete" status discovered within this period will be skipped during recursive runs.`).addText((text) => text.setPlaceholder("e.g., 30").setValue(this.plugin.settings.discoveryCacheDays.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 0) {
        this.plugin.settings.discoveryCacheDays = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Processors Folder Path").setDesc('Path to the folder where processor and subprocessor notes will be stored (e.g., "Third Parties/Processors").').addText((text) => text.setPlaceholder("e.g., Processors").setValue(this.plugin.settings.processorsFolderPath).onChange(async (value) => {
      this.plugin.settings.processorsFolderPath = value || DEFAULT_SETTINGS.processorsFolderPath;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Analysis Logs Folder Path").setDesc('Path to the folder where analysis log notes for each processor will be stored (e.g., "Compliance/Logs").').addText((text) => text.setPlaceholder("e.g., Analysis Logs").setValue(this.plugin.settings.analysisLogsFolderPath).onChange(async (value) => {
      this.plugin.settings.analysisLogsFolderPath = value || DEFAULT_SETTINGS.analysisLogsFolderPath;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "RightBrain Model Configuration" });
    new import_obsidian.Setting(containerEl).setDesc((() => {
      const apiUrl = this.plugin.settings.rightbrainApiUrl || "";
      const dashboardUrl = apiUrl.includes("stag") || apiUrl.includes("leftbrain") ? "https://stag.leftbrain.me" : "https://app.rightbrain.ai";
      const fragment = new DocumentFragment();
      fragment.appendText("You can configure basic RightBrain settings here, or log in to the ");
      fragment.createEl("a", {
        text: "Rightbrain Dashboard",
        href: dashboardUrl,
        attr: { "target": "_blank", "rel": "noopener noreferrer" }
        // Added rel for security
      });
      fragment.appendText(" for more fine-tuned control.");
      return fragment;
    })());
    new import_obsidian.Setting(containerEl).setName("Refresh Model List").setDesc("Fetch the latest available LLM models from your RightBrain project. The list is automatically cached for 24 hours.").addButton((button) => button.setButtonText("Refresh Now").onClick(async () => {
      await this.plugin.updateLlmModelList(true);
      this.display();
    }));
    const taskDefsForUI = [
      { name: "Verify Subprocessor List URL", settingKey: "verifyUrlModelId" },
      { name: "Extract Entities From Page Content", settingKey: "extractEntitiesModelId" },
      { name: "Deduplicate Subprocessors", settingKey: "deduplicateSubprocessorsModelId" },
      { name: "DDG SERP Parser", settingKey: "duckDuckGoSearchModelId" },
      { name: "Find DPA URL", settingKey: "findDpaModelId" },
      { name: "Find ToS URL", settingKey: "findTosModelId" },
      { name: "Find Security Page URL", settingKey: "findSecurityModelId" }
    ];
    const availableModels = this.plugin.settings.llmModelList;
    const defaultModel = availableModels.find((m) => m.alias.toLowerCase().includes("gemini 1.5 flash"));
    taskDefsForUI.forEach((task) => {
      new import_obsidian.Setting(containerEl).setName(task.name).setDesc(`Select the LLM to use for the "${task.name}" task.`).addDropdown((dropdown) => {
        if (availableModels.length === 0) {
          dropdown.addOption("", "No models loaded. Refresh list or check credentials.");
          dropdown.setDisabled(true);
          return;
        }
        availableModels.forEach((model) => {
          dropdown.addOption(model.id, model.alias);
        });
        const currentModelId = this.plugin.settings[task.settingKey];
        dropdown.setValue(currentModelId || (defaultModel ? defaultModel.id : availableModels[0].id));
        dropdown.onChange(async (value) => {
          this.plugin.settings[task.settingKey] = value;
          await this.plugin.saveSettings();
          new import_obsidian.Notice(`${task.name} will now use ${dropdown.selectEl.options[dropdown.selectEl.selectedIndex].text}.`);
        });
      });
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBNb2RhbCwgTm90aWNlLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIHJlcXVlc3RVcmwsIFRGaWxlLCBNZW51LCBNZW51SXRlbSwgRnJvbnRNYXR0ZXJDYWNoZSwgVEZvbGRlciwgVGV4dENvbXBvbmVudCwgVGV4dEFyZWFDb21wb25lbnQsIEJ1dHRvbkNvbXBvbmVudCB9IGZyb20gJ29ic2lkaWFuJztcblxuLy8gLS0tLS0gQ09OU1RBTlRTIC0tLS0tXG5jb25zdCBTVUJQUk9DRVNTT1JfVVJMX0tFWVdPUkRTID0gW1xuICAgICdzdWJwcm9jZXNzb3InLCAnc3ViLXByb2Nlc3NvcicsICdzdWJfcHJvY2Vzc29yJyxcbiAgICAndmVuZG9yLWxpc3QnLCAndmVuZG9ybGlzdCcsICd0aGlyZC1wYXJ0eS1saXN0JywgJ3RoaXJkcGFydHlsaXN0JyxcbiAgICAnc2VydmljZS1wcm92aWRlcnMnLCAnc2VydmljZXByb3ZpZGVycycsXG4gICAgJ2RwYS1leGhpYml0JywgJ2RwYS9leGhpYml0JywgJ2RhdGEtcHJvY2Vzc2luZy1hZGRlbmR1bS9leGhpYml0JyxcbiAgICAndHJ1c3QtY2VudGVyL3N1YicsICdsZWdhbC9zdWJwcm9jZXNzb3JzJ1xuXTtcblxuXG4vLyAtLS0tLSBTRVRUSU5HUyBJTlRFUkZBQ0UgQU5EIERFRkFVTFRTIC0tLS0tXG5leHBvcnQgaW50ZXJmYWNlIExsbU1vZGVsIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGFsaWFzOiBzdHJpbmc7XG4gIH1cblxuaW50ZXJmYWNlIFByb2Nlc3NvclByb2Nlc3NvclNldHRpbmdzIHtcbiAgICBzZXJwQXBpS2V5OiBzdHJpbmc7XG4gICAgcmlnaHRicmFpbkNsaWVudElkOiBzdHJpbmc7XG4gICAgcmlnaHRicmFpbkNsaWVudFNlY3JldDogc3RyaW5nO1xuICAgIHJpZ2h0YnJhaW5PcmdJZDogc3RyaW5nO1xuICAgIHJpZ2h0YnJhaW5Qcm9qZWN0SWQ6IHN0cmluZztcbiAgICByaWdodGJyYWluQXBpVXJsOiBzdHJpbmc7XG4gICAgcmlnaHRicmFpbk9hdXRoMlVybDogc3RyaW5nO1xuICAgIHJpZ2h0YnJhaW5WZXJpZnlVcmxUYXNrSWQ6IHN0cmluZztcbiAgICByaWdodGJyYWluRXh0cmFjdEVudGl0aWVzVGFza0lkOiBzdHJpbmc7XG4gICAgcmlnaHRicmFpbkV4dHJhY3RJbnB1dEZpZWxkOiBzdHJpbmc7XG4gICAgcmlnaHRicmFpbkV4dHJhY3RPdXRwdXRUaGlyZFBhcnR5RmllbGQ6IHN0cmluZztcbiAgICByaWdodGJyYWluRXh0cmFjdE91dHB1dE93bkVudGl0aWVzRmllbGQ6IHN0cmluZztcbiAgICByaWdodGJyYWluRGVkdXBsaWNhdGVTdWJwcm9jZXNzb3JzVGFza0lkOiBzdHJpbmc7XG4gICAgcmlnaHRicmFpbkR1Y2tEdWNrR29TZWFyY2hUYXNrSWQ6IHN0cmluZztcbiAgICBjcmVhdGVQYWdlc0Zvck93bkVudGl0aWVzOiBib29sZWFuO1xuICAgIHZlcmJvc2VEZWJ1ZzogYm9vbGVhbjtcbiAgICBtYXhSZXN1bHRzUGVyUHJvY2Vzc29yOiBudW1iZXI7XG4gICAgbWF4UmVjdXJzaXZlRGVwdGg6IG51bWJlcjtcbiAgICBkaXNjb3ZlcnlDYWNoZURheXM6IG51bWJlcjtcbiAgICBwcm9jZXNzb3JzRm9sZGVyUGF0aDogc3RyaW5nO1xuICAgIGFuYWx5c2lzTG9nc0ZvbGRlclBhdGg6IHN0cmluZztcbiAgICByaWdodGJyYWluRmluZERwYVRhc2tJZDogc3RyaW5nO1xuICAgIHJpZ2h0YnJhaW5GaW5kVG9zVGFza0lkOiBzdHJpbmc7IFxuICAgIHJpZ2h0YnJhaW5GaW5kU2VjdXJpdHlUYXNrSWQ6IHN0cmluZztcbiAgICBhdXRvU3luY2hyb25pemVUYXNrczogYm9vbGVhbjtcbiAgICBsbG1Nb2RlbExpc3Q6IExsbU1vZGVsW107XG4gICAgbGxtTW9kZWxMaXN0TGFzdFVwZGF0ZWQ6IG51bWJlcjtcbiAgICB2ZXJpZnlVcmxNb2RlbElkOiBzdHJpbmc7XG4gICAgZXh0cmFjdEVudGl0aWVzTW9kZWxJZDogc3RyaW5nO1xuICAgIGRlZHVwbGljYXRlU3VicHJvY2Vzc29yc01vZGVsSWQ6IHN0cmluZztcbiAgICBkdWNrRHVja0dvU2VhcmNoTW9kZWxJZDogc3RyaW5nO1xuICAgIGZpbmREcGFNb2RlbElkOiBzdHJpbmc7XG4gICAgZmluZFRvc01vZGVsSWQ6IHN0cmluZztcbiAgICBmaW5kU2VjdXJpdHlNb2RlbElkOiBzdHJpbmc7XG59XG5cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFByb2Nlc3NvclByb2Nlc3NvclNldHRpbmdzID0ge1xuICAgIHNlcnBBcGlLZXk6ICcnLFxuICAgIHJpZ2h0YnJhaW5DbGllbnRJZDogJycsXG4gICAgcmlnaHRicmFpbkNsaWVudFNlY3JldDogJycsXG4gICAgcmlnaHRicmFpbk9yZ0lkOiAnJyxcbiAgICByaWdodGJyYWluUHJvamVjdElkOiAnJyxcbiAgICByaWdodGJyYWluQXBpVXJsOiAnaHR0cHM6Ly9hcHAucmlnaHRicmFpbi5haS9hcGkvdjEnLFxuICAgIHJpZ2h0YnJhaW5PYXV0aDJVcmw6ICdodHRwczovL29hdXRoLnJpZ2h0YnJhaW4uYWknLFxuICAgIHJpZ2h0YnJhaW5WZXJpZnlVcmxUYXNrSWQ6ICcnLFxuICAgIHJpZ2h0YnJhaW5FeHRyYWN0RW50aXRpZXNUYXNrSWQ6ICcnLFxuICAgIHJpZ2h0YnJhaW5FeHRyYWN0SW5wdXRGaWVsZDogJ3BhZ2VfdGV4dCcsXG4gICAgcmlnaHRicmFpbkV4dHJhY3RPdXRwdXRUaGlyZFBhcnR5RmllbGQ6ICd0aGlyZF9wYXJ0eV9zdWJwcm9jZXNzb3JzJyxcbiAgICByaWdodGJyYWluRXh0cmFjdE91dHB1dE93bkVudGl0aWVzRmllbGQ6ICdvd25fZW50aXRpZXMnLFxuICAgIHJpZ2h0YnJhaW5EZWR1cGxpY2F0ZVN1YnByb2Nlc3NvcnNUYXNrSWQ6ICcnLFxuICAgIHJpZ2h0YnJhaW5EdWNrRHVja0dvU2VhcmNoVGFza0lkOiAnJyxcbiAgICBjcmVhdGVQYWdlc0Zvck93bkVudGl0aWVzOiBmYWxzZSxcbiAgICB2ZXJib3NlRGVidWc6IGZhbHNlLFxuICAgIG1heFJlc3VsdHNQZXJQcm9jZXNzb3I6IDEsXG4gICAgbWF4UmVjdXJzaXZlRGVwdGg6IDIsXG4gICAgZGlzY292ZXJ5Q2FjaGVEYXlzOiAzMCxcbiAgICBwcm9jZXNzb3JzRm9sZGVyUGF0aDogJ1Byb2Nlc3NvcnMnLFxuICAgIGFuYWx5c2lzTG9nc0ZvbGRlclBhdGg6ICdBbmFseXNpcyBMb2dzJyxcbiAgICByaWdodGJyYWluRmluZERwYVRhc2tJZDogJycsIFxuICAgIHJpZ2h0YnJhaW5GaW5kVG9zVGFza0lkOiAnJywgXG4gICAgcmlnaHRicmFpbkZpbmRTZWN1cml0eVRhc2tJZDogJycsXG4gICAgYXV0b1N5bmNocm9uaXplVGFza3M6IHRydWUsXG4gICAgbGxtTW9kZWxMaXN0OiBbXSxcbiAgICBsbG1Nb2RlbExpc3RMYXN0VXBkYXRlZDogMCxcbiAgICB2ZXJpZnlVcmxNb2RlbElkOiAnJywgLy8gV2UnbGwgbGVhdmUgdGhlc2UgYmxhbmsgYW5kIGhhbmRsZSBkZWZhdWx0cyBpbiB0aGUgVUlcbiAgICBleHRyYWN0RW50aXRpZXNNb2RlbElkOiAnJyxcbiAgICBkZWR1cGxpY2F0ZVN1YnByb2Nlc3NvcnNNb2RlbElkOiAnJyxcbiAgICBkdWNrRHVja0dvU2VhcmNoTW9kZWxJZDogJycsXG4gICAgZmluZERwYU1vZGVsSWQ6ICcnLFxuICAgIGZpbmRUb3NNb2RlbElkOiAnJyxcbiAgICBmaW5kU2VjdXJpdHlNb2RlbElkOiAnJyxcbn1cblxuLy8gLS0tLS0gREFUQSBTVFJVQ1RVUkVTIC0tLS0tXG5pbnRlcmZhY2UgU2VycEFwaVJlc3VsdCB7XG4gICAgdGl0bGU6IHN0cmluZzsgdXJsOiBzdHJpbmc7IHNuaXBwZXQ6IHN0cmluZzsgc2VhcmNoUXVlcnk/OiBzdHJpbmc7XG4gICAgcHJvY2Vzc29yTmFtZTogc3RyaW5nOyBkb2N1bWVudFR5cGU6IHN0cmluZztcbiAgICBzb3VyY2VEcGFVcmw/OiBzdHJpbmc7XG59XG5pbnRlcmZhY2UgRXh0cmFjdGVkUmVsYXRpb25zaGlwIHtcbiAgICBQcmltYXJ5UHJvY2Vzc29yOiBzdHJpbmc7IFN1YnByb2Nlc3Nvck5hbWU6IHN0cmluZzsgUHJvY2Vzc2luZ0Z1bmN0aW9uOiBzdHJpbmc7XG4gICAgTG9jYXRpb246IHN0cmluZzsgUmVsYXRpb25zaGlwVHlwZTogJ3VzZXNfc3VicHJvY2Vzc29yJyB8ICdpc19vd25fZW50aXR5JztcbiAgICBTb3VyY2VVUkw6IHN0cmluZzsgVmVyaWZpY2F0aW9uUmVhc29uaW5nOiBzdHJpbmc7XG59XG5pbnRlcmZhY2UgUHJvY2Vzc2VkVXJsSW5mbyBleHRlbmRzIFBhcnRpYWw8U2VycEFwaVJlc3VsdD4ge1xuICAgIHVybDogc3RyaW5nOyB0aXRsZT86IHN0cmluZzsgdmVyaWZpY2F0aW9uTWV0aG9kPzogc3RyaW5nOyB2ZXJpZmljYXRpb25SZWFzb25pbmc/OiBzdHJpbmc7XG4gICAgaXNMaXN0PzogYm9vbGVhbjsgaXNDdXJyZW50PzogYm9vbGVhbjsgZXh0cmFjdGVkU3VicHJvY2Vzc29yc0NvdW50PzogbnVtYmVyOyBkb2N1bWVudFR5cGU6IHN0cmluZztcbn1cbmludGVyZmFjZSBTZWFyY2hEYXRhIHtcbiAgICBjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzOiBFeHRyYWN0ZWRSZWxhdGlvbnNoaXBbXTtcbiAgICBwcm9jZXNzZWRVcmxEZXRhaWxzOiBQcm9jZXNzZWRVcmxJbmZvW107XG4gICAgZmxhZ2dlZENhbmRpZGF0ZVVybENvdW50OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBTdWJwcm9jZXNzb3JQYWdlSW5mbyB7XG4gICAgZmlsZV9wYXRoOiBzdHJpbmc7XG4gICAgcGFnZV9uYW1lOiBzdHJpbmc7XG4gICAgYWxpYXNlczogc3RyaW5nW107XG59XG5cbmludGVyZmFjZSBEZWR1cGxpY2F0aW9uUmVzdWx0SXRlbSB7XG4gICAgc3Vydml2b3JfZmlsZV9wYXRoOiBzdHJpbmc7XG4gICAgZHVwbGljYXRlX2ZpbGVfcGF0aHM6IHN0cmluZ1tdO1xuICAgIHJlYXNvbmluZz86IHN0cmluZztcbn1cblxuXG4vLyAtLS0tLSBNQUlOIFBMVUdJTiBDTEFTUyAtLS0tLVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvY2Vzc29yUHJvY2Vzc29yUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBzZXR0aW5nczogUHJvY2Vzc29yUHJvY2Vzc29yU2V0dGluZ3M7XG4gICAgcHJpdmF0ZSBwcm9jZXNzZWRJbkN1cnJlbnRSZWN1cnNpdmVTZWFyY2g6IFNldDxzdHJpbmc+O1xuXG4gICAgYXN5bmMgb25sb2FkKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NlZEluQ3VycmVudFJlY3Vyc2l2ZVNlYXJjaCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy51cGRhdGVMbG1Nb2RlbExpc3QoZmFsc2UpOyBcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5hdXRvU3luY2hyb25pemVUYXNrcykge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnN5bmNocm9uaXplUmlnaHRCcmFpblRhc2tzKCksIDEwMDApOyBcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkUmliYm9uSWNvbignbGluaycsICdNYW51YWxseSBBZGQgU3VicHJvY2Vzc29yIExpc3QgVVJMJywgKGV2dDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgbmV3IE1hbnVhbElucHV0TW9kYWwodGhpcy5hcHAsIGFzeW5jIChwcm9jZXNzb3JOYW1lLCBsaXN0VXJsLCBpc1ByaW1hcnkpID0+IHsgLy8gPC0tIFVwZGF0ZWQgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3Nvck5hbWUgJiYgbGlzdFVybCkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBQcm9jZXNzaW5nIG1hbnVhbCBVUkwgaW5wdXQgZm9yOiAke3Byb2Nlc3Nvck5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NvckZpbGUgPSBhd2FpdCB0aGlzLmVuc3VyZVByb2Nlc3NvckZpbGUocHJvY2Vzc29yTmFtZSwgdHJ1ZSwgaXNQcmltYXJ5KTsgLy8gPC0tIFBhc3MgZmxhZ1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc29yRmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoRGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2hEYXRhRnJvbURpcmVjdFVybChwcm9jZXNzb3JOYW1lLCBsaXN0VXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2hEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0U3VicHJvY2Vzc29ySW5mbyhwcm9jZXNzb3JOYW1lLCBwcm9jZXNzb3JGaWxlLCBzZWFyY2hEYXRhLCBpc1ByaW1hcnkpOyAvLyA8LS0gUGFzcyBmbGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaERhdGEuZmxhZ2dlZENhbmRpZGF0ZVVybENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGAke3NlYXJjaERhdGEuZmxhZ2dlZENhbmRpZGF0ZVVybENvdW50fSBVUkwocykgbG9va2VkIHByb21pc2luZyBidXQgY291bGRuJ3QgYmUgdmVyaWZpZWQuIENoZWNrIGxvZ3MuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBDb3VsZCBub3QgcHJvY2VzcyBkYXRhIGZyb20gZGlyZWN0IFVSTCBmb3IgJHtwcm9jZXNzb3JOYW1lfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYENvdWxkIG5vdCBjcmVhdGUgb3IgZmluZCBmaWxlIGZvciAke3Byb2Nlc3Nvck5hbWV9IGluICR7dGhpcy5zZXR0aW5ncy5wcm9jZXNzb3JzRm9sZGVyUGF0aH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLm9wZW4oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRSaWJib25JY29uKCdwYXN0ZScsICdJbnB1dCBTdWJwcm9jZXNzb3IgTGlzdCBmcm9tIFRleHQnLCAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9wZW5NYW51YWxUZXh0RW50cnlNb2RhbCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdydW4tcHJvY2Vzc29yLXNlYXJjaC1nbG9iYWwnLFxuICAgICAgICAgICAgbmFtZTogJ1NlYXJjaCBmb3IgU3VicHJvY2Vzc29ycyAoRGlzY292ZXIpJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbmV3IFNlYXJjaE1vZGFsKHRoaXMuYXBwLCB0aGlzLnNldHRpbmdzLCBhc3luYyAocHJvY2Vzc29yTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc29yTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgU3RhcnRpbmcgZGlzY292ZXJ5IHNlYXJjaCBmb3I6ICR7cHJvY2Vzc29yTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NvckZpbGUgPSBhd2FpdCB0aGlzLmVuc3VyZVByb2Nlc3NvckZpbGUocHJvY2Vzc29yTmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc29yRmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzY292ZXJBbmRQcm9jZXNzUHJvY2Vzc29yUGFnZShwcm9jZXNzb3JOYW1lLCBwcm9jZXNzb3JGaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgQ291bGQgbm90IGNyZWF0ZSBvciBmaW5kIGZpbGUgZm9yICR7cHJvY2Vzc29yTmFtZX0gaW4gJHt0aGlzLnNldHRpbmdzLnByb2Nlc3NvcnNGb2xkZXJQYXRofWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdpbnB1dC1zdWJwcm9jZXNzb3ItbGlzdC1mcm9tLXRleHQnLFxuICAgICAgICAgICAgbmFtZTogJ0lucHV0IFN1YnByb2Nlc3NvciBMaXN0IGZyb20gVGV4dCcsXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub3Blbk1hbnVhbFRleHRFbnRyeU1vZGFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ3J1bi1wcm9jZXNzb3Itc2VhcmNoLXJlY3Vyc2l2ZScsIC8vIE5ldyBJRFxuICAgICAgICAgICAgbmFtZTogJ1NlYXJjaCBmb3IgU3VicHJvY2Vzc29ycyAoUmVjdXJzaXZlIERpc2NvdmVyKScsXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIG5ldyBTZWFyY2hNb2RhbCh0aGlzLmFwcCwgdGhpcy5zZXR0aW5ncywgYXN5bmMgKHByb2Nlc3Nvck5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3Nvck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsOiBBZGQgYSB3YXkgZm9yIHRoZSB1c2VyIHRvIHNldCBtYXhEZXB0aCwgb3IgdXNlIGEgZGVmYXVsdC9zZXR0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2NvdmVyUmVjdXJzaXZlbHkocHJvY2Vzc29yTmFtZSwgdW5kZWZpbmVkLCB0aGlzLnNldHRpbmdzLm1heFJlY3Vyc2l2ZURlcHRoKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdmb3JjZS1tZXJnZS1wcm9jZXNzb3JzLWZyb20tcGFsZXR0ZScsXG4gICAgICAgICAgICBuYW1lOiAnRm9yY2UgTWVyZ2UgcHJvY2Vzc29yIGZpbGVzLi4uJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuRmlsZVNlbGVjdG9yTWVyZ2VNb2RhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdzeW5jaHJvbml6ZS1yaWdodGJyYWluLXRhc2tzJyxcbiAgICAgICAgICAgIG5hbWU6ICdTeW5jaHJvbml6ZSBSaWdodEJyYWluIFRhc2tzJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zeW5jaHJvbml6ZVJpZ2h0QnJhaW5UYXNrcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdjb21wbGV0ZS1maXJzdC10aW1lLXNldHVwJyxcbiAgICAgICAgICAgIG5hbWU6ICdDb21wbGV0ZSBGaXJzdC1UaW1lIFNldHVwIChDcmVkZW50aWFscyAmIFRhc2tzKScsXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIG5ldyBQYXN0ZUVudk1vZGFsKHRoaXMuYXBwLCB0aGlzKS5vcGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ2FwcGx5LXJlY29tbWVuZGVkLWdyYXBoLXNldHRpbmdzJyxcbiAgICAgICAgICAgIG5hbWU6ICdBcHBseSBSZWNvbW1lbmRlZCBHcmFwaCBTZXR0aW5ncycsXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlSZWNvbW1lbmRlZEdyYXBoU2V0dGluZ3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLm9uKCdmaWxlLW1lbnUnLCAobWVudTogTWVudSwgZmlsZU9yRm9sZGVyOiBURmlsZSB8IFRGb2xkZXIsIHNvdXJjZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTG9naWMgZm9yIHNpbmdsZSBmb2xkZXJzXG4gICAgICAgICAgICAgICAgaWYgKGZpbGVPckZvbGRlciBpbnN0YW5jZW9mIFRGb2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gZmlsZU9yRm9sZGVyIGFzIFRGb2xkZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2xkZXIucGF0aCA9PT0gdGhpcy5zZXR0aW5ncy5wcm9jZXNzb3JzRm9sZGVyUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVudS5hZGRJdGVtKChpdGVtOiBNZW51SXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0VGl0bGUoJ0RlZHVwbGljYXRlIFN1YnByb2Nlc3NvciBQYWdlcycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRJY29uKCdnaXQtcHVsbC1yZXF1ZXN0LWRyYWZ0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5EZWR1cGxpY2F0ZVN1YnByb2Nlc3NvcnNUYXNrSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiRGVkdXBsaWNhdGlvbiBUYXNrIElEIG5vdCBzZXQgaW4gcGx1Z2luIHNldHRpbmdzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBTdGFydGluZyBkZWR1cGxpY2F0aW9uIGZvciBmb2xkZXI6ICR7Zm9sZGVyLnBhdGh9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJ1bkRlZHVwbGljYXRpb25Gb3JGb2xkZXIoZm9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgLy8gTG9naWMgZm9yIHNpbmdsZSBmaWxlc1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbGVPckZvbGRlciBpbnN0YW5jZW9mIFRGaWxlICYmIGZpbGVPckZvbGRlci5leHRlbnNpb24gPT09ICdtZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGZpbGVPckZvbGRlciBhcyBURmlsZTtcbiAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLnBhdGguc3RhcnRzV2l0aCh0aGlzLnNldHRpbmdzLnByb2Nlc3NvcnNGb2xkZXJQYXRoICsgXCIvXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlQ2FjaGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb250bWF0dGVyID0gZmlsZUNhY2hlPy5mcm9udG1hdHRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUHJvY2Vzc29yTmFtZSA9IChmcm9udG1hdHRlcj8uYWxpYXNlcyAmJiBBcnJheS5pc0FycmF5KGZyb250bWF0dGVyLmFsaWFzZXMpICYmIGZyb250bWF0dGVyLmFsaWFzZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGZyb250bWF0dGVyLmFsaWFzZXNbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZpbGUuYmFzZW5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbnUuYWRkSXRlbSgoaXRlbTogTWVudUl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFRpdGxlKCdNYXAgU3VicHJvY2Vzc29yIFJlbGF0aW9uc2hpcHMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbignY2hldnJvbnMtZG93bi11cCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYFN0YXJ0aW5nIHJlY3Vyc2l2ZSBkaXNjb3ZlcnkgZnJvbTogJHtvcmlnaW5hbFByb2Nlc3Nvck5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2NvdmVyUmVjdXJzaXZlbHkob3JpZ2luYWxQcm9jZXNzb3JOYW1lLCBmaWxlLCB0aGlzLnNldHRpbmdzLm1heFJlY3Vyc2l2ZURlcHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWVudS5hZGRJdGVtKChpdGVtOiBNZW51SXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0VGl0bGUoJ0Rpc2NvdmVyIFN1YnByb2Nlc3NvciBMaXN0Jykuc2V0SWNvbignd2FuZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYERpc2NvdmVyaW5nIHN1YnByb2Nlc3NvciBsaXN0IGZvcjogJHtvcmlnaW5hbFByb2Nlc3Nvck5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2NvdmVyQW5kUHJvY2Vzc1Byb2Nlc3NvclBhZ2Uob3JpZ2luYWxQcm9jZXNzb3JOYW1lLCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWVudS5hZGRJdGVtKChpdGVtOiBNZW51SXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0VGl0bGUoJ0VucmljaCBQcm9jZXNzb3IgRG9jdW1lbnRhdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRJY29uKCdib29rLXBsdXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBFbnJpY2hpbmcgZG9jdW1lbnRhdGlvbiBmb3I6ICR7b3JpZ2luYWxQcm9jZXNzb3JOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbnJpY2hQcm9jZXNzb3JGaWxlKG9yaWdpbmFsUHJvY2Vzc29yTmFtZSwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbnUuYWRkSXRlbSgoaXRlbTogTWVudUl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFRpdGxlKCdBZGQgU3VicHJvY2Vzc29yIExpc3QgVVJMJykuc2V0SWNvbigncGx1cy1jaXJjbGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTWFudWFsSW5wdXRNb2RhbCh0aGlzLmFwcCwgYXN5bmMgKHBOYW1lLCBsaXN0VXJsLCBpc1ByaW1hcnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlzdFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBQcm9jZXNzaW5nIG1hbnVhbCBVUkwgaW5wdXQgZm9yOiAke29yaWdpbmFsUHJvY2Vzc29yTmFtZX0gdXNpbmcgVVJMOiAke2xpc3RVcmx9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaERhdGEgPSBhd2FpdCB0aGlzLmZldGNoRGF0YUZyb21EaXJlY3RVcmwob3JpZ2luYWxQcm9jZXNzb3JOYW1lLCBsaXN0VXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdFN1YnByb2Nlc3NvckluZm8ob3JpZ2luYWxQcm9jZXNzb3JOYW1lLCBmaWxlLCBzZWFyY2hEYXRhLCBpc1ByaW1hcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2hEYXRhLmZsYWdnZWRDYW5kaWRhdGVVcmxDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGAke3NlYXJjaERhdGEuZmxhZ2dlZENhbmRpZGF0ZVVybENvdW50fSBVUkwocykgbG9va2VkIHByb21pc2luZyBidXQgY291bGRuJ3QgYmUgdmVyaWZpZWQuIENoZWNrIGxvZ3MuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBDb3VsZCBub3QgcHJvY2VzcyBkYXRhIGZyb20gZGlyZWN0IFVSTCBmb3IgJHtvcmlnaW5hbFByb2Nlc3Nvck5hbWV9LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3JpZ2luYWxQcm9jZXNzb3JOYW1lKS5vcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbnUuYWRkSXRlbSgoaXRlbTogTWVudUl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFRpdGxlKCdJbnB1dCBTdWJwcm9jZXNzb3IgTGlzdCBmcm9tIFRleHQnKS5zZXRJY29uKCdmaWxlLWlucHV0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuTWFudWFsVGV4dEVudHJ5TW9kYWwob3JpZ2luYWxQcm9jZXNzb3JOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBQcm9jZXNzb3JQcm9jZXNzb3JTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzb3IgUHJvY2Vzc29yIHBsdWdpbiBsb2FkZWQuJyk7XG4gICAgfVxuXG4gICAgb251bmxvYWQoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzb3IgUHJvY2Vzc29yIHBsdWdpbiB1bmxvYWRlZC4nKTtcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBMTE0gbW9kZWxzIGZyb20gdGhlIFJpZ2h0YnJhaW4gQVBJLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIExsbU1vZGVsIG9iamVjdHMuXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hMbG1Nb2RlbHMoKTogUHJvbWlzZTxMbG1Nb2RlbFtdPiB7XG4gICAgICAgIGNvbnN0IHJiVG9rZW4gPSBhd2FpdCB0aGlzLmdldFJpZ2h0QnJhaW5BY2Nlc3NUb2tlbigpO1xuICAgICAgICBpZiAoIXJiVG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgZmV0Y2ggTExNIG1vZGVscyB3aXRob3V0IGFuIGFjY2VzcyB0b2tlbi5cIik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtb2RlbHNVcmwgPSBgJHt0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5BcGlVcmx9L29yZy8ke3RoaXMuc2V0dGluZ3MucmlnaHRicmFpbk9yZ0lkfS9wcm9qZWN0LyR7dGhpcy5zZXR0aW5ncy5yaWdodGJyYWluUHJvamVjdElkfS9tb2RlbGA7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7ICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3JiVG9rZW59YCB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoeyB1cmw6IG1vZGVsc1VybCwgbWV0aG9kOiAnR0VUJywgaGVhZGVyczogaGVhZGVycywgdGhyb3c6IGZhbHNlIH0pO1xuXG4gICAgICAgICAgICAvLyBGSVg6IENoZWNrIGlmIHRoZSByZXNwb25zZSBpdHNlbGYgaXMgYW4gYXJyYXlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCAmJiBBcnJheS5pc0FycmF5KHJlc3BvbnNlLmpzb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gRklYOiBNYXAgb3ZlciB0aGUgcmVzcG9uc2UuanNvbiBkaXJlY3RseSwgbm90IHJlc3BvbnNlLmpzb24ubW9kZWxzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24ubWFwKChtb2RlbDogYW55KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBpZDogbW9kZWwuaWQsXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzOiBtb2RlbC5hbGlhc1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBsaXN0IFJpZ2h0QnJhaW4gTExNIG1vZGVsczpcIiwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS50ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgUmlnaHRCcmFpbiBMTE0gbW9kZWxzOlwiLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjYWNoZWQgbGlzdCBvZiBMTE0gbW9kZWxzIGlmIHRoZSBjYWNoZSBpcyBzdGFsZSBvciBpZiBmb3JjZWQuXG4gICAgICogQHBhcmFtIGZvcmNlIC0gSWYgdHJ1ZSwgYnlwYXNzZXMgdGhlIGNhY2hlIGNoZWNrLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUxsbU1vZGVsTGlzdChmb3JjZTogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGNhY2hlRHVyYXRpb24gPSAyNCAqIDYwICogNjAgKiAxMDAwOyAvLyAyNCBob3Vyc1xuXG4gICAgICAgIGNvbnN0IGhhc0NyZWRlbnRpYWxzID0gdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluQ2xpZW50SWQgJiYgdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluT3JnSWQgJiYgdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluUHJvamVjdElkO1xuXG4gICAgICAgIGlmICghZm9yY2UgJiYgdGhpcy5zZXR0aW5ncy5sbG1Nb2RlbExpc3QubGVuZ3RoID4gMCAmJiAobm93IC0gdGhpcy5zZXR0aW5ncy5sbG1Nb2RlbExpc3RMYXN0VXBkYXRlZCA8IGNhY2hlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIFVzZSBjYWNoZWQgZGF0YVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXNDcmVkZW50aWFscykge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBDYW4ndCBmZXRjaCB3aXRob3V0IGNyZWRlbnRpYWxzLlxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVscyA9IGF3YWl0IHRoaXMuZmV0Y2hMbG1Nb2RlbHMoKTtcbiAgICAgICAgICAgIGlmIChtb2RlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MubGxtTW9kZWxMaXN0ID0gbW9kZWxzO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MubGxtTW9kZWxMaXN0TGFzdFVwZGF0ZWQgPSBub3c7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnTExNIG1vZGVsIGxpc3QgaGFzIGJlZW4gdXBkYXRlZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSBMTE0gbW9kZWwgbGlzdDpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnRmFpbGVkIHRvIHVwZGF0ZSBMTE0gbW9kZWwgbGlzdC4gQ2hlY2sgY29uc29sZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgb3Blbk1hbnVhbFRleHRFbnRyeU1vZGFsKGluaXRpYWxQcm9jZXNzb3JOYW1lPzogc3RyaW5nKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluRXh0cmFjdEVudGl0aWVzVGFza0lkKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiUmlnaHRCcmFpbiBUYXNrIElEIGZvciBlbnRpdHkgZXh0cmFjdGlvbiBpcyBub3QgY29uZmlndXJlZC4gUGxlYXNlIHNldCBpdCBpbiBwbHVnaW4gc2V0dGluZ3MuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5ldyBNYW51YWxUZXh0RW50cnlNb2RhbCh0aGlzLmFwcCwgYXN5bmMgKHByb2Nlc3Nvck5hbWUsIHBhc3RlZFRleHQsIGlzUHJpbWFyeSkgPT4geyBcbiAgICAgICAgICAgIGlmIChwcm9jZXNzb3JOYW1lICYmIHBhc3RlZFRleHQpIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBQcm9jZXNzaW5nIHBhc3RlZCB0ZXh0IGZvcjogJHtwcm9jZXNzb3JOYW1lfWApO1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgdGhlICdpc1ByaW1hcnknIGZsYWcgdG8gZW5zdXJlIHRoZSBjb3JyZWN0IHRhZyBpcyBhcHBsaWVkXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29yRmlsZSA9IGF3YWl0IHRoaXMuZW5zdXJlUHJvY2Vzc29yRmlsZShwcm9jZXNzb3JOYW1lLCB0cnVlLCBpc1ByaW1hcnkpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzb3JGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaERhdGEgPSBhd2FpdCB0aGlzLmZldGNoRGF0YUZyb21QYXN0ZWRUZXh0KHByb2Nlc3Nvck5hbWUsIHBhc3RlZFRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyB0aGUgJ2lzUHJpbWFyeScgZmxhZyBoZXJlIGFzIHdlbGwgZm9yIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RTdWJwcm9jZXNzb3JJbmZvKHByb2Nlc3Nvck5hbWUsIHByb2Nlc3NvckZpbGUsIHNlYXJjaERhdGEsIGlzUHJpbWFyeSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBDb3VsZCBub3QgcHJvY2VzcyBkYXRhIGZyb20gcGFzdGVkIHRleHQgZm9yICR7cHJvY2Vzc29yTmFtZX0uYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBDb3VsZCBub3QgY3JlYXRlIG9yIGZpbmQgZmlsZSBmb3IgJHtwcm9jZXNzb3JOYW1lfSBpbiAke3RoaXMuc2V0dGluZ3MucHJvY2Vzc29yc0ZvbGRlclBhdGh9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpbml0aWFsUHJvY2Vzc29yTmFtZSkub3BlbigpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2FuaXRpemVOYW1lRm9yRmlsZVBhdGhBbmRBbGlhcyhlbnRpdHlOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsKTogeyBmaWxlUGF0aE5hbWU6IHN0cmluZywgb3JpZ2luYWxOYW1lQXNBbGlhczogc3RyaW5nIH0ge1xuICAgICAgICBjb25zdCBvcmlnaW5hbE5hbWUgPSAoZW50aXR5TmFtZSB8fCBcIlVua25vd24gRW50aXR5XCIpLnRyaW0oKTtcbiAgICAgICAgbGV0IGJhc2VOYW1lRm9yRmlsZSA9IG9yaWdpbmFsTmFtZTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgXCJkYmFcIiBwYXR0ZXJucyB0byBwcmlvcml0aXplIHRoZSBcImRvaW5nIGJ1c2luZXNzIGFzXCIgbmFtZSBmb3IgdGhlIGZpbGVcbiAgICAgICAgY29uc3QgZGJhUmVnZXggPSAvXiguKj8pXFxzKyg/OmRiYXxkXFwvYlxcL2F8ZG9pbmcgYnVzaW5lc3MgYXMpXFxzKyguKikkL2k7XG4gICAgICAgIGNvbnN0IGRiYU1hdGNoID0gb3JpZ2luYWxOYW1lLm1hdGNoKGRiYVJlZ2V4KTtcbiAgICAgICAgaWYgKGRiYU1hdGNoICYmIGRiYU1hdGNoWzJdKSB7IC8vIGRiYU1hdGNoWzJdIGlzIHRoZSBuYW1lIGFmdGVyICdkYmEnXG4gICAgICAgICAgICBiYXNlTmFtZUZvckZpbGUgPSBkYmFNYXRjaFsyXS50cmltKCk7IC8vIFVzZSB0aGlzIGFzIHRoZSBiYXNlIGZvciB0aGUgZmlsZW5hbWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSBjb21tYXMgZnJvbSB0aGUgYmFzZSBuYW1lIGZvciB0aGUgZmlsZSwgYXMgdGhleSBjYW4gYmUgcHJvYmxlbWF0aWMgaW4gbGlua3MvdGFnc1xuICAgICAgICBsZXQgZmlsZVBhdGhOYW1lID0gYmFzZU5hbWVGb3JGaWxlLnJlcGxhY2UoLywvZywgJycpO1xuICAgICAgICAvLyBSZXBsYWNlIGNoYXJhY3RlcnMgZm9yYmlkZGVuIGluIGZpbGUgcGF0aHNcbiAgICAgICAgZmlsZVBhdGhOYW1lID0gZmlsZVBhdGhOYW1lLnJlcGxhY2UoL1tcXFxcLzoqP1wiPD58XS9nLCAnJykudHJpbSgpO1xuXG4gICAgICAgIC8vIElmIGZpbGVQYXRoTmFtZSBiZWNvbWVzIGVtcHR5IGFmdGVyIHNhbml0aXphdGlvbiAoZS5nLiwgbmFtZSB3YXMganVzdCBcIi8vL1wiKSxcbiAgICAgICAgLy8gdXNlIGEgc2FuaXRpemVkIHZlcnNpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bGwgbmFtZSBvciBhIGZhbGxiYWNrLlxuICAgICAgICBpZiAoIWZpbGVQYXRoTmFtZSkge1xuICAgICAgICAgICAgZmlsZVBhdGhOYW1lID0gb3JpZ2luYWxOYW1lLnJlcGxhY2UoL1tcXFxcLzoqP1wiPD58LF0vZywgJycpLnJlcGxhY2UoL1xccysvZywgJ18nKSB8fCBcIlNhbml0aXplZF9FbnRpdHlcIjtcbiAgICAgICAgfVxuICAgICAgICAgaWYgKCFmaWxlUGF0aE5hbWUpIHsgLy8gRmluYWwgZmFsbGJhY2sgaWYgaXQncyBzdGlsbCBzb21laG93IGVtcHR5XG4gICAgICAgICAgICBmaWxlUGF0aE5hbWUgPSBcIlNhbml0aXplZF9FbnRpdHlfXCIgKyBEYXRlLm5vdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpbGVQYXRoTmFtZTogZmlsZVBhdGhOYW1lLFxuICAgICAgICAgICAgb3JpZ2luYWxOYW1lQXNBbGlhczogb3JpZ2luYWxOYW1lIC8vIFRoZSBvcmlnaW5hbCBmdWxsIG5hbWUgaXMgYWx3YXlzIHVzZWQgYXMgYW4gYWxpYXNcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgc2NydWJIeXBlcmxpbmtzKHRleHQ6IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwpOiBzdHJpbmcge1xuICAgICAgICBpZiAoIXRleHQpIHJldHVybiBcIk4vQVwiOyAvLyBSZXR1cm4gXCJOL0FcIiBpZiBpbnB1dCBpcyBudWxsLCB1bmRlZmluZWQsIG9yIGVtcHR5XG4gICAgICAgIGxldCBzY3J1YmJlZFRleHQgPSBTdHJpbmcodGV4dCk7IC8vIEVuc3VyZSBpdCdzIGEgc3RyaW5nXG5cbiAgICAgICAgLy8gUmVtb3ZlIE1hcmtkb3duIGxpbmtzOiBbbGluayB0ZXh0XSh1cmwpIC0+IGxpbmsgdGV4dFxuICAgICAgICBzY3J1YmJlZFRleHQgPSBzY3J1YmJlZFRleHQucmVwbGFjZSgvXFxbKC4qPylcXF1cXCgoPzouKj8pXFwpL2csICckMScpO1xuICAgICAgICAvLyBSZW1vdmUgSFRNTCBsaW5rczogPGEgaHJlZj1cIi4uLlwiPmxpbmsgdGV4dDwvYT4gLT4gbGluayB0ZXh0XG4gICAgICAgIHNjcnViYmVkVGV4dCA9IHNjcnViYmVkVGV4dC5yZXBsYWNlKC88YVtePl0qPiguKj8pPFxcL2E+L2dpLCAnJDEnKTtcbiAgICAgICAgLy8gU3RyaXAgYW55IHJlbWFpbmluZyBIVE1MIHRhZ3NcbiAgICAgICAgc2NydWJiZWRUZXh0ID0gc2NydWJiZWRUZXh0LnJlcGxhY2UoLzxbXj5dKz4vZywgJycpO1xuICAgICAgICAvLyBOb3JtYWxpemUgd2hpdGVzcGFjZSAobXVsdGlwbGUgc3BhY2VzL25ld2xpbmVzIHRvIHNpbmdsZSBzcGFjZSlcbiAgICAgICAgc2NydWJiZWRUZXh0ID0gc2NydWJiZWRUZXh0LnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XG5cbiAgICAgICAgcmV0dXJuIHNjcnViYmVkVGV4dCB8fCBcIk4vQVwiOyAvLyBSZXR1cm4gXCJOL0FcIiBpZiB0aGUgcmVzdWx0IGlzIGFuIGVtcHR5IHN0cmluZ1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBhZGRSZWxhdGlvbnNoaXAoXG4gICAgICAgIGNvbGxlY3RlZFJlbGF0aW9uc2hpcHM6IEV4dHJhY3RlZFJlbGF0aW9uc2hpcFtdLFxuICAgICAgICBzZWVuUmVsYXRpb25zaGlwczogU2V0PHN0cmluZz4sIC8vIFRvIHRyYWNrIHVuaXF1ZSAoUHJpbWFyeVByb2Nlc3NvciwgU3VicHJvY2Vzc29yTmFtZSwgVHlwZSkgdHVwbGVzXG4gICAgICAgIHByb2Nlc3Nvck5hbWU6IHN0cmluZywgICAgICAgICAgLy8gVGhlIG5hbWUgb2YgdGhlIHByaW1hcnkgcHJvY2Vzc29yIHRoaXMgcmVsYXRpb25zaGlwIHBlcnRhaW5zIHRvXG4gICAgICAgIGVudGl0eTogYW55LCAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJhdyBlbnRpdHkgb2JqZWN0IChlLmcuLCBmcm9tIFJpZ2h0QnJhaW4pXG4gICAgICAgIHR5cGU6IEV4dHJhY3RlZFJlbGF0aW9uc2hpcFsnUmVsYXRpb25zaGlwVHlwZSddLCAvLyAndXNlc19zdWJwcm9jZXNzb3InIG9yICdpc19vd25fZW50aXR5J1xuICAgICAgICBzb3VyY2VVcmw6IHN0cmluZywgICAgICAgICAgICAgIC8vIFRoZSBVUkwgd2hlcmUgdGhpcyBpbmZvcm1hdGlvbiB3YXMgZm91bmQvdmVyaWZpZWRcbiAgICAgICAgdmVyaWZpY2F0aW9uUmVhc29uaW5nOiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsIC8vIFJlYXNvbmluZyBmcm9tIHZlcmlmaWNhdGlvbiwgaWYgYW55XG4gICAgKTogbnVtYmVyIHsgLy8gUmV0dXJucyAxIGlmIGEgbmV3IHJlbGF0aW9uc2hpcCB3YXMgYWRkZWQsIDAgb3RoZXJ3aXNlXG5cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxFbnRpdHlOYW1lID0gZW50aXR5Lm5hbWU/LnRyaW0oKTtcbiAgICAgICAgaWYgKCFvcmlnaW5hbEVudGl0eU5hbWUpIHJldHVybiAwOyAvLyBTa2lwIGlmIG5vIG5hbWVcblxuICAgICAgICAvLyBVc2UgdGhlIG9yaWdpbmFsLCB1bmFsdGVyZWQgZW50aXR5IG5hbWUgZm9yIHN0b3JhZ2UgYW5kIGNvbXBhcmlzb25cbiAgICAgICAgLy8gVGhlIHNhbml0aXphdGlvbiBmb3IgZmlsZSBwYXRocyB3aWxsIGhhcHBlbiBsYXRlciB3aGVuIGNyZWF0aW5nIGZpbGVzLlxuICAgICAgICBjb25zdCBzdWJwcm9jZXNzb3JOYW1lVG9TdG9yZSA9IG9yaWdpbmFsRW50aXR5TmFtZTtcblxuICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBPcGVuQUkgLSBza2lwIGlmIGl0J3MgaWRlbnRpZnlpbmcgaXRzIG93biBrbm93biBhZmZpbGlhdGVzIGFzIFwib3duX2VudGl0eVwiXG4gICAgICAgIC8vIFRoaXMgcHJldmVudHMgT3BlbkFJIGZyb20gbGlzdGluZyBpdHNlbGYgb3IgaXRzIGNvcmUgY29tcG9uZW50cyBhcyBpZiB0aGV5IHdlcmUgZGlzdGluY3Qgc3VicHJvY2Vzc29ycyAqb2YgaXRzZWxmKi5cbiAgICAgICAgaWYgKHByb2Nlc3Nvck5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJvcGVuYWlcIiAmJiB0eXBlID09PSBcImlzX293bl9lbnRpdHlcIikge1xuICAgICAgICAgICAgY29uc3Qgb3BlbmFpQWZmaWxpYXRlcyA9IFtcIm9wZW5haSBnbG9iYWxcIiwgXCJvcGVuYWksIG9wY29cIiwgXCJvcGVuYWkgaXJlbGFuZFwiLCBcIm9wZW5haSB1a1wiLCBcIm9wZW5haSBqYXBhblwiLCBcIm9wZW5haWdsb2JhbFwiLCBcIm9wZW5haSBvcGNvXCIsIFwib3BlbmFpIGxsY1wiXTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBlbnRpdHkgbmFtZSBsb29rcyBsaWtlIG9uZSBvZiBPcGVuQUkncyBvd24gY29tbW9uIG5hbWVzL2FmZmlsaWF0ZXMsIGRvbid0IGFkZCBpdCBhcyBhbiBcIm93bl9lbnRpdHlcIiByZWxhdGlvbnNoaXAgZm9yIE9wZW5BSS5cbiAgICAgICAgICAgIGlmIChvcGVuYWlBZmZpbGlhdGVzLnNvbWUoYWZmID0+IG9yaWdpbmFsRW50aXR5TmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGFmZikpIHx8IG9yaWdpbmFsRW50aXR5TmFtZS50b0xvd2VyQ2FzZSgpID09PSBcIm9wZW5haVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgU2tpcHBpbmcgYWRkaW5nICcke29yaWdpbmFsRW50aXR5TmFtZX0nIGFzIG93bl9lbnRpdHkgZm9yIE9wZW5BSSBkdWUgdG8gc2VsZi1yZWZlcmVuY2UvYWZmaWxpYXRlIHJ1bGUuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSB0dXBsZSBmb3IgdGhpcyByZWxhdGlvbnNoaXAgdG8gYXZvaWQgZHVwbGljYXRlcyAqd2l0aGluIHRoZSBjdXJyZW50IHByb2Nlc3NpbmcgcnVuKlxuICAgICAgICBjb25zdCByZWxUdXBsZSA9IGAke3Byb2Nlc3Nvck5hbWV9fCR7c3VicHJvY2Vzc29yTmFtZVRvU3RvcmV9fCR7dHlwZX1gO1xuXG4gICAgICAgIGlmICghc2VlblJlbGF0aW9uc2hpcHMuaGFzKHJlbFR1cGxlKSkge1xuICAgICAgICAgICAgY29sbGVjdGVkUmVsYXRpb25zaGlwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBQcmltYXJ5UHJvY2Vzc29yOiBwcm9jZXNzb3JOYW1lLFxuICAgICAgICAgICAgICAgIFN1YnByb2Nlc3Nvck5hbWU6IHN1YnByb2Nlc3Nvck5hbWVUb1N0b3JlLCAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgbmFtZVxuICAgICAgICAgICAgICAgIFByb2Nlc3NpbmdGdW5jdGlvbjogdGhpcy5zY3J1Ykh5cGVybGlua3MoZW50aXR5LnByb2Nlc3NpbmdfZnVuY3Rpb24pLFxuICAgICAgICAgICAgICAgIExvY2F0aW9uOiB0aGlzLnNjcnViSHlwZXJsaW5rcyhlbnRpdHkubG9jYXRpb24pLFxuICAgICAgICAgICAgICAgIFJlbGF0aW9uc2hpcFR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgU291cmNlVVJMOiBzb3VyY2VVcmwsXG4gICAgICAgICAgICAgICAgVmVyaWZpY2F0aW9uUmVhc29uaW5nOiB0aGlzLnNjcnViSHlwZXJsaW5rcyh2ZXJpZmljYXRpb25SZWFzb25pbmcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlZW5SZWxhdGlvbnNoaXBzLmFkZChyZWxUdXBsZSk7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cblxuICAgIGFzeW5jIGRpc2NvdmVyQW5kUHJvY2Vzc1Byb2Nlc3NvclBhZ2UocHJvY2Vzc29yTmFtZTogc3RyaW5nLCBwcm9jZXNzb3JGaWxlOiBURmlsZSkge1xuICAgICAgICBuZXcgTm90aWNlKGBQcm9jZXNzaW5nIChkaXNjb3ZlcnkpOiAke3Byb2Nlc3Nvck5hbWV9Li4uYCk7XG4gICAgICAgIGNvbnN0IHNlYXJjaERhdGEgPSBhd2FpdCB0aGlzLmZldGNoUHJvY2Vzc29yU2VhcmNoRGF0YVdpdGhEaXNjb3ZlcnkocHJvY2Vzc29yTmFtZSk7XG5cbiAgICAgICAgaWYgKHNlYXJjaERhdGEpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdFN1YnByb2Nlc3NvckluZm8ocHJvY2Vzc29yTmFtZSwgcHJvY2Vzc29yRmlsZSwgc2VhcmNoRGF0YSk7XG4gICAgICAgICAgICBpZiAoc2VhcmNoRGF0YS5mbGFnZ2VkQ2FuZGlkYXRlVXJsQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShgJHtzZWFyY2hEYXRhLmZsYWdnZWRDYW5kaWRhdGVVcmxDb3VudH0gVVJMKHMpIGxvb2tlZCBwcm9taXNpbmcgYnV0IGNvdWxkbid0IGJlIHZlcmlmaWVkLiBDaGVjayBBbmFseXNpcyBMb2cgZm9yIGRldGFpbHMgYW5kIGNvbnNpZGVyIHVzaW5nIHRoZSAnSW5wdXQgZnJvbSBUZXh0JyBmZWF0dXJlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3IE5vdGljZShgRmFpbGVkIHRvIGZldGNoIGRhdGEgdmlhIGRpc2NvdmVyeSBmb3IgJHtwcm9jZXNzb3JOYW1lfS5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGVucmljaFByb2Nlc3NvckZpbGUocHJvY2Vzc29yTmFtZTogc3RyaW5nLCBmaWxlOiBURmlsZSkge1xuICAgICAgICBuZXcgTm90aWNlKGBGZXRjaGluZyBjb21wbGlhbmNlIGRvY3VtZW50cyBmb3IgJHtwcm9jZXNzb3JOYW1lfS4uLmAsIDUwMDApO1xuICAgICAgICBjb25zdCByYlRva2VuID0gYXdhaXQgdGhpcy5nZXRSaWdodEJyYWluQWNjZXNzVG9rZW4oKTtcbiAgICAgICAgaWYgKCFyYlRva2VuKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiRmFpbGVkIHRvIGdldCBSaWdodEJyYWluIHRva2VuLiBBYm9ydGluZyBlbnJpY2htZW50LlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRvY3VtZW50VHlwZXMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6ICdEUEEnLCB0YXNrSWQ6IHRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkZpbmREcGFUYXNrSWQsIHRpdGxlOiBcIkRhdGEgUHJvY2Vzc2luZyBBZ3JlZW1lbnRcIiB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnVG9TJywgdGFza0lkOiB0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5GaW5kVG9zVGFza0lkLCB0aXRsZTogXCJUZXJtcyBvZiBTZXJ2aWNlXCIgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ1NlY3VyaXR5JywgdGFza0lkOiB0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5GaW5kU2VjdXJpdHlUYXNrSWQsIHRpdGxlOiBcIlNlY3VyaXR5IERvY3VtZW50YXRpb25cIiB9XG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgZm91bmREb2N1bWVudHM6IHsgdGl0bGU6IHN0cmluZywgdXJsOiBzdHJpbmcgfVtdID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCBkb2Mgb2YgZG9jdW1lbnRUeXBlcykge1xuICAgICAgICAgICAgaWYgKCFkb2MudGFza0lkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgU2tpcHBpbmcgJHtkb2MudHlwZX0gc2VhcmNoIGZvciAke3Byb2Nlc3Nvck5hbWV9LCBubyBUYXNrIElEIHNldC5gKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdGFza0lucHV0UGF5bG9hZCA9IHsgXCJjb21wYW55X25hbWVcIjogcHJvY2Vzc29yTmFtZSB9O1xuICAgICAgICAgICAgY29uc3QgdGFza1Jlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbFJpZ2h0QnJhaW5UYXNrKGRvYy50YXNrSWQsIHRhc2tJbnB1dFBheWxvYWQsIHJiVG9rZW4pO1xuXG4gICAgICAgICAgICAvLyBBc3N1bWluZyB0aGUgUmlnaHRCcmFpbiB0YXNrIHJldHVybnMgYSBzaW1wbGUgeyBcInVybFwiOiBcIi4uLlwiIH0gb2JqZWN0XG4gICAgICAgICAgICBpZiAodGFza1Jlc3VsdD8ucmVzcG9uc2U/LnVybCAmJiB0aGlzLmlzVmFsaWRVcmwodGFza1Jlc3VsdC5yZXNwb25zZS51cmwpKSB7XG4gICAgICAgICAgICAgICAgZm91bmREb2N1bWVudHMucHVzaCh7IHRpdGxlOiBkb2MudGl0bGUsIHVybDogdGFza1Jlc3VsdC5yZXNwb25zZS51cmwgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgRm91bmQgJHtkb2MudHlwZX0gZm9yICR7cHJvY2Vzc29yTmFtZX06ICR7dGFza1Jlc3VsdC5yZXNwb25zZS51cmx9YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCB2YWxpZCBVUkwgZm9yICR7ZG9jLnR5cGV9IGZvciAke3Byb2Nlc3Nvck5hbWV9LiBSZXN1bHQ6YCwgdGFza1Jlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7IC8vIFNtYWxsIGRlbGF5IGJldHdlZW4gdGFza3NcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3VuZERvY3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYE5vIG5ldyBjb21wbGlhbmNlIGRvY3VtZW50cyBmb3VuZCBmb3IgJHtwcm9jZXNzb3JOYW1lfS5gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvcm1hdCB0aGUgcmVzdWx0cyBpbnRvIGEgbWFya2Rvd24gbGlzdFxuICAgICAgICBsZXQgbWFya2Rvd25Db250ZW50ID0gXCJcXG5cIjsgLy8gU3RhcnQgd2l0aCBhIG5ld2xpbmUgdG8gZW5zdXJlIHNlcGFyYXRpb25cbiAgICAgICAgZm91bmREb2N1bWVudHMuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICAgICAgbWFya2Rvd25Db250ZW50ICs9IGAtICoqJHtkb2MudGl0bGV9OioqIFske2RvYy51cmx9XSgke2RvYy51cmx9KVxcbmA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFVzZSBlbnN1cmVIZWFkaW5nQW5kU2VjdGlvbiB0byBhcHBlbmQgdG8gdGhlIGZpbGVcbiAgICAgICAgY29uc3QgaGVhZGluZyA9IFwiQ29tcGxpYW5jZSBEb2N1bWVudGF0aW9uXCI7XG4gICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LnByb2Nlc3MoZmlsZSwgKGNvbnRlbnQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgLy8gVGhlICd0cnVlJyBhdCB0aGUgZW5kIHRlbGxzIHRoZSBmdW5jdGlvbiB0byBhcHBlbmQgdW5kZXIgdGhlIGhlYWRpbmcgaWYgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIGNyZWF0aW5nIGR1cGxpY2F0ZSBzZWN0aW9ucyBpZiB5b3UgcnVuIGVucmljaG1lbnQgbXVsdGlwbGUgdGltZXMuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVIZWFkaW5nQW5kU2VjdGlvbihjb250ZW50LCBoZWFkaW5nLCBtYXJrZG93bkNvbnRlbnQsIG51bGwsIG51bGwsIHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBuZXcgTm90aWNlKGBTdWNjZXNzZnVsbHkgYWRkZWQgJHtmb3VuZERvY3VtZW50cy5sZW5ndGh9IGRvY3VtZW50IGxpbmsocykgdG8gJHtwcm9jZXNzb3JOYW1lfS5gKTtcbiAgICB9XG5cbiAgICBhc3luYyBzeW5jaHJvbml6ZVJpZ2h0QnJhaW5UYXNrcygpIHtcbiAgICAgICAgbmV3IE5vdGljZShcIlN0YXJ0aW5nIFJpZ2h0QnJhaW4gdGFzayBzeW5jaHJvbml6YXRpb24uLi5cIiwgNDAwMCk7XG4gICAgXG4gICAgICAgIGNvbnN0IGNyZWRzID0ge1xuICAgICAgICAgICAgYXBpVXJsOiB0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5BcGlVcmwsXG4gICAgICAgICAgICBvYXV0aFVybDogdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluT2F1dGgyVXJsLFxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkNsaWVudElkLFxuICAgICAgICAgICAgY2xpZW50U2VjcmV0OiB0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5DbGllbnRTZWNyZXQsXG4gICAgICAgICAgICBvcmdJZDogdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluT3JnSWQsXG4gICAgICAgICAgICBwcm9qZWN0SWQ6IHRoaXMuc2V0dGluZ3MucmlnaHRicmFpblByb2plY3RJZFxuICAgICAgICB9O1xuICAgIFxuICAgICAgICBjb25zdCByYlRva2VuID0gYXdhaXQgdGhpcy5nZXRSaWdodEJyYWluQWNjZXNzVG9rZW4oY3JlZHMpO1xuICAgICAgICBpZiAoIXJiVG9rZW4pIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJUYXNrIHN5bmMgZmFpbGVkOiBDb3VsZCBub3QgZ2V0IFJpZ2h0QnJhaW4gQWNjZXNzIFRva2VuLlwiLCAxMDAwMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgbGV0IGxvY2FsVGFza0RlZnM6IGFueVtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXI7XG4gICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGAke3RoaXMubWFuaWZlc3QuZGlyfS90YXNrX2RlZmluaXRpb25zLmpzb25gO1xuICAgICAgICAgICAgaWYgKCEoYXdhaXQgYWRhcHRlci5leGlzdHMoZmlsZVBhdGgpKSkge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJUYXNrIHN5bmMgZmFpbGVkOiB0YXNrX2RlZmluaXRpb25zLmpzb24gbm90IGZvdW5kLlwiLCAxMDAwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxUYXNrRGVmcyA9IEpTT04ucGFyc2UoYXdhaXQgYWRhcHRlci5yZWFkKGZpbGVQYXRoKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiVGFzayBzeW5jIGZhaWxlZDogQ291bGQgbm90IHJlYWQgdGFza19kZWZpbml0aW9ucy5qc29uLiBDaGVjayBjb25zb2xlLlwiLCAxMDAwMCk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUHJvY2Vzc29yUHJvY2Vzc29yOiBGYWlsZWQgdG8gbG9hZCBsb2NhbCB0YXNrIGRlZmluaXRpb25zOlwiLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgY29uc3Qgc2VydmVyVGFza3NBcnJheSA9IGF3YWl0IHRoaXMubGlzdEFsbFJpZ2h0QnJhaW5UYXNrcyhyYlRva2VuLCBjcmVkcyk7XG4gICAgICAgIGlmIChzZXJ2ZXJUYXNrc0FycmF5ID09PSBudWxsKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiVGFzayBzeW5jIGZhaWxlZDogQ291bGQgbm90IHJldHJpZXZlIHRhc2tzIGZyb20gUmlnaHRCcmFpbi5cIiwgMTAwMDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZlclRhc2tzTWFwID0gbmV3IE1hcChzZXJ2ZXJUYXNrc0FycmF5Lm1hcCgodGFzazogYW55KSA9PiBbdGFzay5uYW1lLCB0YXNrXSkpO1xuICAgIFxuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsRGVmIG9mIGxvY2FsVGFza0RlZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlclRhc2sgPSBzZXJ2ZXJUYXNrc01hcC5nZXQobG9jYWxEZWYubmFtZSk7XG4gICAgXG4gICAgICAgICAgICBjb25zdCBtb2RlbFNldHRpbmdLZXlNYXA6IHsgW2tleTogc3RyaW5nXToga2V5b2YgUHJvY2Vzc29yUHJvY2Vzc29yU2V0dGluZ3MgfSA9IHtcbiAgICAgICAgICAgICAgICAncmlnaHRicmFpblZlcmlmeVVybFRhc2tJZCc6ICd2ZXJpZnlVcmxNb2RlbElkJyxcbiAgICAgICAgICAgICAgICAncmlnaHRicmFpbkV4dHJhY3RFbnRpdGllc1Rhc2tJZCc6ICdleHRyYWN0RW50aXRpZXNNb2RlbElkJyxcbiAgICAgICAgICAgICAgICAncmlnaHRicmFpbkRlZHVwbGljYXRlU3VicHJvY2Vzc29yc1Rhc2tJZCc6ICdkZWR1cGxpY2F0ZVN1YnByb2Nlc3NvcnNNb2RlbElkJyxcbiAgICAgICAgICAgICAgICAncmlnaHRicmFpbkR1Y2tEdWNrR29TZWFyY2hUYXNrSWQnOiAnZHVja0R1Y2tHb1NlYXJjaE1vZGVsSWQnLFxuICAgICAgICAgICAgICAgICdyaWdodGJyYWluRmluZERwYVRhc2tJZCc6ICdmaW5kRHBhTW9kZWxJZCcsXG4gICAgICAgICAgICAgICAgJ3JpZ2h0YnJhaW5GaW5kVG9zVGFza0lkJzogJ2ZpbmRUb3NNb2RlbElkJyxcbiAgICAgICAgICAgICAgICAncmlnaHRicmFpbkZpbmRTZWN1cml0eVRhc2tJZCc6ICdmaW5kU2VjdXJpdHlNb2RlbElkJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsU2V0dGluZ0tleSA9IG1vZGVsU2V0dGluZ0tleU1hcFtsb2NhbERlZi5zZXR0aW5nX2tleV07XG4gICAgICAgICAgICBjb25zdCB1c2VyU2VsZWN0ZWRNb2RlbElkID0gbW9kZWxTZXR0aW5nS2V5ID8gKHRoaXMuc2V0dGluZ3MgYXMgYW55KVttb2RlbFNldHRpbmdLZXldIDogbnVsbDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY2xlYW4gcGF5bG9hZCB3aXRoIG9ubHkgdGhlIHByb3BlcnRpZXMgbmVlZGVkIGZvciBhIHJldmlzaW9uLlxuICAgICAgICAgICAgY29uc3QgbmV3UmV2aXNpb25QYXlsb2FkOiBhbnkgPSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtX3Byb21wdDogbG9jYWxEZWYuc3lzdGVtX3Byb21wdCxcbiAgICAgICAgICAgICAgICB1c2VyX3Byb21wdDogbG9jYWxEZWYudXNlcl9wcm9tcHQsXG4gICAgICAgICAgICAgICAgb3V0cHV0X2Zvcm1hdDogbG9jYWxEZWYub3V0cHV0X2Zvcm1hdCxcbiAgICAgICAgICAgICAgICBpbnB1dF9wcm9jZXNzb3JzOiBsb2NhbERlZi5pbnB1dF9wcm9jZXNzb3JzIHx8IFtdLFxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGxvY2FsRGVmLmVuYWJsZWQsXG4gICAgICAgICAgICAgICAgbGxtX21vZGVsX2lkOiB1c2VyU2VsZWN0ZWRNb2RlbElkIHx8IGxvY2FsRGVmLmxsbV9tb2RlbF9pZFxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIGlmICghc2VydmVyVGFzaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coYFRhc2sgJyR7bG9jYWxEZWYubmFtZX0nIG5vdCBmb3VuZCBvbiBzZXJ2ZXIuIENyZWF0aW5nLi4uYCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JlYXRlVGFza1BheWxvYWQgPSB7IC4uLm5ld1JldmlzaW9uUGF5bG9hZCwgbmFtZTogbG9jYWxEZWYubmFtZSwgZGVzY3JpcHRpb246IGxvY2FsRGVmLmRlc2NyaXB0aW9uIH07XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVSaWdodEJyYWluVGFzayhyYlRva2VuLCBjcmVhdGVUYXNrUGF5bG9hZCwgY3JlZHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXRlc3RSZXZpc2lvbiA9IHNlcnZlclRhc2sudGFza19yZXZpc2lvbnM/LnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiBuZXcgRGF0ZShiLmNyZWF0ZWRfYXQpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEuY3JlYXRlZF9hdCkuZ2V0VGltZSgpKVswXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBuZWVkc1VwZGF0ZSA9ICFsYXRlc3RSZXZpc2lvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZXN0UmV2aXNpb24uc3lzdGVtX3Byb21wdCAhPT0gbmV3UmV2aXNpb25QYXlsb2FkLnN5c3RlbV9wcm9tcHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhdGVzdFJldmlzaW9uLnVzZXJfcHJvbXB0ICE9PSBuZXdSZXZpc2lvblBheWxvYWQudXNlcl9wcm9tcHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhdGVzdFJldmlzaW9uLmxsbV9tb2RlbF9pZCAhPT0gbmV3UmV2aXNpb25QYXlsb2FkLmxsbV9tb2RlbF9pZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobGF0ZXN0UmV2aXNpb24ub3V0cHV0X2Zvcm1hdCkgIT09IEpTT04uc3RyaW5naWZ5KG5ld1JldmlzaW9uUGF5bG9hZC5vdXRwdXRfZm9ybWF0KTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgVGFzayAnJHtsb2NhbERlZi5uYW1lfScgaGFzIHVwZGF0ZXMuIENyZWF0aW5nIG5ldyByZXZpc2lvbi4uLmApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZVJpZ2h0QnJhaW5UYXNrKHJiVG9rZW4sIHNlcnZlclRhc2suaWQsIG5ld1JldmlzaW9uUGF5bG9hZCwgbG9jYWxEZWYubmFtZSwgY3JlZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICBjb25zdCBmaW5hbFNlcnZlclRhc2tzID0gYXdhaXQgdGhpcy5saXN0QWxsUmlnaHRCcmFpblRhc2tzKHJiVG9rZW4sIGNyZWRzKTtcbiAgICAgICAgaWYgKGZpbmFsU2VydmVyVGFza3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJUYXNrIHN5bmMgZmFpbGVkOiBDb3VsZCBub3QgZmV0Y2ggZmluYWwgdGFzayBsaXN0IHRvIHNhdmUgSURzLlwiLCAxMDAwMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmluYWxUYXNrTWFwID0gbmV3IE1hcChmaW5hbFNlcnZlclRhc2tzLm1hcCgodGFzazogYW55KSA9PiBbdGFzay5uYW1lLCB0YXNrLmlkXSkpO1xuICAgIFxuICAgICAgICBsZXQgdGFza3NQb3B1bGF0ZWQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGxvY2FsRGVmIG9mIGxvY2FsVGFza0RlZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdLZXkgPSBsb2NhbERlZi5zZXR0aW5nX2tleSBhcyBrZXlvZiBQcm9jZXNzb3JQcm9jZXNzb3JTZXR0aW5ncztcbiAgICAgICAgICAgIGlmIChzZXR0aW5nS2V5ICYmIGZpbmFsVGFza01hcC5oYXMobG9jYWxEZWYubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAodGhpcy5zZXR0aW5ncyBhcyBhbnkpW3NldHRpbmdLZXldID0gZmluYWxUYXNrTWFwLmdldChsb2NhbERlZi5uYW1lKTtcbiAgICAgICAgICAgICAgICB0YXNrc1BvcHVsYXRlZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgIG5ldyBOb3RpY2UoYFJpZ2h0QnJhaW4gdGFza3Mgc3luY2hyb25pemVkIHN1Y2Nlc3NmdWxseS4gJHt0YXNrc1BvcHVsYXRlZH0gdGFza3MgY29uZmlndXJlZC5gLCAxMDAwMCk7XG4gICAgfVxuXG4gICAgYXN5bmMgc2V0dXBSaWdodEJyYWluVGFza3MoY3JlZHM6IHsgYXBpVXJsOiBzdHJpbmcsIG9hdXRoVXJsOiBzdHJpbmcsIGNsaWVudElkOiBzdHJpbmcsIGNsaWVudFNlY3JldDogc3RyaW5nLCBvcmdJZDogc3RyaW5nLCBwcm9qZWN0SWQ6IHN0cmluZyB9KSB7XG4gICAgICAgIG5ldyBOb3RpY2UoXCJTdGVwIDE6IFZlcmlmeWluZyB0YXNrcyBvbiBSaWdodEJyYWluLi4uXCIsIDQwMDApO1xuXG4gICAgICAgIC8vIEdldCBhdXRoIHRva2VuIGFuZCBsb2FkIGxvY2FsIGRlZmluaXRpb25zIGZyb20gdGhlIEpTT04gZmlsZVxuICAgICAgICBjb25zdCByYlRva2VuID0gYXdhaXQgdGhpcy5nZXRSaWdodEJyYWluQWNjZXNzVG9rZW4oY3JlZHMpO1xuICAgICAgICBpZiAoIXJiVG9rZW4pIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJTZXR1cCBmYWlsZWQ6IENvdWxkIG5vdCBnZXQgUmlnaHRCcmFpbiBBY2Nlc3MgVG9rZW4uXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRhc2tEZWZzOiBhbnlbXTsgLy8gVXNpbmcgJ2FueVtdJyB0byBlYXNpbHkgYWNjZXNzIHRoZSBjdXN0b20gJ3NldHRpbmdfa2V5JyBwcm9wZXJ0eVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXI7XG4gICAgICAgICAgICBjb25zdCBwbHVnaW5EaXIgPSB0aGlzLm1hbmlmZXN0LmRpcjtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gYCR7cGx1Z2luRGlyfS90YXNrX2RlZmluaXRpb25zLmpzb25gO1xuICAgICAgICAgICAgaWYgKCEoYXdhaXQgYWRhcHRlci5leGlzdHMoZmlsZVBhdGgpKSkge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJFcnJvcjogdGFza19kZWZpbml0aW9ucy5qc29uIG5vdCBmb3VuZCBpbiBwbHVnaW4gZm9sZGVyLlwiLCA3MDAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWxlQ29udGVudCA9IGF3YWl0IGFkYXB0ZXIucmVhZChmaWxlUGF0aCk7XG4gICAgICAgICAgICB0YXNrRGVmcyA9IEpTT04ucGFyc2UoZmlsZUNvbnRlbnQpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIkVycm9yIHJlYWRpbmcgb3IgcGFyc2luZyB0YXNrX2RlZmluaXRpb25zLmpzb24uIENoZWNrIGNvbnNvbGUuXCIsIDcwMDApO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlByb2Nlc3NvclByb2Nlc3NvcjogRmFpbGVkIHRvIGxvYWQgdGFzayBkZWZpbml0aW9ucyBmcm9tIGZpbGU6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLSBTdGVwIDE6IEVuc3VyZSBhbGwgdGFza3MgZnJvbSBkZWZpbml0aW9ucyBleGlzdCBvbiB0aGUgc2VydmVyLCBjcmVhdGluZyBhbnkgdGhhdCBhcmUgbWlzc2luZyAtLS1cbiAgICAgICAgY29uc3QgZXhpc3RpbmdUYXNrcyA9IGF3YWl0IHRoaXMubGlzdEFsbFJpZ2h0QnJhaW5UYXNrcyhyYlRva2VuLCBjcmVkcyk7XG4gICAgICAgIGlmIChleGlzdGluZ1Rhc2tzID09PSBudWxsKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiU2V0dXAgZmFpbGVkOiBDb3VsZCBub3QgcmV0cmlldmUgZXhpc3RpbmcgdGFza3MgZnJvbSBSaWdodEJyYWluLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGlzdGluZ1Rhc2tOYW1lcyA9IG5ldyBTZXQoZXhpc3RpbmdUYXNrcy5tYXAoKHRhc2s6IGFueSkgPT4gdGFzay5uYW1lKSk7XG5cbiAgICAgICAgZm9yIChjb25zdCB0YXNrRGVmIG9mIHRhc2tEZWZzKSB7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nVGFza05hbWVzLmhhcyh0YXNrRGVmLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShgQ3JlYXRpbmcgbWlzc2luZyB0YXNrOiAnJHt0YXNrRGVmLm5hbWV9Jy4uLmApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlUmlnaHRCcmFpblRhc2socmJUb2tlbiwgdGFza0RlZiwgY3JlZHMpO1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTsgLy8gUGF1c2UgdG8gcHJldmVudCByYXRlLWxpbWl0aW5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0gU3RlcCAyOiBSZS1mZXRjaCB0aGUgY29tcGxldGUgbGlzdCBvZiB0YXNrcyB0byBnZXQgZGVmaW5pdGl2ZSBJRHMgLS0tXG4gICAgICAgIG5ldyBOb3RpY2UoXCJTdGVwIDI6IEZldGNoaW5nIGFsbCB0YXNrIElEcy4uLlwiLCA0MDAwKTtcbiAgICAgICAgY29uc3QgYWxsU2VydmVyVGFza3MgPSBhd2FpdCB0aGlzLmxpc3RBbGxSaWdodEJyYWluVGFza3MocmJUb2tlbiwgY3JlZHMpO1xuICAgICAgICBpZiAoYWxsU2VydmVyVGFza3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJFcnJvcjogQ291bGQgbm90IGZldGNoIHRoZSBmaW5hbCBsaXN0IG9mIHRhc2tzIHRvIHNhdmUgdGhlaXIgSURzLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLSBTdGVwIDM6IENyZWF0ZSBhIG1hcCBvZiBUYXNrIE5hbWUgLT4gVGFzayBJRCBmb3IgZWFzeSBsb29rdXAgLS0tXG4gICAgICAgIGNvbnN0IHNlcnZlclRhc2tNYXAgPSBuZXcgTWFwKGFsbFNlcnZlclRhc2tzLm1hcCgodGFzazogYW55KSA9PiBbdGFzay5uYW1lLCB0YXNrLmlkXSkpO1xuICAgICAgICBsZXQgdGFza3NQb3B1bGF0ZWQgPSAwO1xuXG4gICAgICAgIC8vIC0tLSBTdGVwIDQ6IExvb3AgdGhyb3VnaCBsb2NhbCBkZWZpbml0aW9ucyBhbmQgcG9wdWxhdGUgc2V0dGluZ3MgdXNpbmcgdGhlIG1hcCAtLS1cbiAgICAgICAgZm9yIChjb25zdCB0YXNrRGVmIG9mIHRhc2tEZWZzKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nS2V5ID0gdGFza0RlZi5zZXR0aW5nX2tleSBhcyBrZXlvZiBQcm9jZXNzb3JQcm9jZXNzb3JTZXR0aW5ncztcbiAgICAgICAgICAgIGlmIChzZXR0aW5nS2V5ICYmIHNlcnZlclRhc2tNYXAuaGFzKHRhc2tEZWYubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXNrSWQgPSBzZXJ2ZXJUYXNrTWFwLmdldCh0YXNrRGVmLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0YXNrSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2V0dGluZ3MgYXMgYW55KVtzZXR0aW5nS2V5XSA9IHRhc2tJZDtcbiAgICAgICAgICAgICAgICAgICAgdGFza3NQb3B1bGF0ZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgYSBtYXRjaGluZyB0YXNrIG9uIHRoZSBzZXJ2ZXIgZm9yIGxvY2FsIGRlZmluaXRpb246IFwiJHt0YXNrRGVmLm5hbWV9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gLS0tIFN0ZXAgNTogU2F2ZSB0aGUgZnVsbHkgcG9wdWxhdGVkIHNldHRpbmdzIG9iamVjdCB0byBkYXRhLmpzb24gLS0tXG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAodGFza3NQb3B1bGF0ZWQgPT09IHRhc2tEZWZzLmxlbmd0aCkge1xuICAgICAgICAgICAgbmV3IE5vdGljZShgU3VjY2VzcyEgQWxsICR7dGFza3NQb3B1bGF0ZWR9IHRhc2sgSURzIGhhdmUgYmVlbiBjb25maWd1cmVkIGFuZCBzYXZlZC5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFNldHVwIGZpbmlzaGVkLCBidXQgb25seSAke3Rhc2tzUG9wdWxhdGVkfSBvZiAke3Rhc2tEZWZzLmxlbmd0aH0gdGFzayBJRHMgY291bGQgYmUgc2F2ZWQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIGxpc3Qgb2YgYWxsIHRhc2tzIGZyb20gdGhlIGNvbmZpZ3VyZWQgUmlnaHRCcmFpbiBwcm9qZWN0LlxuICAgICAqIEBwYXJhbSByYlRva2VuIFRoZSBSaWdodEJyYWluIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0YXNrIG9iamVjdHMgb3IgbnVsbCBpZiBhbiBlcnJvciBvY2N1cnMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBsaXN0QWxsUmlnaHRCcmFpblRhc2tzKHJiVG9rZW46IHN0cmluZywgY3JlZHM6IHsgYXBpVXJsOiBzdHJpbmcsIG9yZ0lkOiBzdHJpbmcsIHByb2plY3RJZDogc3RyaW5nIH0pOiBQcm9taXNlPGFueVtdIHwgbnVsbD4ge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIG5vdyB1c2VzIHRoZSAnY3JlZHMnIG9iamVjdCB0byBidWlsZCB0aGUgVVJMXG4gICAgICAgIGNvbnN0IHRhc2tzVXJsID0gYCR7Y3JlZHMuYXBpVXJsfS9vcmcvJHtjcmVkcy5vcmdJZH0vcHJvamVjdC8ke2NyZWRzLnByb2plY3RJZH0vdGFza2A7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7ICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3JiVG9rZW59YCB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoeyB1cmw6IHRhc2tzVXJsLCBtZXRob2Q6ICdHRVQnLCBoZWFkZXJzOiBoZWFkZXJzLCB0aHJvdzogZmFsc2UgfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbi5yZXN1bHRzIHx8IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGxpc3QgUmlnaHRCcmFpbiB0YXNrczpcIiwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS50ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBSaWdodEJyYWluIHRhc2tzOlwiLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2luZ2xlIG5ldyB0YXNrIGluIFJpZ2h0QnJhaW4gdXNpbmcgYSBwcm92aWRlZCBkZWZpbml0aW9uLlxuICAgICAqIEBwYXJhbSByYlRva2VuIFRoZSBSaWdodEJyYWluIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAcGFyYW0gdGFza0RlZmluaXRpb24gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZ1bGwgY29uZmlndXJhdGlvbiBmb3IgdGhlIG5ldyB0YXNrLlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHRhc2sgb2JqZWN0IG9yIG51bGwgaWYgYW4gZXJyb3Igb2NjdXJzLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgY3JlYXRlUmlnaHRCcmFpblRhc2socmJUb2tlbjogc3RyaW5nLCB0YXNrRGVmaW5pdGlvbjogYW55LCBjcmVkczogeyBhcGlVcmw6IHN0cmluZywgb3JnSWQ6IHN0cmluZywgcHJvamVjdElkOiBzdHJpbmcgfSk6IFByb21pc2U8YW55IHwgbnVsbD4ge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsc28gdXNlcyB0aGUgJ2NyZWRzJyBvYmplY3Qgbm93XG4gICAgICAgIGNvbnN0IGNyZWF0ZVVybCA9IGAke2NyZWRzLmFwaVVybH0vb3JnLyR7Y3JlZHMub3JnSWR9L3Byb2plY3QvJHtjcmVkcy5wcm9qZWN0SWR9L3Rhc2tgO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7cmJUb2tlbn1gLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgICAgICAgICAgICAgIHVybDogY3JlYXRlVXJsLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGFza0RlZmluaXRpb24pLFxuICAgICAgICAgICAgICAgIHRocm93OiBmYWxzZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMSB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYFN1Y2Nlc3NmdWxseSBjcmVhdGVkIHRhc2s6ICcke3Rhc2tEZWZpbml0aW9uLm5hbWV9J2ApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBGYWlsZWQgdG8gY3JlYXRlIHRhc2sgJyR7dGFza0RlZmluaXRpb24ubmFtZX0nOiAke3Jlc3BvbnNlLnN0YXR1c31gLCA3MDAwKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjcmVhdGluZyB0YXNrICcke3Rhc2tEZWZpbml0aW9uLm5hbWV9JzpgLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTmV0d29yayBlcnJvciBjcmVhdGluZyB0YXNrICcke3Rhc2tEZWZpbml0aW9uLm5hbWV9JzpgLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHBlcnNpc3RTdWJwcm9jZXNzb3JJbmZvKHByb2Nlc3Nvck5hbWU6IHN0cmluZywgcHJvY2Vzc29yRmlsZTogVEZpbGUsIHNlYXJjaERhdGE6IFNlYXJjaERhdGEsIGlzVG9wTGV2ZWxQcm9jZXNzb3I6IGJvb2xlYW4gPSB0cnVlLCBtZXJnZURlY2lzaW9uczogc3RyaW5nW10gPSBbXSkge1xuICAgICAgICBuZXcgTm90aWNlKGBQZXJzaXN0aW5nIGluZm8gZm9yOiAke3Byb2Nlc3Nvck5hbWV9Li4uYCk7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRm9sZGVyRXhpc3RzKHRoaXMuc2V0dGluZ3MucHJvY2Vzc29yc0ZvbGRlclBhdGgpO1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUZvbGRlckV4aXN0cyh0aGlzLnNldHRpbmdzLmFuYWx5c2lzTG9nc0ZvbGRlclBhdGgpO1xuXG4gICAgICAgIGNvbnN0IHsgY29sbGVjdGVkUmVsYXRpb25zaGlwcywgcHJvY2Vzc2VkVXJsRGV0YWlscyB9ID0gc2VhcmNoRGF0YTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIG1haW4gcHJvY2Vzc29yIGZpbGUgKGUuZy4sIFwiT3BlbkFJLm1kXCIpXG4gICAgICAgIGF3YWl0IHRoaXMudXBkYXRlUHJvY2Vzc29yRmlsZShwcm9jZXNzb3JGaWxlLCBwcm9jZXNzb3JOYW1lLCBjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzLCBpc1RvcExldmVsUHJvY2Vzc29yKTtcblxuICAgICAgICAvLyBHZXQgdW5pcXVlIHRhcmdldCBlbnRpdHkgbmFtZXMgKHN1YnByb2Nlc3NvcnMgb3Igb3duX2VudGl0aWVzKVxuICAgICAgICBjb25zdCB1bmlxdWVUYXJnZXRFbnRpdHlPcmlnaW5hbE5hbWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KGNvbGxlY3RlZFJlbGF0aW9uc2hpcHMubWFwKHIgPT4gci5TdWJwcm9jZXNzb3JOYW1lKSkpO1xuICAgICAgICBjb25zdCBjcmVhdGVkUGFnZXNGb3JUaGlzUnVuID0gbmV3IFNldDxzdHJpbmc+KCk7IC8vIFRyYWNrIGZpbGUgcGF0aHMgY3JlYXRlZC91cGRhdGVkIGluIHRoaXMgcnVuIHRvIGF2b2lkIHJlZHVuZGFudCBvcHNcblxuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldEVudGl0eU9yaWdpbmFsTmFtZSBvZiB1bmlxdWVUYXJnZXRFbnRpdHlPcmlnaW5hbE5hbWVzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZpbGVQYXRoTmFtZTogdGFyZ2V0RW50aXR5RmlsZVBhdGhOYW1lIH0gPSB0aGlzLnNhbml0aXplTmFtZUZvckZpbGVQYXRoQW5kQWxpYXModGFyZ2V0RW50aXR5T3JpZ2luYWxOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGNyZWF0ZWRQYWdlc0ZvclRoaXNSdW4uaGFzKHRhcmdldEVudGl0eUZpbGVQYXRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBBbHJlYWR5IHByb2Nlc3NlZCBwYWdlIGZvciAke3RhcmdldEVudGl0eUZpbGVQYXRoTmFtZX0gaW4gdGhpcyBydW4sIHNraXBwaW5nLmApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgYWxsIHJlbGF0aW9uc2hpcHMgd2hlcmUgdGhpcyBlbnRpdHkgaXMgdGhlIHRhcmdldCAoU3VicHJvY2Vzc29yTmFtZSlcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0aW9uc1doZXJlVGhpc0VudGl0eUlzVGFyZ2V0ID0gY29sbGVjdGVkUmVsYXRpb25zaGlwcy5maWx0ZXIociA9PiByLlN1YnByb2Nlc3Nvck5hbWUgPT09IHRhcmdldEVudGl0eU9yaWdpbmFsTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChyZWxhdGlvbnNXaGVyZVRoaXNFbnRpdHlJc1RhcmdldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBObyByZWxhdGlvbnNoaXBzIGZvdW5kIGZvciB0YXJnZXQgJHt0YXJnZXRFbnRpdHlPcmlnaW5hbE5hbWV9LCBza2lwcGluZyBwYWdlIGNyZWF0aW9uLmApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTaG91bGQgbm90IGhhcHBlbiBpZiBpdCdzIGluIHVuaXF1ZVRhcmdldEVudGl0eU9yaWdpbmFsTmFtZXMgZnJvbSBjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBpZiB0aGlzIGVudGl0eSBpcyBldmVyIHVzZWQgYXMgYSBzdWJwcm9jZXNzb3IgYnkgKmFueSogcHJpbWFyeSBwcm9jZXNzb3IgaW4gdGhlIGN1cnJlbnQgYmF0Y2hcbiAgICAgICAgICAgIGNvbnN0IGlzRXZlclVzZWRBc1N1YnByb2Nlc3NvciA9IHJlbGF0aW9uc1doZXJlVGhpc0VudGl0eUlzVGFyZ2V0LnNvbWUociA9PiByLlJlbGF0aW9uc2hpcFR5cGUgPT09ICd1c2VzX3N1YnByb2Nlc3NvcicpO1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhpcyBlbnRpdHkgaXMgYW4gXCJvd25fZW50aXR5XCIgb2YgdGhlICpjdXJyZW50KiBwcmltYXJ5IHByb2Nlc3NvciBiZWluZyBwcm9jZXNzZWQgKHByb2Nlc3Nvck5hbWUpXG4gICAgICAgICAgICBjb25zdCBpc093bkVudGl0eU9mQ3VycmVudFByaW1hcnlQcm9jZXNzb3IgPSByZWxhdGlvbnNXaGVyZVRoaXNFbnRpdHlJc1RhcmdldC5zb21lKFxuICAgICAgICAgICAgICAgIHIgPT4gci5QcmltYXJ5UHJvY2Vzc29yID09PSBwcm9jZXNzb3JOYW1lICYmIHIuUmVsYXRpb25zaGlwVHlwZSA9PT0gJ2lzX293bl9lbnRpdHknXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBsZXQgc2hvdWxkQ3JlYXRlUGFnZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGlzRXZlclVzZWRBc1N1YnByb2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIHNob3VsZENyZWF0ZVBhZ2UgPSB0cnVlOyAvLyBBbHdheXMgY3JlYXRlL3VwZGF0ZSBwYWdlIGlmIGl0J3MgYSBzdWJwcm9jZXNzb3JcbiAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBQYWdlIGZvciAnJHt0YXJnZXRFbnRpdHlPcmlnaW5hbE5hbWV9JyB3aWxsIGJlIGNyZWF0ZWQvdXBkYXRlZCBiZWNhdXNlIGl0J3MgdXNlZCBhcyBhIHN1YnByb2Nlc3Nvci5gKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPd25FbnRpdHlPZkN1cnJlbnRQcmltYXJ5UHJvY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhbiBvd25fZW50aXR5IG9mIHRoZSBjdXJyZW50IHByb2Nlc3NvciwgY3JlYXRlIHBhZ2Ugb25seSBpZiBzZXR0aW5nIGlzIGVuYWJsZWRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jcmVhdGVQYWdlc0Zvck93bkVudGl0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZENyZWF0ZVBhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBQYWdlIGZvciBvd25fZW50aXR5ICcke3RhcmdldEVudGl0eU9yaWdpbmFsTmFtZX0nIChvZiAnJHtwcm9jZXNzb3JOYW1lfScpIHdpbGwgYmUgY3JlYXRlZC91cGRhdGVkIGR1ZSB0byBzZXR0aW5nLmApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coYFNraXBwaW5nIHBhZ2UgY3JlYXRpb24gZm9yIG93bl9lbnRpdHkgJyR7dGFyZ2V0RW50aXR5T3JpZ2luYWxOYW1lfScgKG9mICcke3Byb2Nlc3Nvck5hbWV9JykgZHVlIHRvIHNldHRpbmcuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGlmIChzaG91bGRDcmVhdGVQYWdlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBjcmVhdGluZy91cGRhdGluZyBhIHN1YnByb2Nlc3NvcidzIHBhZ2UgKGUuZy4sIFwiQVdTLm1kXCIpLFxuICAgICAgICAgICAgICAgIC8vIHdlIGxpc3QgYWxsIHByaW1hcnkgcHJvY2Vzc29ycyB0aGF0IHVzZSBpdCBhcyBhIHN1YnByb2Nlc3Nvci5cbiAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRSZWxhdGlvbnNoaXBzRm9yVGFyZ2V0RW50aXR5UGFnZSA9IGNvbGxlY3RlZFJlbGF0aW9uc2hpcHMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICByID0+IHIuU3VicHJvY2Vzc29yTmFtZSA9PT0gdGFyZ2V0RW50aXR5T3JpZ2luYWxOYW1lICYmIHIuUmVsYXRpb25zaGlwVHlwZSA9PT0gJ3VzZXNfc3VicHJvY2Vzc29yJ1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZU9yVXBkYXRlU3VicHJvY2Vzc29yRmlsZShcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RW50aXR5T3JpZ2luYWxOYW1lLCAgICAgICAgLy8gVGhlIG5hbWUgb2YgdGhlIHN1YnByb2Nlc3Nvci9vd25fZW50aXR5IGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzb3JOYW1lLCAgICAgICAgICAgICAgICAgICAvLyBUaGUgcHJpbWFyeSBwcm9jZXNzb3IgY29udGV4dCAoZm9yIGxvZ2dpbmcvdHJhY2tpbmcsIG5vdCBmb3IgY29udGVudCBvZiBzdWJwcm9jZXNzb3IncyBwYWdlIGRpcmVjdGx5KVxuICAgICAgICAgICAgICAgICAgICBjbGllbnRSZWxhdGlvbnNoaXBzRm9yVGFyZ2V0RW50aXR5UGFnZSAvLyBSZWxhdGlvbnNoaXBzIHdoZXJlIHRoaXMgZW50aXR5IGlzIHRoZSBzdWJwcm9jZXNzb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNyZWF0ZWRQYWdlc0ZvclRoaXNSdW4uYWRkKHRhcmdldEVudGl0eUZpbGVQYXRoTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGFuYWx5c2lzIGxvZyBmb3IgdGhlIHByaW1hcnkgcHJvY2Vzc29yXG4gICAgICAgIGF3YWl0IHRoaXMudXBkYXRlQW5hbHlzaXNMb2dQYWdlKHByb2Nlc3Nvck5hbWUsIHByb2Nlc3NlZFVybERldGFpbHMsIGNvbGxlY3RlZFJlbGF0aW9uc2hpcHMsIG1lcmdlRGVjaXNpb25zKTtcbiAgICAgICAgbmV3IE5vdGljZShgRmluaXNoZWQgcGVyc2lzdGluZyBpbmZvIGZvciAke3Byb2Nlc3Nvck5hbWV9LmApO1xuICAgIH1cblxuICAgIGFzeW5jIHNlYXJjaFZpYVJpZ2h0QnJhaW5EdWNrRHVja0dvKHByb2Nlc3Nvck5hbWU6IHN0cmluZywgcmJUb2tlbjogc3RyaW5nKTogUHJvbWlzZTxTZXJwQXBpUmVzdWx0W10+IHtcbiAgICAgICAgLy8gVGhlIGxvZ2ljIHRvIGNyZWF0ZSB0aGUgdGFzayBvbiB0aGUgZmx5IGhhcyBiZWVuIHJlbW92ZWQuXG4gICAgICAgIC8vIFdlIG5vdyBqdXN0IGNoZWNrIGlmIHRoZSBzZXR0aW5nIGlzIHByZXNlbnQuXG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluRHVja0R1Y2tHb1NlYXJjaFRhc2tJZCkge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIkR1Y2tEdWNrR28gU2VhcmNoIFRhc2sgSUQgaXMgbm90IGNvbmZpZ3VyZWQuIFBsZWFzZSBydW4gdGhlIHNldHVwIGNvbW1hbmQgb3IgY29uZmlndXJlIGl0IGluIHNldHRpbmdzLlwiLCAxMDAwMCk7XG4gICAgICAgICAgICByZXR1cm4gW107IC8vIEZhaWwgZ3JhY2VmdWxseSBpZiB0aGUgdGFzayBJRCBpcyBub3Qgc2V0XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgY29uc3Qgc2VhcmNoVGFza0lkID0gdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluRHVja0R1Y2tHb1NlYXJjaFRhc2tJZDtcbiAgICBcbiAgICAgICAgY29uc3Qgc2VhcmNoUXVlcmllcyA9IHRoaXMuZ2VuZXJhdGVTZWFyY2hRdWVyaWVzKHByb2Nlc3Nvck5hbWUpO1xuICAgICAgICBjb25zdCBhbGxSZXN1bHRzOiBTZXJwQXBpUmVzdWx0W10gPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcmllc1RvUHJvY2VzcyA9IHNlYXJjaFF1ZXJpZXMuc2xpY2UoMCwgTWF0aC5taW4oc2VhcmNoUXVlcmllcy5sZW5ndGgsIDIpKTtcbiAgICBcbiAgICAgICAgbmV3IE5vdGljZShgUGVyZm9ybWluZyB1cCB0byAke3F1ZXJpZXNUb1Byb2Nlc3MubGVuZ3RofSBEdWNrRHVja0dvIHNlYXJjaGVzIGZvciAke3Byb2Nlc3Nvck5hbWV9Li4uYCwgNTAwMCk7XG4gICAgXG4gICAgICAgIGZvciAoY29uc3QgcXVlcnkgb2YgcXVlcmllc1RvUHJvY2Vzcykge1xuICAgICAgICAgICAgY29uc3QgZHVja0R1Y2tHb1VybCA9IGBodHRwczovL2R1Y2tkdWNrZ28uY29tLz9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX0maWE9d2ViJmtsPXVzLWVuJmtwPS0yYDtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IHRhc2tJbnB1dFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoX3VybF90b19wcm9jZXNzOiBkdWNrRHVja0dvVXJsLFxuICAgICAgICAgICAgICAgIHRhcmdldF9jb21wYW55X25hbWU6IHByb2Nlc3Nvck5hbWVcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQ2FsbGluZyBSaWdodEJyYWluIFRhc2sgJHtzZWFyY2hUYXNrSWR9IGZvciBEREcgc2VhcmNoLiBVUkw6ICR7ZHVja0R1Y2tHb1VybH0sIFRhcmdldDogJHtwcm9jZXNzb3JOYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgY29uc3QgdGFza1J1blJlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbFJpZ2h0QnJhaW5UYXNrKHNlYXJjaFRhc2tJZCwgdGFza0lucHV0UGF5bG9hZCwgcmJUb2tlbik7XG4gICAgXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcgJiYgdGFza1J1blJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGdWxsIFJpZ2h0QnJhaW4gUmVzcG9uc2UgZm9yIERERyBzZWFyY2ggcXVlcnkgXCIke3F1ZXJ5fVwiOmAsIEpTT04uc3RyaW5naWZ5KHRhc2tSdW5SZXN1bHQsIG51bGwsIDIpKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGlmICh0YXNrUnVuUmVzdWx0Py5yZXNwb25zZT8uc2VhcmNoX3Jlc3VsdHMgJiYgQXJyYXkuaXNBcnJheSh0YXNrUnVuUmVzdWx0LnJlc3BvbnNlLnNlYXJjaF9yZXN1bHRzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHNMaXN0OiBhbnlbXSA9IHRhc2tSdW5SZXN1bHQucmVzcG9uc2Uuc2VhcmNoX3Jlc3VsdHM7XG4gICAgXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0c0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC51cmwgJiYgcmVzdWx0LnRpdGxlICYmIChTdHJpbmcocmVzdWx0LnVybCkuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgU3RyaW5nKHJlc3VsdC51cmwpLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbFJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc29yTmFtZTogcHJvY2Vzc29yTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hRdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFN0cmluZyhyZXN1bHQudGl0bGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogU3RyaW5nKHJlc3VsdC51cmwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNuaXBwZXQ6IFN0cmluZyhyZXN1bHQuc25pcHBldCB8fCAnJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRUeXBlOiAnZHVja2R1Y2tnb19yYl9zZWFyY2hfcmVzdWx0J1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgcHJvY2Vzc2VkICR7cmVzdWx0c0xpc3QubGVuZ3RofSBzZWFyY2ggcmVzdWx0cyBmb3IgcXVlcnkgXCIke3F1ZXJ5fVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBEREcgc2VhcmNoIHZpYSBSQiBmb3IgXCIke3F1ZXJ5LnN1YnN0cmluZygwLCAyMCl9Li4uXCIgeWllbGRlZCBubyB2YWxpZCByZXN1bHRzLmAsIDMwMDApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFJCIFRhc2sgZm9yIERERyBTZWFyY2ggZm9yIHF1ZXJ5IFwiJHtxdWVyeX1cIiBkaWQgbm90IHJldHVybiBleHBlY3RlZCAneyBcInNlYXJjaF9yZXN1bHRzXCI6IFsuLi5dIH0nIGFycmF5IG9yIGZhaWxlZC4gRnVsbCB0YXNrUnVuUmVzdWx0OmAsIHRhc2tSdW5SZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA3MDAgKyBNYXRoLnJhbmRvbSgpICogNTAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgc2VhcmNoVmlhUmlnaHRCcmFpbkR1Y2tEdWNrR28gY29sbGVjdGVkICR7YWxsUmVzdWx0cy5sZW5ndGh9IGZpbHRlcmVkIGNhbmRpZGF0ZXMgZm9yICR7cHJvY2Vzc29yTmFtZX1gKTtcbiAgICAgICAgcmV0dXJuIGFsbFJlc3VsdHM7XG4gICAgfVxuXG5cbiAgICBhc3luYyBmZXRjaFByb2Nlc3NvclNlYXJjaERhdGFXaXRoRGlzY292ZXJ5KHByb2Nlc3Nvck5hbWU6IHN0cmluZyk6IFByb21pc2U8U2VhcmNoRGF0YSB8IG51bGw+IHtcbiAgICAgICAgY29uc3QgY29sbGVjdGVkUmVsYXRpb25zaGlwczogRXh0cmFjdGVkUmVsYXRpb25zaGlwW10gPSBbXTtcbiAgICAgICAgY29uc3Qgc2VlblJlbGF0aW9uc2hpcHNJbkN1cnJlbnRTZWFyY2ggPSBuZXcgU2V0PHN0cmluZz4oKTsgLy8gVHJhY2tzIChQcmltYXJ5LCBTdWIsIFR5cGUpXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZFVybERldGFpbHM6IFByb2Nlc3NlZFVybEluZm9bXSA9IFtdOyAvLyBMb2cgb2YgYWxsIFVSTHMgcHJvY2Vzc2VkXG4gICAgICAgIGxldCBjYW5kaWRhdGVVcmxzSW5mbzogU2VycEFwaVJlc3VsdFtdID0gW107XG4gICAgICAgIGxldCBmbGFnZ2VkQ2FuZGlkYXRlVXJsQ291bnQgPSAwO1xuXG4gICAgICAgIGNvbnN0IHJiVG9rZW4gPSBhd2FpdCB0aGlzLmdldFJpZ2h0QnJhaW5BY2Nlc3NUb2tlbigpO1xuICAgICAgICBpZiAoIXJiVG9rZW4pIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJDb3VsZCBub3QgZ2V0IFJpZ2h0QnJhaW4gQWNjZXNzIFRva2VuLiBBYm9ydGluZyBkaXNjb3ZlcnkuXCIsIDcwMDApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGVwIDE6IEluaXRpYWwgU2VhcmNoIChTZXJwQVBJIG9yIFJpZ2h0QnJhaW4vRERHKVxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zZXJwQXBpS2V5KSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBVc2luZyBTZXJwQVBJIGZvciBwcmltYXJ5IHNlYXJjaCBmb3I6ICR7cHJvY2Vzc29yTmFtZX1gLCA1MDAwKTtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFF1ZXJpZXMgPSB0aGlzLmdlbmVyYXRlU2VhcmNoUXVlcmllcyhwcm9jZXNzb3JOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHNlcnBBcGlSZXN1bHRzID0gYXdhaXQgdGhpcy5zZWFyY2hTZXJwQXBpRm9yRHBhcyhwcm9jZXNzb3JOYW1lLCBzZWFyY2hRdWVyaWVzLCB0aGlzLnNldHRpbmdzLm1heFJlc3VsdHNQZXJQcm9jZXNzb3IpO1xuICAgICAgICAgICAgY2FuZGlkYXRlVXJsc0luZm8ucHVzaCguLi5zZXJwQXBpUmVzdWx0cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5yaWdodGJyYWluT3JnSWQgJiYgdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluUHJvamVjdElkKSB7IC8vIENoZWNrIGlmIFJpZ2h0QnJhaW4gaXMgY29uZmlndXJlZCBmb3IgRERHXG4gICAgICAgICAgICBuZXcgTm90aWNlKGBTZXJwQVBJIGtleSBub3QgY29uZmlndXJlZC4gVXNpbmcgRHVja0R1Y2tHbyAoRmlsdGVyZWQgRXh0cmFjdG9yIFRhc2spIHZpYSBSaWdodEJyYWluIGZvcjogJHtwcm9jZXNzb3JOYW1lfWAsIDUwMDApO1xuICAgICAgICAgICAgLy8gVGhpcyBjYWxsIG5vdyB1c2VzIHRoZSBSQiBUYXNrIHRoYXQgZmlsdGVycyBhbmQgcGFyc2VzIERERyByZXN1bHRzXG4gICAgICAgICAgICBjYW5kaWRhdGVVcmxzSW5mbyA9IGF3YWl0IHRoaXMuc2VhcmNoVmlhUmlnaHRCcmFpbkR1Y2tEdWNrR28ocHJvY2Vzc29yTmFtZSwgcmJUb2tlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiTm8gc2VhcmNoIG1ldGhvZCBjb25maWd1cmVkIChTZXJwQVBJIG9yIFJpZ2h0QnJhaW4gZm9yIERERykuIEFib3J0aW5nIGRpc2NvdmVyeS5cIiwgNzAwMCk7XG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIHJldHVybiBudWxsIGltbWVkaWF0ZWx5LCBhcyBoYXJkY29kZWQgVVJMcyBtaWdodCBzdGlsbCBiZSBwcm9jZXNzZWQgaWYgdmVyYm9zZURlYnVnIGlzIG9uLlxuICAgICAgICB9XG5cblxuICAgICAgICAvLyBIYXJkY29kZWQgVVJMcyBmb3IgdGVzdGluZyAoaWYgZW5hYmxlZClcbiAgICAgICAgY29uc3QgaGFyZGNvZGVkVGVzdFVybHM6IFJlY29yZDxzdHJpbmcsIFNlcnBBcGlSZXN1bHRbXT4gPSB7XG4gICAgICAgICAgICAvLyBcIm9wZW5haVwiOiBbeyB0aXRsZTogXCJUZXN0IE9wZW5BSSBTdWJQIExpc3RcIiwgdXJsOiBcImh0dHBzOi8vZXhhbXBsZS5jb20vb3BlbmFpLXN1YnBcIiwgc25pcHBldDogXCJcIiwgcHJvY2Vzc29yTmFtZTogXCJvcGVuYWlcIiwgZG9jdW1lbnRUeXBlOiBcImhhcmRjb2RlZF90ZXN0XCIgfV0sXG4gICAgICAgIH07IC8vIEtlZXAgdGhpcyBlbXB0eSBvciBtYW5hZ2UgaXQgY2FyZWZ1bGx5XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZyAmJiBoYXJkY29kZWRUZXN0VXJsc1twcm9jZXNzb3JOYW1lLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBBZGRpbmcgaGFyZGNvZGVkIHRlc3QgVVJMcyBmb3IgJHtwcm9jZXNzb3JOYW1lfWApO1xuICAgICAgICAgICAgY2FuZGlkYXRlVXJsc0luZm8ucHVzaCguLi5oYXJkY29kZWRUZXN0VXJsc1twcm9jZXNzb3JOYW1lLnRvTG93ZXJDYXNlKCldKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCAyOiAoT3B0aW9uYWwpIEV4dHJhY3QgbW9yZSBVUkxzIGZyb20gYWxyZWFkeSBpZGVudGlmaWVkIERQQS9TdWJwcm9jZXNzb3IgbGlzdCBwYWdlc1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsVXJsc0Zyb21DYW5kaWRhdGVQYWdlczogU2VycEFwaVJlc3VsdFtdID0gW107XG4gICAgICAgIGNvbnN0IHBhZ2VzVG9TY2FuRm9yTW9yZUxpbmtzID0gY2FuZGlkYXRlVXJsc0luZm8uZmlsdGVyKFxuICAgICAgICAgICAgaXRlbSA9PiBpdGVtLmRvY3VtZW50VHlwZSA9PT0gJ2RwYV9vcl9zdWJwcm9jZXNzb3JfbGlzdCcgfHwgU1VCUFJPQ0VTU09SX1VSTF9LRVlXT1JEUy5zb21lKGt3ID0+IGl0ZW0udXJsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoa3cpKVxuICAgICAgICApO1xuXG4gICAgICAgIGZvciAoY29uc3QgcGFnZUl0ZW0gb2YgcGFnZXNUb1NjYW5Gb3JNb3JlTGlua3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IGF3YWl0IHRoaXMuZXh0cmFjdFVybHNGcm9tRHBhUGFnZShwYWdlSXRlbS51cmwsIHByb2Nlc3Nvck5hbWUsIHBhZ2VJdGVtLnRpdGxlKTtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxVcmxzRnJvbUNhbmRpZGF0ZVBhZ2VzLnB1c2goLi4uZXh0cmFjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBjYW5kaWRhdGVVcmxzSW5mby5wdXNoKC4uLmFkZGl0aW9uYWxVcmxzRnJvbUNhbmRpZGF0ZVBhZ2VzKTtcblxuXG4gICAgICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBsaXN0IG9mIFVSTHMgdG8gcHJvY2VzcywgcHJpb3JpdGl6aW5nIGVhcmxpZXIgZm91bmQgb25lcy5cbiAgICAgICAgY29uc3QgdW5pcXVlQ2FuZGlkYXRlVXJscyA9IG5ldyBNYXA8c3RyaW5nLCBTZXJwQXBpUmVzdWx0PigpO1xuICAgICAgICBjYW5kaWRhdGVVcmxzSW5mby5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0udXJsICYmIChpdGVtLnVybC5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCBpdGVtLnVybC5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikpICYmICF1bmlxdWVDYW5kaWRhdGVVcmxzLmhhcyhpdGVtLnVybC5yZXBsYWNlKC9cXC8kLywgJycpKSkgeyAvLyBOb3JtYWxpemUgVVJMIGJ5IHJlbW92aW5nIHRyYWlsaW5nIHNsYXNoXG4gICAgICAgICAgICAgICAgdW5pcXVlQ2FuZGlkYXRlVXJscy5zZXQoaXRlbS51cmwucmVwbGFjZSgvXFwvJC8sICcnKSwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB1bmlxdWVVcmxzVG9Qcm9jZXNzID0gQXJyYXkuZnJvbSh1bmlxdWVDYW5kaWRhdGVVcmxzLnZhbHVlcygpKTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBUb3RhbCB1bmlxdWUgVVJMcyB0byB2ZXJpZnkgZm9yICR7cHJvY2Vzc29yTmFtZX06ICR7dW5pcXVlVXJsc1RvUHJvY2Vzcy5sZW5ndGh9YCk7XG5cbiAgICAgICAgaWYgKHVuaXF1ZVVybHNUb1Byb2Nlc3MubGVuZ3RoID09PSAwICYmIGNhbmRpZGF0ZVVybHNJbmZvLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUud2FybihgQWxsIGNhbmRpZGF0ZSBVUkxzIHdlcmUgaW52YWxpZCBvciBkdXBsaWNhdGVzIGZvciAke3Byb2Nlc3Nvck5hbWV9LiBPcmlnaW5hbCBjb3VudDogJHtjYW5kaWRhdGVVcmxzSW5mby5sZW5ndGh9YCk7XG4gICAgICAgIH0gZWxzZSBpZiAodW5pcXVlVXJsc1RvUHJvY2Vzcy5sZW5ndGggPT09IDApIHsgXG4gICAgICAgICAgICBuZXcgTm90aWNlKGBObyBjYW5kaWRhdGUgVVJMcyBmb3VuZCB0byBwcm9jZXNzIGZvciAke3Byb2Nlc3Nvck5hbWV9LmApO1xuICAgICAgICAgICAgLy8gTm8gVVJMcyB0byBwcm9jZXNzLCBzbyByZXR1cm4gY3VycmVudCBzdGF0ZSAobGlrZWx5IGVtcHR5IHJlbGF0aW9uc2hpcHMpXG4gICAgICAgICAgICAvLyByZXR1cm4geyBjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzLCBwcm9jZXNzZWRVcmxEZXRhaWxzLCBmbGFnZ2VkQ2FuZGlkYXRlVXJsQ291bnQgfTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gU3RlcCAzOiBWZXJpZnkgZWFjaCB1bmlxdWUgVVJMIGFuZCBleHRyYWN0IGVudGl0aWVzIGlmIGl0J3MgYSB2YWxpZCwgY3VycmVudCBsaXN0XG4gICAgICAgIGZvciAoY29uc3QgdXJsSW5mbyBvZiB1bmlxdWVVcmxzVG9Qcm9jZXNzKSB7XG5cbiAgICAgICAgICAgIC8vIEF2b2lkIHJlLXByb2Nlc3NpbmcgaWYgdGhpcyBleGFjdCBVUkwgd2FzIHNvbWVob3cgYWRkZWQgdG8gcHJvY2Vzc2VkVXJsRGV0YWlscyBhbHJlYWR5XG4gICAgICAgICAgICBpZiAocHJvY2Vzc2VkVXJsRGV0YWlscy5zb21lKHAgPT4gcC51cmwucmVwbGFjZSgvXFwvJC8sICcnKSA9PT0gdXJsSW5mby51cmwucmVwbGFjZSgvXFwvJC8sICcnKSkpIHtcbiAgICAgICAgICAgICAgICAgaWYodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBVUkwgJHt1cmxJbmZvLnVybH0gYWxyZWFkeSBwcm9jZXNzZWQgaW4gcHJvY2Vzc2VkVXJsRGV0YWlscywgc2tpcHBpbmcgcmUtdmVyaWZpY2F0aW9uLmApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY3VycmVudFVybEV4dHJhY3RlZENvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCBjdXJyZW50UHJvY2Vzc2VkVXJsSW5mbzogUHJvY2Vzc2VkVXJsSW5mbyA9IHsgLi4udXJsSW5mbywgZG9jdW1lbnRUeXBlOiB1cmxJbmZvLmRvY3VtZW50VHlwZSB8fCAnZHVja2R1Y2tnb19yYl9zZWFyY2hfcmVzdWx0JyB9OyBcblxuICAgICAgICAgICAgY29uc3QgdmVyaWZpY2F0aW9uUmVzdWx0ID0gYXdhaXQgdGhpcy52ZXJpZnlTdWJwcm9jZXNzb3JMaXN0VXJsKHVybEluZm8udXJsLCBwcm9jZXNzb3JOYW1lLCByYlRva2VuKTtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvID0geyBcbiAgICAgICAgICAgICAgICAuLi5jdXJyZW50UHJvY2Vzc2VkVXJsSW5mbyxcbiAgICAgICAgICAgICAgICB2ZXJpZmljYXRpb25NZXRob2Q6ICdyaWdodGJyYWluJyxcbiAgICAgICAgICAgICAgICBpc0xpc3Q6IHZlcmlmaWNhdGlvblJlc3VsdD8uaXNMaXN0IHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzQ3VycmVudDogdmVyaWZpY2F0aW9uUmVzdWx0Py5pc0N1cnJlbnQgfHwgZmFsc2UsIFxuICAgICAgICAgICAgICAgIHZlcmlmaWNhdGlvblJlYXNvbmluZzogdmVyaWZpY2F0aW9uUmVzdWx0Py5yZWFzb25pbmcgfHwgJ04vQSdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIC0tLS0gVEhJUyBJUyBUSEUgS0VZIExPR0lDIENIQU5HRSAtLS0tXG4gICAgICAgICAgICBpZiAodmVyaWZpY2F0aW9uUmVzdWx0Py5pc0xpc3QgJiYgdmVyaWZpY2F0aW9uUmVzdWx0LmlzQ3VycmVudCAmJiB2ZXJpZmljYXRpb25SZXN1bHQuaXNDb3JyZWN0UHJvY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3VycmVudFByb2Nlc3NlZFVybEluZm8uZG9jdW1lbnRUeXBlID0gJ3ZlcmlmaWVkX2N1cnJlbnRfc3VicHJvY2Vzc29yX2xpc3QnO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJpZmljYXRpb25SZXN1bHQucGFnZUNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0cmFjdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMuZXh0cmFjdEVudGl0aWVzRnJvbVBhZ2VDb250ZW50KHZlcmlmaWNhdGlvblJlc3VsdC5wYWdlQ29udGVudCwgcmJUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYWN0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRoaXJkUGFydHlTdWJwcm9jZXNzb3JzLCBvd25FbnRpdGllcyB9ID0gZXh0cmFjdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXJkUGFydHlTdWJwcm9jZXNzb3JzLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFVybEV4dHJhY3RlZENvdW50ICs9IHRoaXMuYWRkUmVsYXRpb25zaGlwKGNvbGxlY3RlZFJlbGF0aW9uc2hpcHMsIHNlZW5SZWxhdGlvbnNoaXBzSW5DdXJyZW50U2VhcmNoLCBwcm9jZXNzb3JOYW1lLCBlLCBcInVzZXNfc3VicHJvY2Vzc29yXCIsIHVybEluZm8udXJsLCB2ZXJpZmljYXRpb25SZXN1bHQucmVhc29uaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3duRW50aXRpZXMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXJsRXh0cmFjdGVkQ291bnQgKz0gdGhpcy5hZGRSZWxhdGlvbnNoaXAoY29sbGVjdGVkUmVsYXRpb25zaGlwcywgc2VlblJlbGF0aW9uc2hpcHNJbkN1cnJlbnRTZWFyY2gsIHByb2Nlc3Nvck5hbWUsIGUsIFwiaXNfb3duX2VudGl0eVwiLCB1cmxJbmZvLnVybCwgdmVyaWZpY2F0aW9uUmVzdWx0LnJlYXNvbmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgY3VycmVudFByb2Nlc3NlZFVybEluZm8uZG9jdW1lbnRUeXBlID0gJ3ZlcmlmaWVkX2N1cnJlbnRfc3VicHJvY2Vzc29yX2xpc3QgKHJiX2V4dHJhY3Rpb25fZmFpbGVkKSc7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgeyBjdXJyZW50UHJvY2Vzc2VkVXJsSW5mby5kb2N1bWVudFR5cGUgPSAndmVyaWZpZWRfY3VycmVudF9zdWJwcm9jZXNzb3JfbGlzdCAobm9fY29udGVudF9mb3JfZXh0cmFjdGlvbiknO31cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvY2Vzc2VkVXJsSW5mby5leHRyYWN0ZWRTdWJwcm9jZXNzb3JzQ291bnQgPSBjdXJyZW50VXJsRXh0cmFjdGVkQ291bnQ7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkVXJsRGV0YWlscy5wdXNoKGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHN1Y2Nlc3NmdWxseSBleHRyYWN0ZWQgZW50aXRpZXMgZnJvbSBhIHZlcmlmaWVkIGxpc3QsIHdlIGFyZSBkb25lLlxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VXJsRXh0cmFjdGVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coYEZvdW5kIGFuZCBwcm9jZXNzZWQgYSB2YWxpZCBzdWJwcm9jZXNzb3IgbGlzdCBhdCAke3VybEluZm8udXJsfS4gU3RvcHBpbmcgc2VhcmNoLmApO1xuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBGb3VuZCB2YWxpZCBsaXN0IGZvciAke3Byb2Nlc3Nvck5hbWV9LiBGaW5pc2hpbmcgcHJvY2Vzcy5gKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIDwtLSBFWElUIFRIRSBMT09QIEVBUkxZXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gVGhpcyBibG9jayBjYXRjaGVzIGxpc3RzIHRoYXQgYXJlIG5vdCBjdXJyZW50IE9SIG5vdCBmb3IgdGhlIGNvcnJlY3QgcHJvY2Vzc29yXG4gICAgICAgICAgICAgICAgY29uc3QgdXJsTG93ZXIgPSB1cmxJbmZvLnVybC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5zS2V5d29yZCA9IFNVQlBST0NFU1NPUl9VUkxfS0VZV09SRFMuc29tZShrZXl3b3JkID0+IHVybExvd2VyLmluY2x1ZGVzKGtleXdvcmQpKTtcblxuICAgICAgICAgICAgICAgIGlmICghdmVyaWZpY2F0aW9uUmVzdWx0Py5pc0xpc3QgJiYgY29udGFpbnNLZXl3b3JkKSB7IFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvY2Vzc2VkVXJsSW5mby5kb2N1bWVudFR5cGUgPSAna2V5d29yZF9tYXRjaF9ub3RfdmVyaWZpZWRfbGlzdCc7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdnZWRDYW5kaWRhdGVVcmxDb3VudCsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmVyaWZpY2F0aW9uUmVzdWx0Py5pc0xpc3QgJiYgIXZlcmlmaWNhdGlvblJlc3VsdC5pc0NvcnJlY3RQcm9jZXNzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2Nlc3NlZFVybEluZm8uZG9jdW1lbnRUeXBlID0gJ3ZlcmlmaWVkX2xpc3RfZm9yX3dyb25nX3Byb2Nlc3Nvcic7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdnZWRDYW5kaWRhdGVVcmxDb3VudCsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmVyaWZpY2F0aW9uUmVzdWx0Py5pc0xpc3QpIHsgXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvLmRvY3VtZW50VHlwZSA9ICd2ZXJpZmllZF9zdWJwcm9jZXNzb3JfbGlzdCAobm90X2N1cnJlbnQpJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyBcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2Nlc3NlZFVybEluZm8uZG9jdW1lbnRUeXBlID0gJ25vdF9hX3N1YnByb2Nlc3Nvcl9saXN0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFByb2Nlc3NlZFVybEluZm8uZXh0cmFjdGVkU3VicHJvY2Vzc29yc0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWRVcmxEZXRhaWxzLnB1c2goY3VycmVudFByb2Nlc3NlZFVybEluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIEVuZCBvZiBsb29wIHRocm91Z2ggdW5pcXVlIFVSTHNcblxuICAgICAgICByZXR1cm4geyBjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzLCBwcm9jZXNzZWRVcmxEZXRhaWxzLCBmbGFnZ2VkQ2FuZGlkYXRlVXJsQ291bnQgfTtcbiAgICB9XG5cblxuICAgIGFzeW5jIGZldGNoRGF0YUZyb21EaXJlY3RVcmwocHJvY2Vzc29yTmFtZTogc3RyaW5nLCBsaXN0VXJsOiBzdHJpbmcpOiBQcm9taXNlPFNlYXJjaERhdGEgfCBudWxsPiB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coYEZldGNoaW5nIGRhdGEgZnJvbSBkaXJlY3QgVVJMIGZvciAke3Byb2Nlc3Nvck5hbWV9OiAke2xpc3RVcmx9YCk7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkVXJsKGxpc3RVcmwsIHByb2Nlc3Nvck5hbWUpKSB7IC8vIEJhc2ljIFVSTCB2YWxpZGF0aW9uXG4gICAgICAgICAgICBuZXcgTm90aWNlKGBUaGUgcHJvdmlkZWQgVVJMIGZvciAke3Byb2Nlc3Nvck5hbWV9IGlzIG5vdCB2YWxpZDogJHtsaXN0VXJsfWApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzOiBFeHRyYWN0ZWRSZWxhdGlvbnNoaXBbXSA9IFtdO1xuICAgICAgICBjb25zdCBzZWVuUmVsYXRpb25zaGlwc0luQ3VycmVudFNlYXJjaCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRVcmxEZXRhaWxzOiBQcm9jZXNzZWRVcmxJbmZvW10gPSBbXTtcbiAgICAgICAgbGV0IGZsYWdnZWRDYW5kaWRhdGVVcmxDb3VudCA9IDA7XG5cbiAgICAgICAgY29uc3QgZGlyZWN0VXJsSW5mb0Jhc2U6IFBhcnRpYWw8U2VycEFwaVJlc3VsdD4gPSB7IC8vIEJhc2UgaW5mbyBmb3IgdGhpcyBtYW51YWxseSBwcm92aWRlZCBVUkxcbiAgICAgICAgICAgIHRpdGxlOiBgTWFudWFsbHkgUHJvdmlkZWQgTGlzdCBmb3IgJHtwcm9jZXNzb3JOYW1lfWAsIHVybDogbGlzdFVybCxcbiAgICAgICAgICAgIHNuaXBwZXQ6ICdNYW51YWxseSBwcm92aWRlZCBVUkwnLCBwcm9jZXNzb3JOYW1lOiBwcm9jZXNzb3JOYW1lLCBkb2N1bWVudFR5cGU6ICdkaXJlY3RfaW5wdXRfbGlzdCcsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjdXJyZW50UHJvY2Vzc2VkVXJsSW5mbzogUHJvY2Vzc2VkVXJsSW5mbyA9IHsgLi4uZGlyZWN0VXJsSW5mb0Jhc2UsIHVybDogbGlzdFVybCwgZG9jdW1lbnRUeXBlOiAnZGlyZWN0X2lucHV0X2xpc3QnIH07XG5cblxuICAgICAgICBjb25zdCByYlRva2VuID0gYXdhaXQgdGhpcy5nZXRSaWdodEJyYWluQWNjZXNzVG9rZW4oKTtcbiAgICAgICAgaWYgKCFyYlRva2VuKSB7IC8vIFJCIHRva2VuIGlzIGVzc2VudGlhbCBmb3IgdmVyaWZpY2F0aW9uIGFuZCBleHRyYWN0aW9uXG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiQ291bGQgbm90IG9idGFpbiBSaWdodEJyYWluIHRva2VuIGZvciBkaXJlY3QgVVJMIHByb2Nlc3NpbmcuXCIpO1xuICAgICAgICAgICAgY3VycmVudFByb2Nlc3NlZFVybEluZm8udmVyaWZpY2F0aW9uTWV0aG9kID0gJ04vQSAoTm8gUkIgVG9rZW4pJztcbiAgICAgICAgICAgIHByb2Nlc3NlZFVybERldGFpbHMucHVzaChjdXJyZW50UHJvY2Vzc2VkVXJsSW5mbyk7IC8vIExvZyB0aGUgYXR0ZW1wdFxuICAgICAgICAgICAgcmV0dXJuIHsgY29sbGVjdGVkUmVsYXRpb25zaGlwcywgcHJvY2Vzc2VkVXJsRGV0YWlscywgZmxhZ2dlZENhbmRpZGF0ZVVybENvdW50IH07IC8vIFJldHVybiB3aXRoIG5vIGRhdGEgYnV0IHdpdGggbG9nXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3VycmVudFVybEV4dHJhY3RlZENvdW50ID0gMDtcbiAgICAgICAgY29uc3QgdmVyaWZpY2F0aW9uUmVzdWx0ID0gYXdhaXQgdGhpcy52ZXJpZnlTdWJwcm9jZXNzb3JMaXN0VXJsKGxpc3RVcmwsIHByb2Nlc3Nvck5hbWUscmJUb2tlbik7XG5cbiAgICAgICAgLy8gVXBkYXRlIGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvIHdpdGggdmVyaWZpY2F0aW9uIGRldGFpbHNcbiAgICAgICAgY3VycmVudFByb2Nlc3NlZFVybEluZm8udmVyaWZpY2F0aW9uTWV0aG9kID0gJ3JpZ2h0YnJhaW4nO1xuICAgICAgICBjdXJyZW50UHJvY2Vzc2VkVXJsSW5mby5pc0xpc3QgPSB2ZXJpZmljYXRpb25SZXN1bHQ/LmlzTGlzdCB8fCBmYWxzZTtcbiAgICAgICAgY3VycmVudFByb2Nlc3NlZFVybEluZm8uaXNDdXJyZW50ID0gdmVyaWZpY2F0aW9uUmVzdWx0Py5pc0N1cnJlbnQgfHwgZmFsc2U7IC8vIGlzQ3VycmVudCBpbXBsaWVzIGlzTGlzdFxuICAgICAgICBjdXJyZW50UHJvY2Vzc2VkVXJsSW5mby52ZXJpZmljYXRpb25SZWFzb25pbmcgPSB2ZXJpZmljYXRpb25SZXN1bHQ/LnJlYXNvbmluZyB8fCAnTi9BJztcblxuICAgICAgICBpZiAodmVyaWZpY2F0aW9uUmVzdWx0ICYmIHZlcmlmaWNhdGlvblJlc3VsdC5pc0xpc3QgJiYgdmVyaWZpY2F0aW9uUmVzdWx0LmlzQ3VycmVudCkge1xuICAgICAgICAgICAgbmV3IE5vdGljZShgVmVyaWZpZWQgbWFudWFsIFVSTDogJHtsaXN0VXJsfSBhcyBjdXJyZW50IGxpc3QuYCk7XG4gICAgICAgICAgICBjdXJyZW50UHJvY2Vzc2VkVXJsSW5mby5kb2N1bWVudFR5cGUgPSAndmVyaWZpZWRfY3VycmVudF9zdWJwcm9jZXNzb3JfbGlzdCAobWFudWFsX3VybF9pbnB1dCknO1xuICAgICAgICAgICAgaWYgKHZlcmlmaWNhdGlvblJlc3VsdC5wYWdlQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhY3Rpb25SZXN1bHQgPSBhd2FpdCB0aGlzLmV4dHJhY3RFbnRpdGllc0Zyb21QYWdlQ29udGVudCh2ZXJpZmljYXRpb25SZXN1bHQucGFnZUNvbnRlbnQsIHJiVG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChleHRyYWN0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdGhpcmRQYXJ0eVN1YnByb2Nlc3NvcnMsIG93bkVudGl0aWVzIH0gPSBleHRyYWN0aW9uUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB0aGlyZFBhcnR5U3VicHJvY2Vzc29ycy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFVybEV4dHJhY3RlZENvdW50ICs9IHRoaXMuYWRkUmVsYXRpb25zaGlwKGNvbGxlY3RlZFJlbGF0aW9uc2hpcHMsIHNlZW5SZWxhdGlvbnNoaXBzSW5DdXJyZW50U2VhcmNoLCBwcm9jZXNzb3JOYW1lLCBlLCBcInVzZXNfc3VicHJvY2Vzc29yXCIsIGxpc3RVcmwsIHZlcmlmaWNhdGlvblJlc3VsdC5yZWFzb25pbmcpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3duRW50aXRpZXMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVcmxFeHRyYWN0ZWRDb3VudCArPSB0aGlzLmFkZFJlbGF0aW9uc2hpcChjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzLCBzZWVuUmVsYXRpb25zaGlwc0luQ3VycmVudFNlYXJjaCwgcHJvY2Vzc29yTmFtZSwgZSwgXCJpc19vd25fZW50aXR5XCIsIGxpc3RVcmwsIHZlcmlmaWNhdGlvblJlc3VsdC5yZWFzb25pbmcpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyBjdXJyZW50UHJvY2Vzc2VkVXJsSW5mby5kb2N1bWVudFR5cGUgPSAndmVyaWZpZWRfY3VycmVudF9zdWJwcm9jZXNzb3JfbGlzdCAobWFudWFsX3VybF9pbnB1dF9yYl9leHRyYWN0aW9uX2ZhaWxlZCknO31cbiAgICAgICAgICAgIH0gZWxzZSB7Y3VycmVudFByb2Nlc3NlZFVybEluZm8uZG9jdW1lbnRUeXBlID0gJ3ZlcmlmaWVkX2N1cnJlbnRfc3VicHJvY2Vzc29yX2xpc3QgKG1hbnVhbF91cmxfaW5wdXRfbm9fY29udGVudCknO31cbiAgICAgICAgfSBlbHNlIHsgLy8gTm90IHZlcmlmaWVkIGFzIGN1cnJlbnQgYW5kIHZhbGlkLCBvciB2ZXJpZmljYXRpb24gZmFpbGVkXG4gICAgICAgICAgICBjb25zdCB1cmxMb3dlciA9IGxpc3RVcmwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5zS2V5d29yZCA9IFNVQlBST0NFU1NPUl9VUkxfS0VZV09SRFMuc29tZShrZXl3b3JkID0+IHVybExvd2VyLmluY2x1ZGVzKGtleXdvcmQpKTtcbiAgICAgICAgICAgIGlmICghdmVyaWZpY2F0aW9uUmVzdWx0Py5pc0xpc3QgJiYgY29udGFpbnNLZXl3b3JkKSB7IC8vIExvb2tzIGxpa2Ugb25lIChrZXl3b3JkKSwgYnV0IFJCIHNheXMgbm9cbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvY2Vzc2VkVXJsSW5mby5kb2N1bWVudFR5cGUgPSAna2V5d29yZF9tYXRjaF9ub3RfdmVyaWZpZWRfbGlzdCAobWFudWFsX3VybF9pbnB1dCknO1xuICAgICAgICAgICAgICAgIGZsYWdnZWRDYW5kaWRhdGVVcmxDb3VudCsrO1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYE1hbnVhbCBVUkwgJHtsaXN0VXJsfSBsb29rcyBsaWtlIGEgc3VicHJvY2Vzc29yIGxpc3QgYnV0IGNvdWxkbid0IGJlIHZlcmlmaWVkLiBSZWFzb246ICR7dGhpcy5zY3J1Ykh5cGVybGlua3ModmVyaWZpY2F0aW9uUmVzdWx0Py5yZWFzb25pbmcpIHx8ICdEZXRhaWxzIHVuYXZhaWxhYmxlLid9YCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgRmxhZ2dlZCBNYW51YWwgVVJMIChrZXl3b3JkIG1hdGNoLCBub3QgdmVyaWZpZWQpOiAke2xpc3RVcmx9YCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZlcmlmaWNhdGlvblJlc3VsdD8uaXNMaXN0KSB7IC8vIFJCIHNheXMgaXQncyBhIGxpc3QsIGJ1dCBub3QgY3VycmVudFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvLmRvY3VtZW50VHlwZSA9ICd2ZXJpZmllZF9zdWJwcm9jZXNzb3JfbGlzdCAobWFudWFsX3VybF9pbnB1dF9ub3RfY3VycmVudCknO1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYE1hbnVhbCBVUkwgJHtsaXN0VXJsfSB2ZXJpZmllZCBhcyBhIGxpc3QsIGJ1dCBub3QgY3VycmVudC4gUmVhc29uOiAke3RoaXMuc2NydWJIeXBlcmxpbmtzKHZlcmlmaWNhdGlvblJlc3VsdD8ucmVhc29uaW5nKSB8fCAnRGV0YWlscyB1bmF2YWlsYWJsZS4nfWApO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gUkIgc2F5cyBub3QgYSBsaXN0LCBvciB2ZXJpZmljYXRpb24gZmFpbGVkIG1vcmUgYnJvYWRseVxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9jZXNzZWRVcmxJbmZvLmRvY3VtZW50VHlwZSA9ICdub3RfYV9zdWJwcm9jZXNzb3JfbGlzdCAobWFudWFsX3VybF9pbnB1dCknO1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYE1hbnVhbCBVUkwgJHtsaXN0VXJsfSBjb3VsZCBub3QgYmUgdmVyaWZpZWQgYXMgYSBsaXN0LiBSZWFzb246ICR7dGhpcy5zY3J1Ykh5cGVybGlua3ModmVyaWZpY2F0aW9uUmVzdWx0Py5yZWFzb25pbmcpIHx8ICdEZXRhaWxzIHVuYXZhaWxhYmxlLid9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFByb2Nlc3NlZFVybEluZm8uZXh0cmFjdGVkU3VicHJvY2Vzc29yc0NvdW50ID0gY3VycmVudFVybEV4dHJhY3RlZENvdW50O1xuICAgICAgICBwcm9jZXNzZWRVcmxEZXRhaWxzLnB1c2goY3VycmVudFByb2Nlc3NlZFVybEluZm8pOyAvLyBMb2cgdGhlIHByb2Nlc3NpbmcgYXR0ZW1wdCBmb3IgdGhpcyBVUkxcbiAgICAgICAgcmV0dXJuIHsgY29sbGVjdGVkUmVsYXRpb25zaGlwcywgcHJvY2Vzc2VkVXJsRGV0YWlscywgZmxhZ2dlZENhbmRpZGF0ZVVybENvdW50IH07XG4gICAgfVxuXG5cbiAgICBhc3luYyBmZXRjaERhdGFGcm9tUGFzdGVkVGV4dChwcm9jZXNzb3JOYW1lOiBzdHJpbmcsIHBhc3RlZFRleHQ6IHN0cmluZyk6IFByb21pc2U8U2VhcmNoRGF0YSB8IG51bGw+IHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgZGF0YSBmcm9tIHBhc3RlZCB0ZXh0IGZvciAke3Byb2Nlc3Nvck5hbWV9YCk7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluRXh0cmFjdEVudGl0aWVzVGFza0lkKSB7IC8vIENoZWNrIGZvciB0aGUgc3BlY2lmaWMgdGFzayBJRFxuICAgICAgICAgICAgbmV3IE5vdGljZShcIlJpZ2h0QnJhaW4gVGFzayBJRCBmb3IgZW50aXR5IGV4dHJhY3Rpb24gaXMgbm90IGNvbmZpZ3VyZWQuIFBsZWFzZSBzZXQgaXQgaW4gcGx1Z2luIHNldHRpbmdzLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29sbGVjdGVkUmVsYXRpb25zaGlwczogRXh0cmFjdGVkUmVsYXRpb25zaGlwW10gPSBbXTtcbiAgICAgICAgY29uc3Qgc2VlblJlbGF0aW9uc2hpcHNJbkN1cnJlbnRTZWFyY2ggPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkVXJsRGV0YWlsczogUHJvY2Vzc2VkVXJsSW5mb1tdID0gW107IC8vIFRvIGxvZyB0aGlzIFwidGV4dCBwcm9jZXNzaW5nXCIgZXZlbnRcblxuICAgICAgICBjb25zdCByYlRva2VuID0gYXdhaXQgdGhpcy5nZXRSaWdodEJyYWluQWNjZXNzVG9rZW4oKTtcbiAgICAgICAgaWYgKCFyYlRva2VuKSB7IC8vIFJCIHRva2VuIGlzIGVzc2VudGlhbFxuICAgICAgICAgICAgbmV3IE5vdGljZShcIkNvdWxkIG5vdCBvYnRhaW4gUmlnaHRCcmFpbiB0b2tlbiBmb3IgcGFzdGVkIHRleHQgcHJvY2Vzc2luZy5cIik7XG4gICAgICAgICAgICAvLyBMb2cgdGhpcyBhdHRlbXB0IGFzIGEgZmFpbHVyZSBkdWUgdG8gbm8gdG9rZW5cbiAgICAgICAgICAgIHByb2Nlc3NlZFVybERldGFpbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdXJsOiBgdGV4dF9pbnB1dF9mb3JfJHt0aGlzLnNhbml0aXplTmFtZUZvckZpbGVQYXRoQW5kQWxpYXMocHJvY2Vzc29yTmFtZSkuZmlsZVBhdGhOYW1lfWAsIC8vIFBsYWNlaG9sZGVyIFVSTCBmb3IgbG9nZ2luZ1xuICAgICAgICAgICAgICAgIHRpdGxlOiBgUGFzdGVkIFRleHQgZm9yICR7cHJvY2Vzc29yTmFtZX1gLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50VHlwZTogJ21hbnVhbF90ZXh0X3N1Ym1pc3Npb25fZmFpbGVkIChub19yYl90b2tlbiknLFxuICAgICAgICAgICAgICAgIC8vIE5vIHZlcmlmaWNhdGlvbiBkZXRhaWxzIGFwcGxpY2FibGUgaGVyZSBhcyB0aGUgcHJvY2VzcyBjb3VsZG4ndCBzdGFydFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzLCBwcm9jZXNzZWRVcmxEZXRhaWxzLCBmbGFnZ2VkQ2FuZGlkYXRlVXJsQ291bnQ6IDAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXBhcmUgaW5wdXQgZm9yIHRoZSBSQiB0YXNrIGJhc2VkIG9uIGNvbmZpZ3VyZWQgZmllbGQgbmFtZVxuICAgICAgICBjb25zdCB0YXNrSW5wdXQgPSB7IFt0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5FeHRyYWN0SW5wdXRGaWVsZF06IHBhc3RlZFRleHQgfTtcbiAgICAgICAgY29uc3QgZXh0cmFjdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbFJpZ2h0QnJhaW5UYXNrKHRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkV4dHJhY3RFbnRpdGllc1Rhc2tJZCwgdGFza0lucHV0LCByYlRva2VuKTtcblxuICAgICAgICBsZXQgY3VycmVudFVybEV4dHJhY3RlZENvdW50ID0gMDtcbiAgICAgICAgY29uc3Qgc291cmNlUGxhY2Vob2xkZXIgPSBgbWFudWFsX3RleHRfaW5wdXQ6JHtwcm9jZXNzb3JOYW1lfWA7IC8vIEZvciB0aGUgU291cmNlVVJMIGZpZWxkXG5cbiAgICAgICAgaWYgKGV4dHJhY3Rpb25SZXN1bHQgJiYgdHlwZW9mIGV4dHJhY3Rpb25SZXN1bHQucmVzcG9uc2UgPT09ICdvYmplY3QnICYmIGV4dHJhY3Rpb25SZXN1bHQucmVzcG9uc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJiUmVzcG9uc2UgPSBleHRyYWN0aW9uUmVzdWx0LnJlc3BvbnNlO1xuICAgICAgICAgICAgLy8gQWNjZXNzIGV4dHJhY3RlZCBlbnRpdGllcyB1c2luZyBjb25maWd1cmVkIGZpZWxkIG5hbWVzXG4gICAgICAgICAgICBjb25zdCB0aGlyZFBhcnR5ID0gcmJSZXNwb25zZVt0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5FeHRyYWN0T3V0cHV0VGhpcmRQYXJ0eUZpZWxkXSB8fCBbXTtcbiAgICAgICAgICAgIGNvbnN0IG93biA9IHJiUmVzcG9uc2VbdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluRXh0cmFjdE91dHB1dE93bkVudGl0aWVzRmllbGRdIHx8IFtdO1xuXG4gICAgICAgICAgICB0aGlyZFBhcnR5LmZvckVhY2goKGU6IGFueSkgPT4geyAvLyBBc3N1bWluZyAnZScgaXMgYW4gb2JqZWN0IHdpdGggJ25hbWUnLCAncHJvY2Vzc2luZ19mdW5jdGlvbicsICdsb2NhdGlvbidcbiAgICAgICAgICAgICAgICBjdXJyZW50VXJsRXh0cmFjdGVkQ291bnQgKz0gdGhpcy5hZGRSZWxhdGlvbnNoaXAoY29sbGVjdGVkUmVsYXRpb25zaGlwcywgc2VlblJlbGF0aW9uc2hpcHNJbkN1cnJlbnRTZWFyY2gsIHByb2Nlc3Nvck5hbWUsIGUsIFwidXNlc19zdWJwcm9jZXNzb3JcIiwgc291cmNlUGxhY2Vob2xkZXIsIFwiUHJvY2Vzc2VkIGZyb20gbWFudWFsbHkgcGFzdGVkIHRleHQuXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvd24uZm9yRWFjaCgoZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgY3VycmVudFVybEV4dHJhY3RlZENvdW50ICs9IHRoaXMuYWRkUmVsYXRpb25zaGlwKGNvbGxlY3RlZFJlbGF0aW9uc2hpcHMsIHNlZW5SZWxhdGlvbnNoaXBzSW5DdXJyZW50U2VhcmNoLCBwcm9jZXNzb3JOYW1lLCBlLCBcImlzX293bl9lbnRpdHlcIiwgc291cmNlUGxhY2Vob2xkZXIsIFwiUHJvY2Vzc2VkIGZyb20gbWFudWFsbHkgcGFzdGVkIHRleHQuXCIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIExvZyBzdWNjZXNzZnVsIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIHByb2Nlc3NlZFVybERldGFpbHMucHVzaCh7IFxuICAgICAgICAgICAgICAgIHVybDogc291cmNlUGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGBQYXN0ZWQgVGV4dCBmb3IgJHtwcm9jZXNzb3JOYW1lfWAsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRUeXBlOiAnbWFudWFsX3RleHRfc3VibWlzc2lvbl9wcm9jZXNzZWQnLFxuICAgICAgICAgICAgICAgIHZlcmlmaWNhdGlvbk1ldGhvZDogJ3JpZ2h0YnJhaW5fdGV4dF90YXNrJyxcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWRTdWJwcm9jZXNzb3JzQ291bnQ6IGN1cnJlbnRVcmxFeHRyYWN0ZWRDb3VudCxcbiAgICAgICAgICAgICAgICB2ZXJpZmljYXRpb25SZWFzb25pbmc6IGBFeHRyYWN0ZWQgJHtjdXJyZW50VXJsRXh0cmFjdGVkQ291bnR9IGVudGl0aWVzIGZyb20gcGFzdGVkIHRleHQuYFxuICAgICAgICAgICAgfSk7IFxuICAgICAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7IC8vIFJCIHRhc2sgZmFpbGVkIG9yIHJldHVybmVkIHVuZXhwZWN0ZWQgZm9ybWF0XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBGYWlsZWQgdG8gZXh0cmFjdCBlbnRpdGllcyBmcm9tIHBhc3RlZCB0ZXh0IGZvciAke3Byb2Nlc3Nvck5hbWV9LiBDaGVjayBjb25zb2xlLmApO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUHJvY2Vzc29yUHJvY2Vzc29yOiBSQiBFeHRyYWN0IEZyb20gVGV4dCB0YXNrIGRpZCBub3QgcmV0dXJuIGV4cGVjdGVkICdyZXNwb25zZScgb2JqZWN0IG9yIGZhaWxlZC4gRnVsbCB0YXNrIHJlc3VsdDpgLCBKU09OLnN0cmluZ2lmeShleHRyYWN0aW9uUmVzdWx0KS5zdWJzdHJpbmcoMCw1MDApKTtcbiAgICAgICAgICAgIC8vIExvZyBmYWlsZWQgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgcHJvY2Vzc2VkVXJsRGV0YWlscy5wdXNoKHsgXG4gICAgICAgICAgICAgICAgdXJsOiBzb3VyY2VQbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICB0aXRsZTogYFBhc3RlZCBUZXh0IGZvciAke3Byb2Nlc3Nvck5hbWV9YCxcbiAgICAgICAgICAgICAgICBkb2N1bWVudFR5cGU6ICdtYW51YWxfdGV4dF9zdWJtaXNzaW9uX2ZhaWxlZCAocmJfdGFza19lcnJvciknLFxuICAgICAgICAgICAgICAgIHZlcmlmaWNhdGlvbk1ldGhvZDogJ3JpZ2h0YnJhaW5fdGV4dF90YXNrJyxcbiAgICAgICAgICAgICAgICB2ZXJpZmljYXRpb25SZWFzb25pbmc6ICdSaWdodEJyYWluIHRhc2sgZm9yIHRleHQgcHJvY2Vzc2luZyBmYWlsZWQgb3IgcmV0dXJuZWQgYW4gdW5leHBlY3RlZCByZXNwb25zZS4nXG4gICAgICAgICAgICB9KTsgXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBjb2xsZWN0ZWRSZWxhdGlvbnNoaXBzLCBwcm9jZXNzZWRVcmxEZXRhaWxzLCBmbGFnZ2VkQ2FuZGlkYXRlVXJsQ291bnQ6IDAgfTsgLy8gZmxhZ2dlZENhbmRpZGF0ZVVybENvdW50IGlzIDAgZm9yIHRleHQgaW5wdXRcbiAgICB9XG5cblxuICAgIHByaXZhdGUgYXN5bmMgZW5zdXJlRm9sZGVyRXhpc3RzKGZvbGRlclBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICAvLyBOb3JtYWxpemUgcGF0aDogcmVtb3ZlIGxlYWRpbmcgc2xhc2ggaWYgcHJlc2VudCwgYXMgdmF1bHQgcGF0aHMgYXJlIHJlbGF0aXZlIHRvIHZhdWx0IHJvb3RcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gZm9sZGVyUGF0aC5zdGFydHNXaXRoKCcvJykgPyBmb2xkZXJQYXRoLnN1YnN0cmluZygxKSA6IGZvbGRlclBhdGg7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZFBhdGggPT09ICcnKSByZXR1cm47IC8vIERvIG5vdGhpbmcgaWYgcGF0aCBpcyBlbXB0eSAoZS5nLiByb290LCB0aG91Z2ggbm90IHR5cGljYWwgZm9yIHRoaXMgdXNlKVxuXG4gICAgICAgICAgICBjb25zdCBhYnN0cmFjdEZvbGRlclBhdGggPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobm9ybWFsaXplZFBhdGgpO1xuICAgICAgICAgICAgaWYgKCFhYnN0cmFjdEZvbGRlclBhdGgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIobm9ybWFsaXplZFBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coYEZvbGRlciBjcmVhdGVkOiAke25vcm1hbGl6ZWRQYXRofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSB7IGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coYEZvbGRlciBhbHJlYWR5IGV4aXN0czogJHtub3JtYWxpemVkUGF0aH1gKTsgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBEb24ndCB0aHJvdywgYnV0IGxvZyBhbmQgbm90aWZ5LiBUaGUgb3BlcmF0aW9uIG1pZ2h0IHN0aWxsIHByb2NlZWQgaWYgdGhlIGZvbGRlciBleGlzdHMgYnV0IGFuIGVycm9yIG9jY3VycmVkIGNoZWNraW5nLlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZW5zdXJpbmcgZm9sZGVyICR7Zm9sZGVyUGF0aH0gZXhpc3RzOmAsIGUpO1xuICAgICAgICAgICAgbmV3IE5vdGljZShgRXJyb3IgY3JlYXRpbmcgZm9sZGVyOiAke2ZvbGRlclBhdGh9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGVuc3VyZVByb2Nlc3NvckZpbGUob3JpZ2luYWxQcm9jZXNzb3JOYW1lOiBzdHJpbmcsIGFkZEZyb250bWF0dGVyOiBib29sZWFuID0gZmFsc2UsIGlzVG9wTGV2ZWxQcm9jZXNzb3I6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTxURmlsZSB8IG51bGw+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVGb2xkZXJFeGlzdHModGhpcy5zZXR0aW5ncy5wcm9jZXNzb3JzRm9sZGVyUGF0aCk7XG4gICAgICAgIGNvbnN0IHsgZmlsZVBhdGhOYW1lLCBvcmlnaW5hbE5hbWVBc0FsaWFzIH0gPSB0aGlzLnNhbml0aXplTmFtZUZvckZpbGVQYXRoQW5kQWxpYXMob3JpZ2luYWxQcm9jZXNzb3JOYW1lKTtcbiAgICAgICAgY29uc3QgZm9sZGVyID0gdGhpcy5zZXR0aW5ncy5wcm9jZXNzb3JzRm9sZGVyUGF0aC5zdGFydHNXaXRoKCcvJykgPyB0aGlzLnNldHRpbmdzLnByb2Nlc3NvcnNGb2xkZXJQYXRoLnN1YnN0cmluZygxKSA6IHRoaXMuc2V0dGluZ3MucHJvY2Vzc29yc0ZvbGRlclBhdGg7XG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gYCR7Zm9sZGVyfS8ke2ZpbGVQYXRoTmFtZX0ubWRgO1xuICAgICAgICBsZXQgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmaWxlUGF0aCkgYXMgVEZpbGU7XG4gICAgXG4gICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChhZGRGcm9udG1hdHRlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWcgPSBpc1RvcExldmVsUHJvY2Vzc29yID8gJ3Byb2Nlc3NvcicgOiAnc3VicHJvY2Vzc29yJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxpYXNGb3JGcm9udG1hdHRlciA9IG9yaWdpbmFsTmFtZUFzQWxpYXMucmVwbGFjZSgvWzpcXFtcXF0sXCJdL2csICcnKTsgXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZW50ID0gYC0tLVxcbnRhZ3M6IFske3RhZ31dXFxuYWxpYXNlczogW1wiJHthbGlhc0ZvckZyb250bWF0dGVyfVwiXVxcbi0tLVxcblxcbiMgJHtvcmlnaW5hbE5hbWVBc0FsaWFzfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRlbnQgPSBgIyAke29yaWdpbmFsTmFtZUFzQWxpYXN9XFxuXFxuYDsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbGUgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoZmlsZVBhdGgsIGluaXRpYWxDb250ZW50KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgICAgICBpZiAoZS5tZXNzYWdlPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiZmlsZSBhbHJlYWR5IGV4aXN0c1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZpbGVQYXRoKSBhcyBURmlsZTtcbiAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZSkgeyBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZ2V0IGZpbGUgJHtmaWxlUGF0aH0gYWZ0ZXIgJ2FscmVhZHkgZXhpc3RzJyBlcnJvci5gKTsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgICAgICAgICAgfSBlbHNlIHsgY29uc29sZS5lcnJvcihgRXJyb3IgY3JlYXRpbmcgcHJvY2Vzc29yIGZpbGUgJHtmaWxlUGF0aH06YCwgZSk7IHJldHVybiBudWxsOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGUgJiYgYWRkRnJvbnRtYXR0ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IGlzVG9wTGV2ZWxQcm9jZXNzb3IgPyAncHJvY2Vzc29yJyA6ICdzdWJwcm9jZXNzb3InO1xuICAgICAgICAgICAgY29uc3QgYWxpYXNGb3JGcm9udG1hdHRlciA9IG9yaWdpbmFsTmFtZUFzQWxpYXMucmVwbGFjZSgvWzpcXFtcXF0sXCJdL2csICcnKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LnByb2Nlc3MoZmlsZSwgKGNvbnRlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q29udGVudCA9IHRoaXMudXBkYXRlRnJvbnRtYXR0ZXIoY29udGVudCwgeyB0YWdzOiBbdGFnXSwgYWxpYXNlczogW2FsaWFzRm9yRnJvbnRtYXR0ZXJdIH0sIG9yaWdpbmFsTmFtZUFzQWxpYXMpO1xuICAgICAgICAgICAgICAgIGlmICghbmV3Q29udGVudC50cmltKCkuaW5jbHVkZXMoYCMgJHtvcmlnaW5hbE5hbWVBc0FsaWFzfWApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlTdGFydEluZGV4ID0gbmV3Q29udGVudC5pbmRleE9mKCdcXG4tLS0nKSA+IDAgPyBuZXdDb250ZW50LmluZGV4T2YoJ1xcbi0tLScsIG5ld0NvbnRlbnQuaW5kZXhPZignXFxuLS0tJykgKyAzKSArIDQgOiAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gbmV3Q29udGVudC5zdWJzdHJpbmcoYm9keVN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9udG1hdHRlclBhcnQgPSBuZXdDb250ZW50LnN1YnN0cmluZygwLCBib2R5U3RhcnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBmcm9udG1hdHRlclBhcnQgKyAoZnJvbnRtYXR0ZXJQYXJ0LmVuZHNXaXRoKFwiXFxuXCIpID8gXCJcIiA6IFwiXFxuXCIpICsgYCMgJHtvcmlnaW5hbE5hbWVBc0FsaWFzfVxcblxcbmAgKyBib2R5LnRyaW1TdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Q29udGVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBhc3luYyB1cGRhdGVQcm9jZXNzb3JGaWxlKGZpbGU6IFRGaWxlLCBvcmlnaW5hbFByb2Nlc3Nvck5hbWU6IHN0cmluZywgcmVsYXRpb25zaGlwczogRXh0cmFjdGVkUmVsYXRpb25zaGlwW10sIGlzVG9wTGV2ZWxQcm9jZXNzb3I6IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3Qgc3VicHJvY2Vzc29yc0hlYWRpbmcgPSBcIlN1YnByb2Nlc3NvcnNcIjtcbiAgICAgICAgbGV0IHRhYmxlTWQgPSBgfCBTdWJwcm9jZXNzb3IgRW50aXR5IE5hbWUgfCBQcm9jZXNzaW5nIEZ1bmN0aW9uIHwgTG9jYXRpb24gfFxcbmA7XG4gICAgICAgIHRhYmxlTWQgKz0gYHwtLS18LS0tfC0tLXxcXG5gO1xuXG4gICAgICAgIC8vIEZpbHRlciBmb3IgJ3VzZXNfc3VicHJvY2Vzc29yJyByZWxhdGlvbnNoaXBzIHdoZXJlIHRoZSBjdXJyZW50IHByb2Nlc3NvciBpcyB0aGUgUHJpbWFyeVByb2Nlc3NvclxuICAgICAgICBjb25zdCByZWxldmFudFJlbGF0aW9uc2hpcHMgPSByZWxhdGlvbnNoaXBzLmZpbHRlcihyID0+IHIuUmVsYXRpb25zaGlwVHlwZSA9PT0gJ3VzZXNfc3VicHJvY2Vzc29yJyAmJiByLlByaW1hcnlQcm9jZXNzb3IgPT09IG9yaWdpbmFsUHJvY2Vzc29yTmFtZSk7XG5cbiAgICAgICAgcmVsZXZhbnRSZWxhdGlvbnNoaXBzLmZvckVhY2gocmVsID0+IHtcbiAgICAgICAgICAgIC8vIFNhbml0aXplIHRoZSBzdWJwcm9jZXNzb3IncyBuYW1lIGZvciBmaWxlIHBhdGggYW5kIGdldCBvcmlnaW5hbCBmb3IgYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IHsgZmlsZVBhdGhOYW1lOiBzdWJGaWxlUGF0aE5hbWUsIG9yaWdpbmFsTmFtZUFzQWxpYXM6IHN1Yk9yaWdpbmFsTmFtZSB9ID0gdGhpcy5zYW5pdGl6ZU5hbWVGb3JGaWxlUGF0aEFuZEFsaWFzKHJlbC5TdWJwcm9jZXNzb3JOYW1lKTtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgZGlzcGxheSBhbGlhcyBmb3IgTWFya2Rvd24gbGluayAocmVtb3ZlIGNoYXJzIHRoYXQgYnJlYWsgbGlua3MvZGlzcGxheSlcbiAgICAgICAgICAgIGNvbnN0IG1hcmtkb3duQWxpYXMgPSBzdWJPcmlnaW5hbE5hbWUucmVwbGFjZSgvXFxuL2csICcgJykucmVwbGFjZSgvW1xcW1xcXSgpfF0vZywgJycpOyAvLyBCYXNpYyBzYW5pdGl6YXRpb24gZm9yIGxpbmsgdGV4dFxuXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzb3JzRm9sZGVyID0gdGhpcy5zZXR0aW5ncy5wcm9jZXNzb3JzRm9sZGVyUGF0aDsgLy8gTm8gbGVhZGluZy90cmFpbGluZyBzbGFzaGVzIG5lZWRlZCBieSBlbmNvZGVVUkkgaWYgcGF0aCBpcyBjbGVhblxuICAgICAgICAgICAgY29uc3QgbWFya2Rvd25MaW5rVGFyZ2V0ID0gZW5jb2RlVVJJKGAke3Byb2Nlc3NvcnNGb2xkZXJ9LyR7c3ViRmlsZVBhdGhOYW1lfS5tZGApOyAvLyBVc2Ugc2FuaXRpemVkIG5hbWUgZm9yIGxpbmsgdGFyZ2V0XG5cbiAgICAgICAgICAgIGNvbnN0IHN1YnByb2Nlc3NvclBhZ2VMaW5rID0gYFske21hcmtkb3duQWxpYXN9XSgke21hcmtkb3duTGlua1RhcmdldH0pYDsgLy8gVXNlIHN0YW5kYXJkIE1hcmtkb3duIGxpbmsgZm9ybWF0XG5cbiAgICAgICAgICAgIC8vIFNjcnViIGFuZCBwcmVwYXJlIGRpc3BsYXkgZm9yIHByb2Nlc3NpbmcgZnVuY3Rpb24gYW5kIGxvY2F0aW9uXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzaW5nRnVuY3Rpb25EaXNwbGF5ID0gKHJlbC5Qcm9jZXNzaW5nRnVuY3Rpb24gfHwgXCJOL0FcIikucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKS5yZXBsYWNlKC9cXHwvZywgXCJcXFxcfFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uRGlzcGxheSA9IChyZWwuTG9jYXRpb24gfHwgXCJOL0FcIikucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKS5yZXBsYWNlKC9cXHwvZywgXCJcXFxcfFwiKTtcblxuICAgICAgICAgICAgdGFibGVNZCArPSBgfCAke3N1YnByb2Nlc3NvclBhZ2VMaW5rfSB8ICR7cHJvY2Vzc2luZ0Z1bmN0aW9uRGlzcGxheX0gfCAke2xvY2F0aW9uRGlzcGxheX0gfFxcbmA7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgY29uc3QgYW5hbHlzaXNMb2dzSGVhZGluZyA9IFwiQW5hbHlzaXMgTG9nc1wiO1xuICAgICAgICAvLyBTYW5pdGl6ZSBwcm9jZXNzb3IgbmFtZSBmb3IgbG9nIGZpbGUgbmFtZSBwYXJ0XG4gICAgICAgIGNvbnN0IHsgZmlsZVBhdGhOYW1lOiBsb2dGaWxlUGF0aE5hbWVQYXJ0IH0gPSB0aGlzLnNhbml0aXplTmFtZUZvckZpbGVQYXRoQW5kQWxpYXMob3JpZ2luYWxQcm9jZXNzb3JOYW1lKTtcbiAgICAgICAgY29uc3QgYW5hbHlzaXNMb2dzRm9sZGVyID0gdGhpcy5zZXR0aW5ncy5hbmFseXNpc0xvZ3NGb2xkZXJQYXRoOyAvLyBOb3JtYWxpemVkXG4gICAgICAgIGNvbnN0IGxvZ0ZpbGVOYW1lID0gYCR7bG9nRmlsZVBhdGhOYW1lUGFydH0gU3VicHJvY2Vzc29yIExvZ3MubWRgO1xuICAgICAgICBjb25zdCBsb2dGaWxlTGlua1RhcmdldCA9IGVuY29kZVVSSShgJHthbmFseXNpc0xvZ3NGb2xkZXJ9LyR7bG9nRmlsZU5hbWV9YCk7IC8vIFVzZSBzYW5pdGl6ZWQgbmFtZSBmb3IgbG9nIGZpbGUgbGlua1xuICAgICAgICBjb25zdCBsb2dGaWxlTGluayA9IGBbWyR7YW5hbHlzaXNMb2dzRm9sZGVyfS8ke2xvZ0ZpbGVOYW1lfXwke29yaWdpbmFsUHJvY2Vzc29yTmFtZX0gU3VicHJvY2Vzc29yIExvZ3NdXWA7IC8vIE9ic2lkaWFuIGxpbmsgdG8gbG9nXG4gICAgICAgIGNvbnN0IGFuYWx5c2lzTG9nU2VjdGlvbiA9IGBcXG4tICR7bG9nRmlsZUxpbmt9XFxuYDtcblxuICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5wcm9jZXNzKGZpbGUsIChjb250ZW50OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IGlzVG9wTGV2ZWxQcm9jZXNzb3IgPyAncHJvY2Vzc29yJyA6ICdzdWJwcm9jZXNzb3InO1xuICAgICAgICAgICAgbGV0IG5ld0NvbnRlbnQgPSB0aGlzLnVwZGF0ZUZyb250bWF0dGVyKGNvbnRlbnQsIHsgdGFnczogW3RhZ10sIGFsaWFzZXM6IFtvcmlnaW5hbFByb2Nlc3Nvck5hbWUucmVwbGFjZSgvWzpcXFtcXF0sXCJdL2csICcnKV0gfSwgb3JpZ2luYWxQcm9jZXNzb3JOYW1lKTtcblxuICAgICAgICAgICAgLy8gRW5zdXJlIEgxIGhlYWRpbmcgZm9yIG9yaWdpbmFsUHJvY2Vzc29yTmFtZVxuICAgICAgICAgICAgaWYgKCFuZXdDb250ZW50LnRyaW0oKS5pbmNsdWRlcyhgIyAke29yaWdpbmFsUHJvY2Vzc29yTmFtZX1gKSkge1xuICAgICAgICAgICAgICAgICBjb25zdCBib2R5U3RhcnRJbmRleCA9IG5ld0NvbnRlbnQuaW5kZXhPZignXFxuLS0tJykgPiAwID8gbmV3Q29udGVudC5pbmRleE9mKCdcXG4tLS0nLCBuZXdDb250ZW50LmluZGV4T2YoJ1xcbi0tLScpICsgMykgKyA0IDogMDtcbiAgICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IG5ld0NvbnRlbnQuc3Vic3RyaW5nKGJvZHlTdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICAgY29uc3QgZnJvbnRtYXR0ZXJQYXJ0ID0gbmV3Q29udGVudC5zdWJzdHJpbmcoMCwgYm9keVN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgICBuZXdDb250ZW50ID0gZnJvbnRtYXR0ZXJQYXJ0ICsgKGZyb250bWF0dGVyUGFydC5lbmRzV2l0aChcIlxcblwiKSA/IFwiXCIgOiBcIlxcblwiKSArIGAjICR7b3JpZ2luYWxQcm9jZXNzb3JOYW1lfVxcblxcbmAgKyBib2R5LnRyaW1TdGFydCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbnN1cmUvVXBkYXRlIFN1YnByb2Nlc3NvcnMgc2VjdGlvblxuICAgICAgICAgICAgbmV3Q29udGVudCA9IHRoaXMuZW5zdXJlSGVhZGluZ0FuZFNlY3Rpb24obmV3Q29udGVudCwgc3VicHJvY2Vzc29yc0hlYWRpbmcsIHRhYmxlTWQsIG51bGwsIG51bGwpOyAvLyBSZXBsYWNlIGVudGlyZSBzZWN0aW9uXG4gICAgICAgICAgICAvLyBFbnN1cmUvVXBkYXRlIEFuYWx5c2lzIExvZ3Mgc2VjdGlvblxuICAgICAgICAgICAgbmV3Q29udGVudCA9IHRoaXMuZW5zdXJlSGVhZGluZ0FuZFNlY3Rpb24obmV3Q29udGVudCwgYW5hbHlzaXNMb2dzSGVhZGluZywgYW5hbHlzaXNMb2dTZWN0aW9uLCBudWxsLCBudWxsLCB0cnVlKTsgLy8gQXBwZW5kIGlmIGhlYWRpbmcgZXhpc3RzLCBlbHNlIGNyZWF0ZVxuICAgICAgICAgICAgcmV0dXJuIG5ld0NvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBhc3luYyBjcmVhdGVPclVwZGF0ZVN1YnByb2Nlc3NvckZpbGUoXG4gICAgICAgIG9yaWdpbmFsU3VicHJvY2Vzc29yTmFtZTogc3RyaW5nLCAvLyBUaGUgbmFtZSBvZiB0aGUgc3VicHJvY2Vzc29yIGl0c2VsZiAoZS5nLiwgXCJBV1NcIilcbiAgICAgICAgb3JpZ2luYWxQcmltYXJ5UHJvY2Vzc29yTmFtZUZvckNvbnRleHQ6IHN0cmluZywgLy8gVGhlIHByaW1hcnkgcHJvY2Vzc29yIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQgKGUuZy4sIFwiT3BlbkFJXCIpIC0gZm9yIGNvbnRleHQsIG5vdCB1c3VhbGx5IG1haW4gY29udGVudCBvZiBBV1MubWRcbiAgICAgICAgbmV3Q2xpZW50UmVsYXRpb25zaGlwczogRXh0cmFjdGVkUmVsYXRpb25zaGlwW10gLy8gUmVsYXRpb25zaGlwcyB3aGVyZSBvcmlnaW5hbFN1YnByb2Nlc3Nvck5hbWUgaXMgdGhlIHRhcmdldCAoU3VicHJvY2Vzc29yTmFtZSkgYW5kIHR5cGUgaXMgJ3VzZXNfc3VicHJvY2Vzc29yJ1xuICAgICkge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZUZvbGRlckV4aXN0cyh0aGlzLnNldHRpbmdzLnByb2Nlc3NvcnNGb2xkZXJQYXRoKTtcbiAgICAgICAgY29uc3QgeyBmaWxlUGF0aE5hbWU6IHN1YkZpbGVQYXRoTmFtZSwgb3JpZ2luYWxOYW1lQXNBbGlhczogc3ViT3JpZ2luYWxOYW1lQXNBbGlhcyB9ID0gdGhpcy5zYW5pdGl6ZU5hbWVGb3JGaWxlUGF0aEFuZEFsaWFzKG9yaWdpbmFsU3VicHJvY2Vzc29yTmFtZSk7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuc2V0dGluZ3MucHJvY2Vzc29yc0ZvbGRlclBhdGguc3RhcnRzV2l0aCgnLycpID8gdGhpcy5zZXR0aW5ncy5wcm9jZXNzb3JzRm9sZGVyUGF0aC5zdWJzdHJpbmcoMSkgOiB0aGlzLnNldHRpbmdzLnByb2Nlc3NvcnNGb2xkZXJQYXRoO1xuICAgICAgICBjb25zdCBzdWJGaWxlUGF0aCA9IGAke2ZvbGRlcn0vJHtzdWJGaWxlUGF0aE5hbWV9Lm1kYDtcblxuICAgICAgICBsZXQgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChzdWJGaWxlUGF0aCkgYXMgVEZpbGU7XG4gICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgY29uc3QgYWxpYXNGb3JGcm9udG1hdHRlciA9IHN1Yk9yaWdpbmFsTmFtZUFzQWxpYXMucmVwbGFjZSgvWzpcXFtcXF0sXCJdL2csICcnKTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxDb250ZW50ID0gYC0tLVxcbnRhZ3M6IFtzdWJwcm9jZXNzb3JdXFxuYWxpYXNlczogW1wiJHthbGlhc0ZvckZyb250bWF0dGVyfVwiXVxcbi0tLVxcblxcbiMgJHtzdWJPcmlnaW5hbE5hbWVBc0FsaWFzfVxcblxcbiMjIFVzZWQgQnlcXG5cXG5gO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmaWxlID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKHN1YkZpbGVQYXRoLCBpbml0aWFsQ29udGVudCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5tZXNzYWdlPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiZmlsZSBhbHJlYWR5IGV4aXN0c1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHN1YkZpbGVQYXRoKSBhcyBURmlsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlKSB7IGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBnZXQgc3VicHJvY2Vzc29yIGZpbGUgJHtzdWJGaWxlUGF0aH0gYWZ0ZXIgJ2FscmVhZHkgZXhpc3RzJyBlcnJvci5gKTsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgY29uc29sZS5lcnJvcihgRXJyb3IgY3JlYXRpbmcgc3VicHJvY2Vzc29yIGZpbGUgJHtzdWJGaWxlUGF0aH06YCwgZSk7IHJldHVybjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmaWxlKSByZXR1cm47IC8vIFNob3VsZCBub3QgaGFwcGVuIGlmIGNyZWF0aW9uL3JldHJpZXZhbCB3YXMgc3VjY2Vzc2Z1bFxuXG4gICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LnByb2Nlc3MoZmlsZSwgKGNvbnRlbnQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgbGV0IG5ld0NvbnRlbnQgPSB0aGlzLnVwZGF0ZUZyb250bWF0dGVyKGNvbnRlbnQsIHsgdGFnczogW1wic3VicHJvY2Vzc29yXCJdLCBhbGlhc2VzOiBbc3ViT3JpZ2luYWxOYW1lQXNBbGlhcy5yZXBsYWNlKC9bOlxcW1xcXSxcIl0vZywgJycpXSB9LCBzdWJPcmlnaW5hbE5hbWVBc0FsaWFzKTtcbiAgICAgICAgICAgIGlmICghbmV3Q29udGVudC50cmltKCkuaW5jbHVkZXMoYCMgJHtzdWJPcmlnaW5hbE5hbWVBc0FsaWFzfWApKSB7XG4gICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlTdGFydEluZGV4ID0gbmV3Q29udGVudC5pbmRleE9mKCdcXG4tLS0nKSA+IDAgPyBuZXdDb250ZW50LmluZGV4T2YoJ1xcbi0tLScsIG5ld0NvbnRlbnQuaW5kZXhPZignXFxuLS0tJykgKyAzKSArIDQgOiAwO1xuICAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gbmV3Q29udGVudC5zdWJzdHJpbmcoYm9keVN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgICBjb25zdCBmcm9udG1hdHRlclBhcnQgPSBuZXdDb250ZW50LnN1YnN0cmluZygwLCBib2R5U3RhcnRJbmRleCk7XG4gICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQgPSBmcm9udG1hdHRlclBhcnQgKyAoZnJvbnRtYXR0ZXJQYXJ0LmVuZHNXaXRoKFwiXFxuXCIpID8gXCJcIiA6IFwiXFxuXCIpICsgYCMgJHtzdWJPcmlnaW5hbE5hbWVBc0FsaWFzfVxcblxcbmAgKyBib2R5LnRyaW1TdGFydCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB1c2VkQnlIZWFkaW5nID0gXCJVc2VkIEJ5XCI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFN0ZXAgMTogRXh0cmFjdCBleGlzdGluZyByb3dzIGFuZCBwdXQgdGhlbSBpbiBhIFNldCB0byBoYW5kbGUgdW5pcXVlbmVzc1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdSb3dzID0gdGhpcy5leHRyYWN0Q2xpZW50VGFibGVSb3dzKGNvbnRlbnQpO1xuICAgICAgICAgICAgY29uc3QgYWxsUm93cyA9IG5ldyBTZXQ8c3RyaW5nPihleGlzdGluZ1Jvd3MpO1xuXG4gICAgICAgICAgICAvLyBTdGVwIDI6IFByb2Nlc3MgbmV3IHJlbGF0aW9uc2hpcHMgYW5kIGFkZCB0aGVtIHRvIHRoZSBTZXRcbiAgICAgICAgICAgIG5ld0NsaWVudFJlbGF0aW9uc2hpcHMuZm9yRWFjaChyZWwgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxOYW1lQXNBbGlhczogcHJpbWFyeU9yaWdpbmFsTmFtZSB9ID0gdGhpcy5zYW5pdGl6ZU5hbWVGb3JGaWxlUGF0aEFuZEFsaWFzKHJlbC5QcmltYXJ5UHJvY2Vzc29yKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBubyBsb25nZXIgY3JlYXRlIGEgbGluaywgc28gd2UganVzdCB1c2UgdGhlIG5hbWUgYW5kIGVzY2FwZSBhbnkgcGlwZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIGNvbnN0IHByaW1hcnlQcm9jZXNzb3JQbGFpblRleHQgPSBwcmltYXJ5T3JpZ2luYWxOYW1lLnJlcGxhY2UoL1xcfC9nLCBcIlxcXFx8XCIpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2luZ0Z1bmN0aW9uRGlzcGxheSA9IChyZWwuUHJvY2Vzc2luZ0Z1bmN0aW9uIHx8IFwiTi9BXCIpLnJlcGxhY2UoL1xcbi9nLCBcIjxicj5cIikucmVwbGFjZSgvXFx8L2csIFwiXFxcXHxcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb25EaXNwbGF5ID0gKHJlbC5Mb2NhdGlvbiB8fCBcIk4vQVwiKS5yZXBsYWNlKC9cXG4vZywgXCI8YnI+XCIpLnJlcGxhY2UoL1xcfC9nLCBcIlxcXFx8XCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVVybExpbmsgPSByZWwuU291cmNlVVJMLnN0YXJ0c1dpdGgoXCJodHRwXCIpID8gYFtTb3VyY2VdKCR7cmVsLlNvdXJjZVVSTH0pYCA6IHJlbC5Tb3VyY2VVUkw7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGlubmVyIGNvbnRlbnQgb2YgdGhlIHJvdywgbm93IHVzaW5nIHBsYWluIHRleHQgZm9yIHRoZSBwcmltYXJ5IHByb2Nlc3Nvci5cbiAgICAgICAgICAgICAgICBjb25zdCByb3dDb250ZW50ID0gYCAke3ByaW1hcnlQcm9jZXNzb3JQbGFpblRleHR9IHwgJHtwcm9jZXNzaW5nRnVuY3Rpb25EaXNwbGF5fSB8ICR7bG9jYXRpb25EaXNwbGF5fSB8ICR7c291cmNlVXJsTGlua30gYDtcbiAgICAgICAgICAgICAgICBhbGxSb3dzLmFkZChyb3dDb250ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTdGVwIDM6IEJ1aWxkIHRoZSBmaW5hbCwgY29tcGxldGUgdGFibGUgZnJvbSB0aGUgU2V0IG9mIGFsbCByb3dzXG4gICAgICAgICAgICBsZXQgY2xpZW50VGFibGVNZCA9IGB8IFByaW1hcnkgUHJvY2Vzc29yIHwgUHJvY2Vzc2luZyBGdW5jdGlvbiB8IExvY2F0aW9uIHwgU291cmNlIFVSTCB8XFxuYDtcbiAgICAgICAgICAgIGNsaWVudFRhYmxlTWQgKz0gYHwtLS18LS0tfC0tLXwtLS18XFxuYDtcbiAgICAgICAgICAgIGFsbFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFJlLWFkZCB0aGUgb3V0ZXIgcGlwZXMgZm9yIGVhY2ggcm93XG4gICAgICAgICAgICAgICAgY2xpZW50VGFibGVNZCArPSBgfCR7cm93fXxcXG5gO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFN0ZXAgNDogUmVwbGFjZSB0aGUgb2xkIHNlY3Rpb24gd2l0aCB0aGUgbmV3LCBtZXJnZWQgdGFibGVcbiAgICAgICAgICAgIG5ld0NvbnRlbnQgPSB0aGlzLmVuc3VyZUhlYWRpbmdBbmRTZWN0aW9uKG5ld0NvbnRlbnQsIHVzZWRCeUhlYWRpbmcsIGNsaWVudFRhYmxlTWQsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NvbnRlbnQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSB1cGRhdGVGcm9udG1hdHRlcihjb250ZW50OiBzdHJpbmcsIHVwZGF0ZXM6IHsgdGFncz86IHN0cmluZ1tdLCBhbGlhc2VzPzogc3RyaW5nW10gfSwgcGFnZU5hbWVGb3JBbGlhczogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IGZtOiBhbnkgPSB7fTtcbiAgICAgICAgY29uc3QgZm1SZWdleCA9IC9eLS0tXFxzKlxcbihbXFxzXFxTXSo/KVxcbi0tLVxccypcXG4vO1xuICAgICAgICBjb25zdCBtYXRjaCA9IGNvbnRlbnQubWF0Y2goZm1SZWdleCk7XG4gICAgICAgIGxldCBib2R5ID0gY29udGVudDtcblxuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gQmFzaWMgWUFNTCBwYXJzaW5nIC0gZm9yIG1vcmUgY29tcGxleCBZQU1MLCBhIGxpYnJhcnkgd291bGQgYmUgbmVlZGVkXG4gICAgICAgICAgICAgICAgY29uc3QgeWFtbExpbmVzID0gbWF0Y2hbMV0uc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIHlhbWxMaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwYXJ0c1swXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnRzLnNsaWNlKDEpLmpvaW4oJzonKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAndGFncycgfHwga2V5ID09PSAnYWxpYXNlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gcGFyc2UgYXMgYXJyYXkgaWYgaXQgbG9va3MgbGlrZSBvbmUsIG90aGVyd2lzZSB0cmVhdCBhcyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnWycpICYmIHZhbHVlLmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm1ba2V5XSA9IHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKS5zcGxpdCgnLCcpLm1hcChzID0+IHMudHJpbSgpLnJlcGxhY2UoL15bXCInXXxbXCInXSQvZywgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBTaW5nbGUgaXRlbSBub3QgaW4gbGlzdCBmb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm1ba2V5XSA9IFt2YWx1ZS5yZXBsYWNlKC9eW1wiJ118W1wiJ10kL2csICcnKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbVtrZXldID0gdmFsdWUucmVwbGFjZSgvXltcIiddfFtcIiddJC9nLCAnJyk7IC8vIFNpbXBsZSBzdHJpbmcgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlByb2Nlc3NvclByb2Nlc3NvcjogQ291bGQgbm90IHBhcnNlIGV4aXN0aW5nIGZyb250bWF0dGVyLCB3aWxsIG92ZXJ3cml0ZSByZWxldmFudCBrZXlzLlwiLCBlKTtcbiAgICAgICAgICAgICAgICBmbSA9IHt9OyAvLyBSZXNldCBpZiBwYXJzaW5nIGZhaWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5ID0gY29udGVudC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0YWdzXG4gICAgICAgIGlmICh1cGRhdGVzLnRhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUYWdzID0gbmV3IFNldChBcnJheS5pc0FycmF5KGZtLnRhZ3MpID8gZm0udGFncy5tYXAoKHQ6IHN0cmluZykgPT4gU3RyaW5nKHQpLnRvTG93ZXJDYXNlKCkpIDogW10pO1xuICAgICAgICAgICAgdXBkYXRlcy50YWdzLmZvckVhY2godGFnID0+IGN1cnJlbnRUYWdzLmFkZChTdHJpbmcodGFnKS50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICBmbS50YWdzID0gQXJyYXkuZnJvbShjdXJyZW50VGFncyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgYWxpYXNlcywgZW5zdXJpbmcgcGFnZU5hbWVGb3JBbGlhcyAoc2FuaXRpemVkKSBpcyBwcmVzZW50XG4gICAgICAgIGlmICh1cGRhdGVzLmFsaWFzZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBbGlhc2VzID0gbmV3IFNldChBcnJheS5pc0FycmF5KGZtLmFsaWFzZXMpID8gZm0uYWxpYXNlcy5tYXAoKGE6IHN0cmluZykgPT4gU3RyaW5nKGEpKSA6IFtdKTtcbiAgICAgICAgICAgIHVwZGF0ZXMuYWxpYXNlcy5mb3JFYWNoKGFsaWFzID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRBbGlhcyA9IFN0cmluZyhhbGlhcykucmVwbGFjZSgvWzpcXFtcXF0sXCJdL2csICcnKTsgLy8gU2FuaXRpemUgZm9yIFlBTUxcbiAgICAgICAgICAgICAgICBpZiAoc2FuaXRpemVkQWxpYXMpIGN1cnJlbnRBbGlhc2VzLmFkZChzYW5pdGl6ZWRBbGlhcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgbWFpbiBwYWdlTmFtZUZvckFsaWFzIChzYW5pdGl6ZWQpIGlzIGFsc28gcHJlc2VudCBhcyBhbiBhbGlhc1xuICAgICAgICAgICAgY29uc3Qgc2FuaXRpemVkUGFnZU5hbWVBbGlhcyA9IFN0cmluZyhwYWdlTmFtZUZvckFsaWFzKS5yZXBsYWNlKC9bOlxcW1xcXSxcIl0vZywgJycpO1xuICAgICAgICAgICAgaWYgKHNhbml0aXplZFBhZ2VOYW1lQWxpYXMpIGN1cnJlbnRBbGlhc2VzLmFkZChzYW5pdGl6ZWRQYWdlTmFtZUFsaWFzKTtcblxuICAgICAgICAgICAgZm0uYWxpYXNlcyA9IEFycmF5LmZyb20oY3VycmVudEFsaWFzZXMpO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBSZWNvbnN0cnVjdCBmcm9udG1hdHRlciBzdHJpbmdcbiAgICAgICAgbGV0IGZtU3RyaW5nID0gXCItLS1cXG5cIjtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZm0pIHtcbiAgICAgICAgICAgIGlmIChmbS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm1ba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZtW2tleV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm1TdHJpbmcgKz0gYCR7a2V5fTogWyR7Zm1ba2V5XS5tYXAoKGl0ZW06IHN0cmluZykgPT4gYFwiJHtpdGVtfVwiYCkuam9pbignLCAnKX1dXFxuYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZtU3RyaW5nICs9IGAke2tleX06IFwiJHtmbVtrZXldfVwiXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm1TdHJpbmcgKz0gXCItLS1cXG5cIjtcblxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gb3JpZ2luYWwgZnJvbnRtYXR0ZXIgYW5kIHdlIGRpZG4ndCBhY3R1YWxseSBhZGQgYW55IHZhbGlkIGZtLCBkb24ndCBwcmVwZW5kIGVtcHR5IGZtIGJsb2NrXG4gICAgICAgIGlmIChmbVN0cmluZyA9PT0gXCItLS1cXG4tLS1cXG5cIiAmJiAhbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZtU3RyaW5nICsgYm9keTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgYXN5bmMgdXBkYXRlQW5hbHlzaXNMb2dQYWdlKHByb2Nlc3Nvck5hbWU6IHN0cmluZywgcHJvY2Vzc2VkVXJsczogUHJvY2Vzc2VkVXJsSW5mb1tdLCByZWxhdGlvbnNoaXBzOiBFeHRyYWN0ZWRSZWxhdGlvbnNoaXBbXSwgbWVyZ2VEZWNpc2lvbnM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRm9sZGVyRXhpc3RzKHRoaXMuc2V0dGluZ3MuYW5hbHlzaXNMb2dzRm9sZGVyUGF0aCk7XG4gICAgICAgIGNvbnN0IHsgZmlsZVBhdGhOYW1lOiBzYW5pdGl6ZWRQcm9jZXNzb3JOYW1lRm9yTG9nRmlsZSB9ID0gdGhpcy5zYW5pdGl6ZU5hbWVGb3JGaWxlUGF0aEFuZEFsaWFzKHByb2Nlc3Nvck5hbWUpO1xuXG4gICAgICAgIGNvbnN0IGxvZ3NGb2xkZXIgPSB0aGlzLnNldHRpbmdzLmFuYWx5c2lzTG9nc0ZvbGRlclBhdGg7IC8vIE5vcm1hbGl6ZWRcbiAgICAgICAgY29uc3QgbG9nRmlsZU5hbWUgPSBgJHtzYW5pdGl6ZWRQcm9jZXNzb3JOYW1lRm9yTG9nRmlsZX0gU3VicHJvY2Vzc29yIExvZ3MubWRgOyAvLyBVc2Ugc2FuaXRpemVkIG5hbWVcbiAgICAgICAgY29uc3QgbG9nRmlsZVBhdGggPSBgJHtsb2dzRm9sZGVyfS8ke2xvZ0ZpbGVOYW1lfWA7XG5cbiAgICAgICAgY29uc3QgbG9nRW50cnlDb250ZW50ID0gdGhpcy5mb3JtYXRSZXN1bHRzRm9yT2JzaWRpYW5Mb2cocHJvY2Vzc29yTmFtZSwgcmVsYXRpb25zaGlwcywgcHJvY2Vzc2VkVXJscywgbWVyZ2VEZWNpc2lvbnMpO1xuXG4gICAgICAgIC8vIFVzZSBlbnN1cmVfZXhpc3RzX2FuZF9hcHBlbmQgbW9kZS4gVGhlIHRpdGxlIGlzIGhhbmRsZWQgYnkgZm9ybWF0UmVzdWx0c0Zvck9ic2lkaWFuTG9nLlxuICAgICAgICBhd2FpdCB0aGlzLndyaXRlUmVzdWx0c1RvT2JzaWRpYW5Ob3RlKGxvZ0ZpbGVQYXRoLCBsb2dFbnRyeUNvbnRlbnQsICdlbnN1cmVfZXhpc3RzX2FuZF9hcHBlbmQnLCBwcm9jZXNzb3JOYW1lKTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgZW5zdXJlSGVhZGluZ0FuZFNlY3Rpb24oXG4gICAgICAgIGNvbnRlbnQ6IHN0cmluZyxcbiAgICAgICAgaGVhZGluZ1RleHQ6IHN0cmluZyxcbiAgICAgICAgc2VjdGlvbk5ld0NvbnRlbnQ6IHN0cmluZyxcbiAgICAgICAgc3RhcnRNYXJrZXI6IHN0cmluZyB8IG51bGwgPSBudWxsLCAvLyBlLmcuLCA8IS0tIFNUQVJUOiBTVUJQUk9DRVNTT1JTIC0tPlxuICAgICAgICBlbmRNYXJrZXI6IHN0cmluZyB8IG51bGwgPSBudWxsLCAgIC8vIGUuZy4sIDwhLS0gRU5EOiBTVUJQUk9DRVNTT1JTIC0tPlxuICAgICAgICBhcHBlbmRVbmRlckhlYWRpbmdJZk5vTWFya2VycyA9IGZhbHNlIC8vIElmIHRydWUgYW5kIG1hcmtlcnMgbm90IGZvdW5kLCBhcHBlbmRzIHVuZGVyIGV4aXN0aW5nIGhlYWRpbmcgaWYgZm91bmRcbiAgICApOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBoZWFkaW5nUmVnZXggPSBuZXcgUmVnRXhwKGBeKCMrKVxcXFxzKiR7aGVhZGluZ1RleHQucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKX0oXFxcXHMqXFxcXG58JClgLCBcImltXCIpO1xuICAgICAgICBjb25zdCBoZWFkaW5nTWF0Y2ggPSBjb250ZW50Lm1hdGNoKGhlYWRpbmdSZWdleCk7XG4gICAgICAgIGNvbnN0IHNlY3Rpb25XaXRoSGVhZGluZyA9IGBcXG4jIyAke2hlYWRpbmdUZXh0fVxcbiR7c2VjdGlvbk5ld0NvbnRlbnQudHJpbSgpfVxcbmA7XG5cbiAgICAgICAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRJZHggPSBjb250ZW50LmluZGV4T2Yoc3RhcnRNYXJrZXIpO1xuICAgICAgICAgICAgY29uc3QgZW5kSWR4ID0gY29udGVudC5pbmRleE9mKGVuZE1hcmtlcik7XG5cbiAgICAgICAgICAgIGlmIChzdGFydElkeCAhPT0gLTEgJiYgZW5kSWR4ICE9PSAtMSAmJiBzdGFydElkeCA8IGVuZElkeCkge1xuICAgICAgICAgICAgICAgIC8vIE1hcmtlcnMgZm91bmQsIHJlcGxhY2UgY29udGVudCBiZXR3ZWVuIHRoZW0gKGV4Y2x1c2l2ZSBvZiBtYXJrZXJzIHRoZW1zZWx2ZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQuc3Vic3RyaW5nKDAsIHN0YXJ0SWR4ICsgc3RhcnRNYXJrZXIubGVuZ3RoKSArXG4gICAgICAgICAgICAgICAgICAgICAgIGBcXG4ke3NlY3Rpb25OZXdDb250ZW50LnRyaW0oKX1cXG5gICsgLy8gRW5zdXJlIG5ldyBjb250ZW50IGlzIG9uIG5ldyBsaW5lc1xuICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LnN1YnN0cmluZyhlbmRJZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFya2VycyBub3QgdXNlZCBvciBub3QgZm91bmQsIHRyeSB0byBmaW5kIGhlYWRpbmdcbiAgICAgICAgaWYgKGhlYWRpbmdNYXRjaCkge1xuICAgICAgICAgICAgLy8gSGVhZGluZyBmb3VuZFxuICAgICAgICAgICAgY29uc3QgaGVhZGluZ0xldmVsID0gaGVhZGluZ01hdGNoWzFdLmxlbmd0aDsgLy8gZS5nLiwgXCIjI1wiIC0+IGxlbmd0aCAyXG4gICAgICAgICAgICBjb25zdCBuZXh0SGVhZGluZ1JlZ2V4ID0gbmV3IFJlZ0V4cChgXiN7MSwke2hlYWRpbmdMZXZlbH19XFxcXHMrLiooXFxcXHMqXFxcXG58JClgLCBcImltXCIpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXhBZnRlckhlYWRpbmcgPSBoZWFkaW5nTWF0Y2guaW5kZXghICsgaGVhZGluZ01hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBjb250ZW50QWZ0ZXJIZWFkaW5nID0gY29udGVudC5zdWJzdHJpbmcoc3RhcnRJbmRleEFmdGVySGVhZGluZyk7XG4gICAgICAgICAgICBsZXQgZW5kSW5kZXggPSBjb250ZW50Lmxlbmd0aDsgLy8gRGVmYXVsdCB0byBlbmQgb2YgY29udGVudFxuXG4gICAgICAgICAgICAvLyBGaW5kIHdoZXJlIHRoZSBjdXJyZW50IHNlY3Rpb24gZW5kcyAoc3RhcnQgb2YgbmV4dCBoZWFkaW5nIG9mIHNhbWUgb3IgaGlnaGVyIGxldmVsLCBvciBlbmQgb2YgZG9jKVxuICAgICAgICAgICAgY29uc3QgbmV4dE1hdGNoID0gY29udGVudEFmdGVySGVhZGluZy5tYXRjaChuZXh0SGVhZGluZ1JlZ2V4KTtcbiAgICAgICAgICAgIGlmIChuZXh0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBlbmRJbmRleCA9IHN0YXJ0SW5kZXhBZnRlckhlYWRpbmcgKyBuZXh0TWF0Y2guaW5kZXghO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXBwZW5kVW5kZXJIZWFkaW5nSWZOb01hcmtlcnMpIHtcbiAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIG5ldyBjb250ZW50IHVuZGVyIHRoZSBleGlzdGluZyBoZWFkaW5nLCBiZWZvcmUgdGhlIG5leHQgb25lLlxuICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRyaWNreSBpZiB0aGUgc2VjdGlvbiBhbHJlYWR5IGhhcyBjb250ZW50LiBUaGlzIHNpbXBsZSBhcHBlbmQgYWRkcyB0byB0aGUgZW5kIG9mIHRoZSBzZWN0aW9uLlxuICAgICAgICAgICAgICAgICAvLyBGb3IgZnVsbCByZXBsYWNlbWVudCwgdGhlIGxvZ2ljIG91dHNpZGUgdGhpcyBgaWZgIGhhbmRsZXMgaXQuXG4gICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50LnN1YnN0cmluZygwLCBlbmRJbmRleCkgKyAvLyBDb250ZW50IHVwIHRvIHdoZXJlIG5leHQgc2VjdGlvbiB3b3VsZCBzdGFydCAob3IgZW5kIG9mIGRvYylcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXG4ke3NlY3Rpb25OZXdDb250ZW50LnRyaW0oKX1cXG5gICsgLy8gQXBwZW5kIG5ldyBzdHVmZlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudC5zdWJzdHJpbmcoZW5kSW5kZXgpOyAgICAgIC8vIFJlc3Qgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGNvbnRlbnQgZnJvbSBhZnRlciB0aGUgaGVhZGluZ01hdGNoIHRvIHdoZXJlIHRoZSBuZXh0IGhlYWRpbmcvZW5kIG9mIGRvYyBzdGFydHNcbiAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQuc3Vic3RyaW5nKDAsIHN0YXJ0SW5kZXhBZnRlckhlYWRpbmcpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke3NlY3Rpb25OZXdDb250ZW50LnRyaW0oKX1cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuc3Vic3RyaW5nKGVuZEluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSGVhZGluZyBub3QgZm91bmQsIGFwcGVuZCB0aGUgbmV3IGhlYWRpbmcgYW5kIHNlY3Rpb24gdG8gdGhlIGVuZFxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQudHJpbUVuZCgpICsgXCJcXG5cXG5cIiArIHNlY3Rpb25XaXRoSGVhZGluZy50cmltU3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBmb3JtYXRSZXN1bHRzRm9yT2JzaWRpYW5Mb2cocHJvY2Vzc29yTmFtZTogc3RyaW5nLCByZWxhdGlvbnNoaXBzOiBFeHRyYWN0ZWRSZWxhdGlvbnNoaXBbXSwgcHJvY2Vzc2VkVXJsczogUHJvY2Vzc2VkVXJsSW5mb1tdLCBtZXJnZURlY2lzaW9uczogc3RyaW5nW10gPSBbXSk6IHN0cmluZyB7XG4gICAgICAgIGxldCBsb2dDb250ZW50ID0gYFxcbi0tLVxcbiMjIyBMb2cgRW50cnk6ICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfSBmb3IgJHtwcm9jZXNzb3JOYW1lfVxcblxcbmA7XG5cbiAgICAgICAgaWYgKG1lcmdlRGVjaXNpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxvZ0NvbnRlbnQgKz0gYCMjIyMgUHJvYWN0aXZlIERlZHVwbGljYXRpb24gRGVjaXNpb25zICgke21lcmdlRGVjaXNpb25zLmxlbmd0aH0pOlxcbmA7XG4gICAgICAgICAgICBtZXJnZURlY2lzaW9ucy5mb3JFYWNoKGRlY2lzaW9uID0+IHtcbiAgICAgICAgICAgICAgICBsb2dDb250ZW50ICs9IGAtICR7ZGVjaXNpb259XFxuYDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9nQ29udGVudCArPSBcIlxcblwiO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nQ29udGVudCArPSBgIyMjIyBQcm9jZXNzZWQgVVJMcyAoJHtwcm9jZXNzZWRVcmxzLmxlbmd0aH0pOlxcbmA7XG4gICAgICAgIGlmIChwcm9jZXNzZWRVcmxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nQ29udGVudCArPSBcIi0gTm8gVVJMcyB3ZXJlIHByb2Nlc3NlZC5cXG5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0NvbnRlbnQgKz0gXCJ8IFVSTCB8IFRpdGxlIHwgVHlwZSB8IFZlcmlmaWVkIExpc3Q/IHwgQ3VycmVudD8gfCBFeHRyYWN0ZWQgIyB8IFJlYXNvbmluZyB8XFxuXCI7XG4gICAgICAgICAgICBsb2dDb250ZW50ICs9IFwifC0tLXwtLS18LS0tfC0tLXwtLS18LS0tfC0tLXxcXG5cIjtcbiAgICAgICAgICAgIHByb2Nlc3NlZFVybHMuZm9yRWFjaCh1cmwgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpdGxlRGlzcGxheSA9IHRoaXMuc2NydWJIeXBlcmxpbmtzKHVybC50aXRsZSB8fCBcIk4vQVwiKS5zdWJzdHJpbmcoMCwgNzApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybExpbmsgPSB1cmwudXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpID8gYFtMaW5rXSgke3VybC51cmx9KWAgOiB1cmwudXJsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYXNvbmluZ0Rpc3BsYXkgPSB0aGlzLnNjcnViSHlwZXJsaW5rcyh1cmwudmVyaWZpY2F0aW9uUmVhc29uaW5nIHx8IFwiTi9BXCIpLnN1YnN0cmluZygwLCAxMDApO1xuICAgICAgICAgICAgICAgIGxvZ0NvbnRlbnQgKz0gYHwgJHt1cmxMaW5rfSB8ICR7dGl0bGVEaXNwbGF5fS4uLiB8ICR7dXJsLmRvY3VtZW50VHlwZSB8fCAnTi9BJ30gfCAke3VybC5pc0xpc3QgPyAnWWVzJyA6ICdObyd9IHwgJHt1cmwuaXNDdXJyZW50ID8gJ1llcycgOiAnTm8nfSB8ICR7dXJsLmV4dHJhY3RlZFN1YnByb2Nlc3NvcnNDb3VudCB8fCAwfSB8ICR7cmVhc29uaW5nRGlzcGxheX0uLi4gfFxcbmA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dDb250ZW50ICs9IFwiXFxuXCI7XG5cbiAgICAgICAgbG9nQ29udGVudCArPSBgIyMjIyBFeHRyYWN0ZWQgUmVsYXRpb25zaGlwcyAoJHtyZWxhdGlvbnNoaXBzLmxlbmd0aH0pOlxcbmA7XG4gICAgICAgIGlmIChyZWxhdGlvbnNoaXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nQ29udGVudCArPSBcIi0gTm8gbmV3IHJlbGF0aW9uc2hpcHMgd2VyZSBleHRyYWN0ZWQgaW4gdGhpcyBydW4uXFxuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dDb250ZW50ICs9IFwifCBQcmltYXJ5IFByb2Nlc3NvciB8IFRhcmdldCBFbnRpdHkgfCBUeXBlIHwgRnVuY3Rpb24gfCBMb2NhdGlvbiB8IFNvdXJjZSBVUkwgfFxcblwiO1xuICAgICAgICAgICAgbG9nQ29udGVudCArPSBcInwtLS18LS0tfC0tLXwtLS18LS0tfC0tLXxcXG5cIjtcbiAgICAgICAgICAgIHJlbGF0aW9uc2hpcHMuZm9yRWFjaChyZWwgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEVudGl0eURpc3BsYXkgPSB0aGlzLnNjcnViSHlwZXJsaW5rcyhyZWwuU3VicHJvY2Vzc29yTmFtZSkuc3Vic3RyaW5nKDAsIDUwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmltYXJ5UHJvY0Rpc3BsYXkgPSB0aGlzLnNjcnViSHlwZXJsaW5rcyhyZWwuUHJpbWFyeVByb2Nlc3Nvcikuc3Vic3RyaW5nKDAsIDUwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmdW5jRGlzcGxheSA9IHRoaXMuc2NydWJIeXBlcmxpbmtzKHJlbC5Qcm9jZXNzaW5nRnVuY3Rpb24pLnN1YnN0cmluZygwLCA3MCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jRGlzcGxheSA9IHRoaXMuc2NydWJIeXBlcmxpbmtzKHJlbC5Mb2NhdGlvbikuc3Vic3RyaW5nKDAsIDUwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VVcmxMaW5rID0gcmVsLlNvdXJjZVVSTC5zdGFydHNXaXRoKFwiaHR0cFwiKSA/IGBbU291cmNlXSgke3JlbC5Tb3VyY2VVUkx9KWAgOiByZWwuU291cmNlVVJMO1xuXG4gICAgICAgICAgICAgICAgbG9nQ29udGVudCArPSBgfCAke3ByaW1hcnlQcm9jRGlzcGxheX0gfCAke3RhcmdldEVudGl0eURpc3BsYXl9IHwgJHtyZWwuUmVsYXRpb25zaGlwVHlwZX0gfCAke2Z1bmNEaXNwbGF5fS4uLiB8ICR7bG9jRGlzcGxheX0uLi4gfCAke3NvdXJjZVVybExpbmt9IHxcXG5gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nQ29udGVudCArPSBcIlxcblwiO1xuICAgICAgICByZXR1cm4gbG9nQ29udGVudDtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgYXN5bmMgd3JpdGVSZXN1bHRzVG9PYnNpZGlhbk5vdGUoXG4gICAgICAgIGZpbGVQYXRoOiBzdHJpbmcsIC8vIEZ1bGwgcGF0aCBmcm9tIHZhdWx0IHJvb3QsIGUuZy4sIFwiQW5hbHlzaXMgTG9ncy9PcGVuQUkgTG9ncy5tZFwiXG4gICAgICAgIGNvbnRlbnRUb0FwcGVuZE9ySW5pdGlhbDogc3RyaW5nLFxuICAgICAgICBtb2RlOiAnb3ZlcndyaXRlJyB8ICdhcHBlbmQnIHwgJ2Vuc3VyZV9leGlzdHNfYW5kX2FwcGVuZCcgPSAnZW5zdXJlX2V4aXN0c19hbmRfYXBwZW5kJyxcbiAgICAgICAgcHJvY2Vzc29yTmFtZUZvckxvZ1RpdGxlPzogc3RyaW5nIC8vIFVzZWQgaWYgY3JlYXRpbmcgdGhlIGZpbGVcbiAgICApIHtcbiAgICAgICAgbGV0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZVBhdGgpIGFzIFRGaWxlO1xuXG4gICAgICAgIGlmICghZmlsZSAmJiAobW9kZSA9PT0gJ2Vuc3VyZV9leGlzdHNfYW5kX2FwcGVuZCcgfHwgbW9kZSA9PT0gJ292ZXJ3cml0ZScpKSB7XG4gICAgICAgICAgICAvLyBGaWxlIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdFxuICAgICAgICAgICAgbGV0IGluaXRpYWxDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzb3JOYW1lRm9yTG9nVGl0bGUpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsQ29udGVudCArPSBgIyBBbmFseXNpcyBMb2c6ICR7cHJvY2Vzc29yTmFtZUZvckxvZ1RpdGxlfVxcblxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbml0aWFsQ29udGVudCArPSBjb250ZW50VG9BcHBlbmRPckluaXRpYWw7IC8vIEFkZCB0aGUgY3VycmVudCBsb2cgZW50cnlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZmlsZSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShmaWxlUGF0aCwgaW5pdGlhbENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coYExvZyBmaWxlIGNyZWF0ZWQ6ICR7ZmlsZVBhdGh9YCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgaWYgKGUubWVzc2FnZT8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImZpbGUgYWxyZWFkeSBleGlzdHNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmaWxlUGF0aCkgYXMgVEZpbGU7XG4gICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGUpIHsgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGdldCBsb2cgZmlsZSAke2ZpbGVQYXRofSBhZnRlciAnYWxyZWFkeSBleGlzdHMnIGVycm9yLmApOyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICAgICAgICAvLyBOb3cgdGhhdCBmaWxlIGV4aXN0cywgcHJvY2VlZCB0byBhcHBlbmQvcHJvY2VzcyBpZiBtb2RlIGlzIGVuc3VyZV9leGlzdHNfYW5kX2FwcGVuZFxuICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjcmVhdGluZyBsb2cgZmlsZSAke2ZpbGVQYXRofTpgLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgRXJyb3IgY3JlYXRpbmcgbG9nIGZpbGU6ICR7ZmlsZVBhdGh9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gU3RvcCBpZiBjcmVhdGlvbiBmYWlsc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBpZiAoZmlsZSAmJiBtb2RlID09PSAnZW5zdXJlX2V4aXN0c19hbmRfYXBwZW5kJykgeyAvKiBGaWxlIGNyZWF0ZWQgd2l0aCBjb250ZW50LCBubyBmdXJ0aGVyIGFjdGlvbiBmb3IgdGhpcyBjYWxsICovIHJldHVybjsgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvLyBJZiBmaWxlIGV4aXN0cyAob3Igd2FzIGp1c3QgY3JlYXRlZCBhbmQgbW9kZSBpcyBub3QgJ2Vuc3VyZV9leGlzdHNfYW5kX2FwcGVuZCcgd2hlcmUgY29udGVudCB3YXMgaW5pdGlhbClcbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAnb3ZlcndyaXRlJykge1xuICAgICAgICAgICAgICAgIGxldCBuZXdDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc29yTmFtZUZvckxvZ1RpdGxlKSB7IC8vIEtlZXAgdGhlIHRpdGxlIGlmIG92ZXJ3cml0aW5nXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQgKz0gYCMgQW5hbHlzaXMgTG9nOiAke3Byb2Nlc3Nvck5hbWVGb3JMb2dUaXRsZX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdDb250ZW50ICs9IGNvbnRlbnRUb0FwcGVuZE9ySW5pdGlhbDtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZmlsZSwgbmV3Q29udGVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgTG9nIGZpbGUgb3ZlcndyaXR0ZW46ICR7ZmlsZVBhdGh9YCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdhcHBlbmQnIHx8IChtb2RlID09PSAnZW5zdXJlX2V4aXN0c19hbmRfYXBwZW5kJyAmJiBmaWxlKSkgeyAvLyBBcHBlbmQgaWYgbW9kZSBpcyBhcHBlbmQgb3IgKGVuc3VyZV9leGlzdHNfYW5kX2FwcGVuZCBhbmQgZmlsZSBhbHJlYWR5IGV4aXN0ZWQpXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuYXBwZW5kKGZpbGUsIGNvbnRlbnRUb0FwcGVuZE9ySW5pdGlhbCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgQ29udGVudCBhcHBlbmRlZCB0byBsb2cgZmlsZTogJHtmaWxlUGF0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnYXBwZW5kJykge1xuICAgICAgICAgICAgLy8gRmlsZSBkb2Vzbid0IGV4aXN0IGFuZCBtb2RlIGlzICdhcHBlbmQnIChzdHJpY3QgYXBwZW5kLCBub3QgY3JlYXRlKVxuICAgICAgICAgICAgbmV3IE5vdGljZShgTG9nIGZpbGUgJHtmaWxlUGF0aH0gbm90IGZvdW5kLiBDYW5ub3QgYXBwZW5kLmApO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgTG9nIGZpbGUgbm90IGZvdW5kIGZvciBhcHBlbmQ6ICR7ZmlsZVBhdGh9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGFzeW5jIGdldFJpZ2h0QnJhaW5BY2Nlc3NUb2tlbihjcmVkcz86IHsgY2xpZW50SWQ6IHN0cmluZywgY2xpZW50U2VjcmV0OiBzdHJpbmcsIG9hdXRoVXJsOiBzdHJpbmcgfSk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgICAgICAvLyBVc2UgdGhlIHBhc3NlZC1pbiBjcmVkZW50aWFscyBpZiB0aGV5IGV4aXN0LCBvdGhlcndpc2UgdXNlIHRoZSBzYXZlZCBzZXR0aW5ncy5cbiAgICAgICAgY29uc3QgY2xpZW50SWQgPSBjcmVkcz8uY2xpZW50SWQgfHwgdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluQ2xpZW50SWQ7XG4gICAgICAgIGNvbnN0IGNsaWVudFNlY3JldCA9IGNyZWRzPy5jbGllbnRTZWNyZXQgfHwgdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluQ2xpZW50U2VjcmV0O1xuICAgICAgICBjb25zdCBvYXV0aFVybCA9IGNyZWRzPy5vYXV0aFVybCB8fCB0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5PYXV0aDJVcmw7XG5cbiAgICAgICAgaWYgKCFjbGllbnRJZCB8fCAhY2xpZW50U2VjcmV0KSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiUmlnaHRCcmFpbiBDbGllbnQgSUQgb3IgU2VjcmV0IG5vdCBjb25maWd1cmVkLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBjYWNoZWQgdG9rZW4gZmlyc3RcbiAgICAgICAgaWYgKCh0aGlzIGFzIGFueSkuX3JiVG9rZW4gJiYgKHRoaXMgYXMgYW55KS5fcmJUb2tlbkV4cGlyeSA+IERhdGUubm93KCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coXCJVc2luZyBjYWNoZWQgUmlnaHRCcmFpbiB0b2tlbi5cIik7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMgYXMgYW55KS5fcmJUb2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRva2VuVXJsID0gYCR7b2F1dGhVcmx9L29hdXRoMi90b2tlbmA7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBib2R5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBib2R5UGFyYW1zLmFwcGVuZCgnZ3JhbnRfdHlwZScsICdjbGllbnRfY3JlZGVudGlhbHMnKTtcblxuICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IGAke2NsaWVudElkfToke2NsaWVudFNlY3JldH1gO1xuICAgICAgICBjb25zdCBlbmNvZGVkQ3JlZGVudGlhbHMgPSBidG9hKGNyZWRlbnRpYWxzKTsgXG5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJhc2ljICR7ZW5jb2RlZENyZWRlbnRpYWxzfWAsXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAnVXNlci1BZ2VudCc6IGBPYnNpZGlhblByb2Nlc3NvclByb2Nlc3NvclBsdWdpbi8ke3RoaXMubWFuaWZlc3QudmVyc2lvbn1gXG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coXCJSZXF1ZXN0aW5nIG5ldyBSaWdodEJyYWluIHRva2VuLlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0b2tlblVybCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlQYXJhbXMudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB0aHJvdzogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgJiYgcmVzcG9uc2UuanNvbiAmJiByZXNwb25zZS5qc29uLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coXCJTdWNjZXNzZnVsbHkgb2J0YWluZWQgbmV3IFJpZ2h0QnJhaW4gdG9rZW4uXCIpO1xuICAgICAgICAgICAgICAgICh0aGlzIGFzIGFueSkuX3JiVG9rZW4gPSByZXNwb25zZS5qc29uLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICAgICAgICAodGhpcyBhcyBhbnkpLl9yYlRva2VuRXhwaXJ5ID0gRGF0ZS5ub3coKSArIChyZXNwb25zZS5qc29uLmV4cGlyZXNfaW4gfHwgMzYwMCkgKiAxMDAwIC0gNjAwMDAwO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlByb2Nlc3NvclByb2Nlc3NvcjogRmFpbGVkIHRvIGdldCBSaWdodEJyYWluIHRva2VuLlwiLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnRleHQpO1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYEZhaWxlZCB0byBnZXQgUmlnaHRCcmFpbiB0b2tlbjogJHtyZXNwb25zZS5zdGF0dXN9LmApO1xuICAgICAgICAgICAgICAgICh0aGlzIGFzIGFueSkuX3JiVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgICh0aGlzIGFzIGFueSkuX3JiVG9rZW5FeHBpcnkgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlByb2Nlc3NvclByb2Nlc3NvcjogTmV0d29yayBlcnJvciBmZXRjaGluZyBSaWdodEJyYWluIHRva2VuOlwiLCBlcnJvcik7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiTmV0d29yayBlcnJvciBmZXRjaGluZyBSaWdodEJyYWluIHRva2VuLlwiKTtcbiAgICAgICAgICAgICh0aGlzIGFzIGFueSkuX3JiVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgKHRoaXMgYXMgYW55KS5fcmJUb2tlbkV4cGlyeSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZVNlYXJjaFF1ZXJpZXMocHJvY2Vzc29yTmFtZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgICAgICAvLyBTYW5pdGl6ZSBwcm9jZXNzb3JOYW1lIGZvciB1c2UgaW4gcXVlcmllcyAoZS5nLiwgcmVtb3ZlIFwiSW5jLlwiLCBcIkxMQ1wiKVxuICAgICAgICBjb25zdCBjbGVhbmVkTmFtZSA9IHByb2Nlc3Nvck5hbWVcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXGIoPzppbmNcXC4/fGxsY1xcLj98bHRkXFwuP3xjb3JwXFwuP3xnbWJoXFwuP3xpbmNvcnBvcmF0ZWR8bGltaXRlZHxjb3Jwb3JhdGlvbilcXGIvZ2ksICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1ssLl0vZywgJycpIC8vIFJlbW92ZSBjb21tYXMgYW5kIHBlcmlvZHMgdGhhdCBtaWdodCBicmVhayBzZWFyY2hcbiAgICAgICAgICAgIC50cmltKCk7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGBcIiR7Y2xlYW5lZE5hbWV9XCIgc3ViLXByb2Nlc3NvciBsaXN0YCxcbiAgICAgICAgICAgIGBcIiR7Y2xlYW5lZE5hbWV9XCIgc3VicHJvY2Vzc29yc2AsXG4gICAgICAgICAgICBgXCIke2NsZWFuZWROYW1lfVwiIGRhdGEgcHJvY2Vzc2luZyBhZGRlbmR1bSBleGhpYml0YCxcbiAgICAgICAgICAgIGBcIiR7Y2xlYW5lZE5hbWV9XCIgRFBBIHN1YnByb2Nlc3NvcnNgLFxuICAgICAgICAgICAgYFwiJHtjbGVhbmVkTmFtZX1cIiB0aGlyZC1wYXJ0eSB2ZW5kb3JzYCxcbiAgICAgICAgICAgIGBcIiR7Y2xlYW5lZE5hbWV9XCIgc2VydmljZSBwcm92aWRlcnMgbGlzdGAsXG4gICAgICAgICAgICAvLyBNb3JlIGdlbmVyaWMgYnV0IHNvbWV0aW1lcyB1c2VmdWwgZm9yIGZpbmRpbmcgcG9ydGFsc1xuICAgICAgICAgICAgYFwiJHtjbGVhbmVkTmFtZX1cIiB0cnVzdCBjZW50ZXIgc3VicHJvY2Vzc29yc2AsXG4gICAgICAgICAgICBgXCIke2NsZWFuZWROYW1lfVwiIGxlZ2FsIHN1YnByb2Nlc3NvcnNgLFxuICAgICAgICAgICAgLy8gSWYgdGhlIG5hbWUgaXMgc2hvcnQsIGJyb2FkIHNlYXJjaGVzIG1pZ2h0IGJlIHRvbyBub2lzeS5cbiAgICAgICAgICAgIC8vIENvbnNpZGVyIGFkZGluZyBxdW90ZXMgYXJvdW5kIGNsZWFuZWROYW1lIGlmIGl0IGNvbnRhaW5zIHNwYWNlcy5cbiAgICAgICAgXTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgYXN5bmMgc2VhcmNoU2VycEFwaUZvckRwYXMocHJvY2Vzc29yTmFtZTogc3RyaW5nLCBxdWVyaWVzOiBzdHJpbmdbXSwgbWF4UmVzdWx0c1NldHRpbmc6IG51bWJlcik6IFByb21pc2U8U2VycEFwaVJlc3VsdFtdPiB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5zZXJwQXBpS2V5KSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiU2VycEFQSSBrZXkgbm90IHNldC4gQ2Fubm90IHBlcmZvcm0gU2VycEFQSSBzZWFyY2guXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWxsUmVzdWx0czogU2VycEFwaVJlc3VsdFtdID0gW107XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZFVybHMgPSBuZXcgU2V0PHN0cmluZz4oKTsgLy8gVG8gYXZvaWQgZHVwbGljYXRlIFVSTHMgZnJvbSBkaWZmZXJlbnQgcXVlcmllc1xuXG4gICAgICAgIC8vIFVzZSBhIHNtYWxsZXIgbnVtYmVyIG9mIHF1ZXJpZXMgZm9yIFNlcnBBUEkgdG8gbWFuYWdlIGNvc3QvcmF0ZSBsaW1pdHNcbiAgICAgICAgY29uc3QgcXVlcmllc1RvUnVuID0gcXVlcmllcy5zbGljZSgwLCBNYXRoLm1pbihxdWVyaWVzLmxlbmd0aCwgMykpOyAvLyBlLmcuLCBydW4gZmlyc3QgMyBxdWVyaWVzXG5cbiAgICAgICAgbmV3IE5vdGljZShgU2VhcmNoaW5nIFNlcnBBUEkgZm9yICR7cHJvY2Vzc29yTmFtZX0gdXNpbmcgJHtxdWVyaWVzVG9SdW4ubGVuZ3RofSBxdWVyaWVzLi4uYCwgMzAwMCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBxdWVyeSBvZiBxdWVyaWVzVG9SdW4pIHtcbiAgICAgICAgICAgIGlmIChhbGxSZXN1bHRzLmxlbmd0aCA+PSBtYXhSZXN1bHRzU2V0dGluZyAmJiBtYXhSZXN1bHRzU2V0dGluZyA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBNYXggcmVzdWx0cyAoJHttYXhSZXN1bHRzU2V0dGluZ30pIHJlYWNoZWQgZm9yICR7cHJvY2Vzc29yTmFtZX0sIHN0b3BwaW5nIFNlcnBBUEkgc2VhcmNoLmApO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBTdG9wIGlmIHdlJ3ZlIGhpdCB0aGUgb3ZlcmFsbCBtYXggcmVzdWx0cyBkZXNpcmVkICh0aG91Z2ggbG9naWMgaXMgMSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgYXBpX2tleTogdGhpcy5zZXR0aW5ncy5zZXJwQXBpS2V5LFxuICAgICAgICAgICAgICAgIHE6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGVuZ2luZTogXCJnb29nbGVcIiwgLy8gT3Igb3RoZXIgZW5naW5lcyBsaWtlICdiaW5nJ1xuICAgICAgICAgICAgICAgIG51bTogXCIxMFwiLCAvLyBOdW1iZXIgb2YgcmVzdWx0cyBwZXIgcXVlcnkgKG1heCAxMDAgZm9yIEdvb2dsZSwgdXN1YWxseSAxMC0yMCBpcyBmaW5lKVxuICAgICAgICAgICAgICAgIC8vIFlvdSBjYW4gYWRkIG90aGVyIHBhcmFtcyBsaWtlICdsb2NhdGlvbicsICdnbCcgKGNvdW50cnkpLCAnaGwnIChsYW5ndWFnZSkgaWYgbmVlZGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNlcnBBcGlVcmwgPSBgaHR0cHM6Ly9zZXJwYXBpLmNvbS9zZWFyY2g/JHtwYXJhbXMudG9TdHJpbmcoKX1gO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybCh7IHVybDogc2VycEFwaVVybCwgbWV0aG9kOiAnR0VUJywgdGhyb3c6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCAmJiByZXNwb25zZS5qc29uICYmIHJlc3BvbnNlLmpzb24ub3JnYW5pY19yZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yZ2FuaWNSZXN1bHRzID0gcmVzcG9uc2UuanNvbi5vcmdhbmljX3Jlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIG9yZ2FuaWNSZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmxpbmsgJiYgIXByb2Nlc3NlZFVybHMuaGFzKHJlc3VsdC5saW5rKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybExvd2VyID0gcmVzdWx0LmxpbmsudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aXRsZUxvd2VyID0gcmVzdWx0LnRpdGxlPy50b0xvd2VyQ2FzZSgpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc25pcHBldExvd2VyID0gcmVzdWx0LnNuaXBwZXQ/LnRvTG93ZXJDYXNlKCkgfHwgXCJcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhc2ljIGtleXdvcmQgY2hlY2sgaW4gVVJMLCB0aXRsZSwgb3Igc25pcHBldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVsZXZhbnQgPSBTVUJQUk9DRVNTT1JfVVJMX0tFWVdPUkRTLnNvbWUoa2V5d29yZCA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmxMb3dlci5pbmNsdWRlcyhrZXl3b3JkKSB8fCB0aXRsZUxvd2VyLmluY2x1ZGVzKGtleXdvcmQpIHx8IHNuaXBwZXRMb3dlci5pbmNsdWRlcyhrZXl3b3JkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWxldmFudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxSZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc29yTmFtZTogcHJvY2Vzc29yTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiByZXN1bHQudGl0bGUgfHwgXCJObyBUaXRsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiByZXN1bHQubGluayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNuaXBwZXQ6IHJlc3VsdC5zbmlwcGV0IHx8IFwiTm8gU25pcHBldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoUXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRUeXBlOiAnc2VycGFwaV9kcGFfb3Jfc3VicHJvY2Vzc29yX2xpc3RfY2FuZGlkYXRlJyAvLyBNYXJrIGFzIHBvdGVudGlhbCBjYW5kaWRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZFVybHMuYWRkKHJlc3VsdC5saW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbFJlc3VsdHMubGVuZ3RoID49IG1heFJlc3VsdHNTZXR0aW5nICYmIG1heFJlc3VsdHNTZXR0aW5nID4gMCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgU2VycEFQSSBlcnJvciBmb3IgcXVlcnkgXCIke3F1ZXJ5fVwiOiAke3Jlc3BvbnNlLnN0YXR1c31gLCByZXNwb25zZS50ZXh0Py5zdWJzdHJpbmcoMCwgMjAwKSk7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYFNlcnBBUEkgcXVlcnkgZmFpbGVkIGZvciBcIiR7cXVlcnkuc3Vic3RyaW5nKDAsMjApfS4uLlwiLiBTdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTmV0d29yayBlcnJvciBkdXJpbmcgU2VycEFQSSBzZWFyY2ggZm9yIHF1ZXJ5IFwiJHtxdWVyeX1cIjpgLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShgTmV0d29yayBlcnJvciBkdXJpbmcgU2VycEFQSSBzZWFyY2ggZm9yIFwiJHtxdWVyeS5zdWJzdHJpbmcoMCwyMCl9Li4uXCIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwICsgTWF0aC5yYW5kb20oKSAqIDMwMCkpOyAvLyBEZWxheSBiZXR3ZWVuIEFQSSBjYWxsc1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coYFNlcnBBUEkgc2VhcmNoIGZvciAke3Byb2Nlc3Nvck5hbWV9IGZvdW5kICR7YWxsUmVzdWx0cy5sZW5ndGh9IHJlbGV2YW50IGNhbmRpZGF0ZXMuYCk7XG4gICAgICAgIHJldHVybiBhbGxSZXN1bHRzO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBnZXRDb21wYW55RG9tYWluKHByb2Nlc3Nvck5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIC8vIEJhc2ljIGRvbWFpbiBleHRyYWN0aW9uIC0gdGhpcyBpcyBuYWl2ZSBhbmQgY2FuIGJlIGltcHJvdmVkLlxuICAgICAgICAvLyBJdCBhc3N1bWVzIHByb2Nlc3Nvck5hbWUgbWlnaHQgYmUgbGlrZSBcIkNvbXBhbnkgTmFtZSBJbmMuXCIgb3IgXCJjb21wYW55LmNvbVwiXG4gICAgICAgIGxldCBuYW1lID0gcHJvY2Vzc29yTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9cXGIoPzppbmNcXC4/fGxsY1xcLj98bHRkXFwuP3xjb3JwXFwuP3xnbWJoXFwuPylcXGIvZywgJycpLnRyaW0oKTsgLy8gUmVtb3ZlIGNvbW1vbiBzdWZmaXhlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bLC5dL2csICcnKTsgLy8gUmVtb3ZlIGNvbW1hcywgcGVyaW9kc1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBsb29rcyBsaWtlIGEgVVJMIGFscmVhZHlcbiAgICAgICAgICAgIGlmIChuYW1lLmluY2x1ZGVzKCcuJykgJiYgIW5hbWUuaW5jbHVkZXMoJyAnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwobmFtZS5zdGFydHNXaXRoKCdodHRwJykgPyBuYW1lIDogYGh0dHA6Ly8ke25hbWV9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybC5ob3N0bmFtZS5yZXBsYWNlKC9ed3d3XFwuLywgJycpOyAvLyBSZW1vdmUgd3d3LlxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7IC8qIE5vdCBhIHZhbGlkIFVSTCwgcHJvY2VlZCAqLyB9XG5cbiAgICAgICAgLy8gSWYgaXQncyBhIG11bHRpLXdvcmQgbmFtZSwgdHJ5IHRvIGZvcm0gYSBkb21haW4gKGUuZy4sIFwiQ29tcGFueSBOYW1lXCIgLT4gXCJjb21wYW55bmFtZS5jb21cIilcbiAgICAgICAgLy8gVGhpcyBpcyBoaWdobHkgc3BlY3VsYXRpdmUgYW5kIG9mdGVuIHdyb25nLlxuICAgICAgICAvLyBBIGJldHRlciBhcHByb2FjaCBpcyB0byBsb29rIGZvciBvZmZpY2lhbCB3ZWJzaXRlIGluIHNlYXJjaCByZXN1bHRzLlxuICAgICAgICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoL1xccysvKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBwYXJ0cy5qb2luKCcnKS50b0xvd2VyQ2FzZSgpICsgXCIuY29tXCI7IC8vIFZlcnkgbmFpdmVcbiAgICAgICAgICAgIHJldHVybiBcIlwiOyAvLyBCZXR0ZXIgdG8gbm90IGd1ZXNzIGlmIHVuc3VyZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lOyAvLyBJZiBzaW5nbGUgd29yZCwgYXNzdW1lIGl0IG1pZ2h0IGJlIHBhcnQgb2YgYSBkb21haW5cbiAgICB9XG5cblxuICAgIHByaXZhdGUgaXNWYWxpZFVybCh1cmw6IHN0cmluZywgcHJvY2Vzc29yTmFtZUNvbnRleHQ6IHN0cmluZyA9IFwiXCIpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCF1cmwgfHwgdHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgICAgIC8vIEFsbG93IGh0dHAgYW5kIGh0dHBzIHByb3RvY29sc1xuICAgICAgICAgICAgaWYgKCFbJ2h0dHA6JywgJ2h0dHBzOiddLmluY2x1ZGVzKHBhcnNlZFVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPcHRpb25hbDogY2hlY2sgaWYgZG9tYWluIHNlZW1zIHJlbGF0ZWQgdG8gcHJvY2Vzc29yTmFtZUNvbnRleHQgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmIChwcm9jZXNzb3JOYW1lQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NvckRvbWFpbiA9IHRoaXMuZ2V0Q29tcGFueURvbWFpbihwcm9jZXNzb3JOYW1lQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NvckRvbWFpbiAmJiAhcGFyc2VkVXJsLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocHJvY2Vzc29yRG9tYWluLnJlcGxhY2UoL153d3dcXC4vLCAnJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzb2Z0IGNoZWNrLCBtaWdodCBiZSB0b28gcmVzdHJpY3RpdmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coYFVSTCAke3VybH0gaG9zdG5hbWUgJHtwYXJzZWRVcmwuaG9zdG5hbWV9IGRvZXNuJ3QgbWF0Y2ggY29udGV4dCAke3Byb2Nlc3NvckRvbWFpbn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBJbnZhbGlkIFVSTCBmb3JtYXRcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBhc3luYyBleHRyYWN0VXJsc0Zyb21EcGFQYWdlKHBhZ2VVcmw6IHN0cmluZywgcHJvY2Vzc29yTmFtZUNvbnRleHQ6IHN0cmluZywgc291cmNlUGFnZVRpdGxlPzogc3RyaW5nKTogUHJvbWlzZTxTZXJwQXBpUmVzdWx0W10+IHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5WZXJpZnlVcmxUYXNrSWQpIHsgLy8gVXNpbmcgdmVyaWZ5IHRhc2sgSUQgYXMgYSBwcm94eSBmb3IgXCJSQiBpcyBjb25maWd1cmVkXCJcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coXCJSQiBub3QgY29uZmlndXJlZCwgc2tpcHBpbmcgVVJMIGV4dHJhY3Rpb24gZnJvbSBEUEEgcGFnZSBjb250ZW50LlwiKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYlRva2VuID0gYXdhaXQgdGhpcy5nZXRSaWdodEJyYWluQWNjZXNzVG9rZW4oKTtcbiAgICAgICAgaWYgKCFyYlRva2VuKSByZXR1cm4gW107XG5cbiAgICAgICAgY29uc3QgZXh0cmFjdGVkTGlua3M6IFNlcnBBcGlSZXN1bHRbXSA9IFtdO1xuXG4gICAgICAgIC8vIFRoaXMgd291bGQgaWRlYWxseSB1c2UgYSBSaWdodEJyYWluIHRhc2sgZGVzaWduZWQgdG8gZmV0Y2ggYSBwYWdlIGFuZCBleHRyYWN0IGFsbCA8YT4gaHJlZnMuXG4gICAgICAgIC8vIEZvciBub3csIGxldCdzIHNpbXVsYXRlIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHdoYXQgc3VjaCBhIHRhc2sgbWlnaHQgcmV0dXJuIGlmIHdlIHBhc3MgcGFnZVVybC5cbiAgICAgICAgLy8gQSBwcm9wZXIgUkIgdGFzayB3b3VsZCB0YWtlIGBwYWdlVXJsYCBhcyBpbnB1dCB0byBhIGB1cmxfZmV0Y2hlcmAgYW5kIHRoZW4gcGFyc2UgaXRzIEhUTUwgb3V0cHV0LlxuXG4gICAgICAgIC8vIFNpbXVsYXRlIGZldGNoaW5nIHBhZ2UgY29udGVudCAodmVyeSBiYXNpYywgbm90IHJvYnVzdClcbiAgICAgICAgbGV0IHBhZ2VDb250ZW50ID0gXCJcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybCh7dXJsOiBwYWdlVXJsLCBtZXRob2Q6ICdHRVQnLCB0aHJvdzogZmFsc2V9KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHBhZ2VDb250ZW50ID0gcmVzcG9uc2UudGV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBmZXRjaCAke3BhZ2VVcmx9IGZvciBsaW5rIGV4dHJhY3Rpb24sIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nICR7cGFnZVVybH0gZm9yIGxpbmsgZXh0cmFjdGlvbjpgLCBlKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFnZUNvbnRlbnQpIHJldHVybiBbXTtcblxuICAgICAgICAvLyBTaW1wbGUgcmVnZXggdG8gZmluZCBocmVmIGF0dHJpYnV0ZXMgaW4gPGE+IHRhZ3NcbiAgICAgICAgY29uc3QgbGlua1JlZ2V4ID0gLzxhXFxzKyg/OltePl0qP1xccyspP2hyZWY9XCIoW15cIl0qKVwiL2dpO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBsaW5rUmVnZXguZXhlYyhwYWdlQ29udGVudCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgaHJlZiA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChocmVmICYmICFocmVmLnN0YXJ0c1dpdGgoJyMnKSAmJiAhaHJlZi5zdGFydHNXaXRoKCdtYWlsdG86JykgJiYgIWhyZWYuc3RhcnRzV2l0aCgnamF2YXNjcmlwdDonKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFic29sdXRlVXJsID0gbmV3IFVSTChocmVmLCBwYWdlVXJsKS50b1N0cmluZygpOyAvLyBSZXNvbHZlIHJlbGF0aXZlIFVSTHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZFVybChhYnNvbHV0ZVVybCwgcHJvY2Vzc29yTmFtZUNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGxpbmsgaXRzZWxmIGxvb2tzIGxpa2UgYSBzdWJwcm9jZXNzb3IgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsTG93ZXIgPSBhYnNvbHV0ZVVybC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpdGxlT3JUZXh0TG93ZXIgPSAobWF0Y2hbMF0ubWF0Y2goLz4oLio/KTwvKT8uWzFdIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7IC8vIEdldCBsaW5rIHRleHRcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNQb3RlbnRpYWxTdWJwcm9jZXNzb3JMaXN0ID0gU1VCUFJPQ0VTU09SX1VSTF9LRVlXT1JEUy5zb21lKGtleXdvcmQgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmxMb3dlci5pbmNsdWRlcyhrZXl3b3JkKSB8fCB0aXRsZU9yVGV4dExvd2VyLmluY2x1ZGVzKGtleXdvcmQpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQb3RlbnRpYWxTdWJwcm9jZXNzb3JMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdGVkTGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Nvck5hbWU6IHByb2Nlc3Nvck5hbWVDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYExpbmtlZCBmcm9tOiAke3NvdXJjZVBhZ2VUaXRsZSB8fCBwYWdlVXJsfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYWJzb2x1dGVVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNuaXBwZXQ6IGBGb3VuZCBvbiBwYWdlOiAke3BhZ2VVcmx9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRUeXBlOiAnbGlua2VkX3N1YnByb2Nlc3Nvcl9saXN0X2NhbmRpZGF0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZURwYVVybDogcGFnZVVybFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJbnZhbGlkIFVSTCwgc2tpcCAqLyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnICYmIGV4dHJhY3RlZExpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKGBFeHRyYWN0ZWQgJHtleHRyYWN0ZWRMaW5rcy5sZW5ndGh9IHBvdGVudGlhbCBzdWJwcm9jZXNzb3IgbGlzdCBVUkxzIGZyb20gJHtwYWdlVXJsfWApO1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBleHRyYWN0ZWRMaW5rcztcbiAgICB9XG5cblxuICAgIHByaXZhdGUgYXN5bmMgY2FsbFJpZ2h0QnJhaW5UYXNrKHRhc2tJZDogc3RyaW5nLCB0YXNrVmFyaWFibGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCByYlRva2VuOiBzdHJpbmcpOiBQcm9taXNlPGFueSB8IG51bGw+IHtcbiAgICAgICAgaWYgKCF0YXNrSWQpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJSaWdodEJyYWluIFRhc2sgSUQgaXMgbWlzc2luZyBmb3IgdGhlIGNhbGwuXCIpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlByb2Nlc3NvclByb2Nlc3NvcjogQXR0ZW1wdGVkIHRvIGNhbGwgUmlnaHRCcmFpbiB0YXNrIHdpdGggbm8gVGFzayBJRC5cIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MucmlnaHRicmFpbk9yZ0lkIHx8ICF0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5Qcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJSaWdodEJyYWluIE9yZyBJRCBvciBQcm9qZWN0IElEIG5vdCBzZXQuIENhbm5vdCBjYWxsIHRhc2suXCIpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlByb2Nlc3NvclByb2Nlc3NvcjogUkIgT3JnSUQgb3IgUHJvamVjdElEIG1pc3NpbmcgZm9yIHRhc2sgY2FsbC5cIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBjb25zdCB0YXNrUnVuVXJsID0gYCR7dGhpcy5zZXR0aW5ncy5yaWdodGJyYWluQXBpVXJsfS9vcmcvJHt0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5PcmdJZH0vcHJvamVjdC8ke3RoaXMuc2V0dGluZ3MucmlnaHRicmFpblByb2plY3RJZH0vdGFzay8ke3Rhc2tJZH0vcnVuYDsgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtyYlRva2VufWAsXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBgT2JzaWRpYW5Qcm9jZXNzb3JQcm9jZXNzb3JQbHVnaW4vJHt0aGlzLm1hbmlmZXN0LnZlcnNpb259YFxuICAgICAgICB9O1xuICAgIFxuICAgICAgICAvLyAtLS0gVEhJUyBJUyBUSEUgTkVXIExPR0lDIC0tLVxuICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IHdyYXAgdGhlIHByb3ZpZGVkIHZhcmlhYmxlcyBpbiB0aGUgcmVxdWlyZWQgJ3Rhc2tfaW5wdXQnIG9iamVjdC5cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIHRhc2tfaW5wdXQ6IHRhc2tWYXJpYWJsZXNcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtjYWxsUmlnaHRCcmFpblRhc2tdIFNlbmRpbmcgUmVxdWVzdCB0byBUYXNrIElEICR7dGFza0lkLnN1YnN0cmluZygwLDgpfS4uLiBQYXlsb2FkOmAsIEpTT04uc3RyaW5naWZ5KHBheWxvYWQsIG51bGwsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0YXNrUnVuVXJsLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksIC8vIFNlbmQgdGhlIG5ld2x5IGNvbnN0cnVjdGVkIHBheWxvYWRcbiAgICAgICAgICAgICAgICB0aHJvdzogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmpzb24gJiYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAxKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NhbGxSaWdodEJyYWluVGFza10gU3VjY2VzcyBmb3IgVGFzayBJRCAke3Rhc2tJZC5zdWJzdHJpbmcoMCw4KX0uLi4gRnVsbCBSZXNwb25zZTpgLCBKU09OLnN0cmluZ2lmeShyZXNwb25zZS5qc29uLCBudWxsLCAyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShgUmlnaHRCcmFpbiBUYXNrICR7dGFza0lkLnN1YnN0cmluZygwLDgpfS4uLiBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfS4gQ2hlY2sgY29uc29sZS5gLCA3MDAwKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBSQiBUYXNrIENhbGwgWyR7dGFza0lkfV0gRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWAsIHJlc3BvbnNlLnRleHQgPyByZXNwb25zZS50ZXh0LnN1YnN0cmluZygwLCAxMDAwKSA6IFwiTm8gYm9keVwiLCBcIlBheWxvYWQgU2VudDpcIiwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYE5ldHdvcmsgZXJyb3IgY2FsbGluZyBSaWdodEJyYWluIFRhc2sgJHt0YXNrSWQuc3Vic3RyaW5nKDAsOCl9Li4uLiBDaGVjayBjb25zb2xlLmAsIDcwMDApO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUkIgVGFzayBDYWxsIFske3Rhc2tJZH1dIE5ldHdvcmsgRXJyb3I6YCwgZXJyb3IsIFwiUGF5bG9hZCBTZW50OlwiLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGFzeW5jIHZlcmlmeVN1YnByb2Nlc3Nvckxpc3RVcmwodXJsVG9WZXJpZnk6IHN0cmluZywgcHJvY2Vzc29yTmFtZTogc3RyaW5nLHJiVG9rZW46IHN0cmluZyk6IFByb21pc2U8eyBpc0xpc3Q6IGJvb2xlYW47IGlzQ3VycmVudDogYm9vbGVhbjsgaXNDb3JyZWN0UHJvY2Vzc29yOiBib29sZWFuOyByZWFzb25pbmc6IHN0cmluZzsgcGFnZUNvbnRlbnQ/OiBzdHJpbmcgfSB8IG51bGw+IHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5WZXJpZnlVcmxUYXNrSWQpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJSaWdodEJyYWluIFZlcmlmeSBVUkwgVGFzayBJRCBpcyBub3QgY29uZmlndXJlZC4gQ2Fubm90IHZlcmlmeSBVUkwuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFRoZSBpbnB1dCBwYXJhbWV0ZXIgbmFtZSBmb3IgdGhlIFJCIHRhc2sgKCd1cmxfdG9fdmVyaWZ5JywgJ3VybF9jb250ZW50JywgZXRjLilcbiAgICAgICAgLy8gbXVzdCBtYXRjaCB3aGF0IHRoZSBSQiB0YXNrIGRlZmluaXRpb24gZXhwZWN0cy5cbiAgICAgICAgLy8gQXNzdW1pbmcgdGhlIHRhc2sgZXhwZWN0cyBzb21ldGhpbmcgbGlrZTogeyBcInVybF9jb250ZW50XCI6IFwiaHR0cHM6Ly8uLi5cIiB9XG4gICAgICAgIC8vIEFuZCB0aGUgdXJsX2ZldGNoZXIgaW5wdXRfcHJvY2Vzc29yIGlzIGNvbmZpZ3VyZWQgZm9yIFwidXJsX2NvbnRlbnRcIlxuICAgICAgICBjb25zdCB0YXNrSW5wdXQgPSB7IFxuICAgICAgICAgICAgXCJ1cmxfY29udGVudFwiOiB1cmxUb1ZlcmlmeSxcbiAgICAgICAgICAgIFwiZXhwZWN0ZWRfcHJvY2Vzc29yX25hbWVcIjogcHJvY2Vzc29yTmFtZVxuICAgICAgICB9OyAvLyBUaGlzIHdpbGwgYmUgZmV0Y2hlZCBieSB1cmxfZmV0Y2hlclxuICAgIFxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIGNvbnNvbGUubG9nKGBWZXJpZnlpbmcgVVJMICR7dXJsVG9WZXJpZnl9IHdpdGggUkIgVGFzayAke3RoaXMuc2V0dGluZ3MucmlnaHRicmFpblZlcmlmeVVybFRhc2tJZH0uIElucHV0OmAsIEpTT04uc3RyaW5naWZ5KHRhc2tJbnB1dCkpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdGFza1Jlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbFJpZ2h0QnJhaW5UYXNrKHRoaXMuc2V0dGluZ3MucmlnaHRicmFpblZlcmlmeVVybFRhc2tJZCwgdGFza0lucHV0LCByYlRva2VuKTtcbiAgICBcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUkIgVmVyaWZ5IFRhc2sgWyR7dGhpcy5zZXR0aW5ncy5yaWdodGJyYWluVmVyaWZ5VXJsVGFza0lkfV0gRnVsbCBSZXN1bHQgZm9yIFVSTCAke3VybFRvVmVyaWZ5fTpgLCBKU09OLnN0cmluZ2lmeSh0YXNrUmVzdWx0LCBudWxsLCAyKSk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgdGFza1Jlc3VsdFxuICAgICAgICBpZiAodGFza1Jlc3VsdCAmJiB0eXBlb2YgdGFza1Jlc3VsdC5yZXNwb25zZSA9PT0gJ29iamVjdCcgJiYgdGFza1Jlc3VsdC5yZXNwb25zZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcmJSZXNwb25zZSA9IHRhc2tSZXN1bHQucmVzcG9uc2U7IFxuICAgICAgICAgICAgY29uc3QgaXNMaXN0ID0gU3RyaW5nKHJiUmVzcG9uc2UuaXNTdWJwcm9jZXNzb3JMaXN0KS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG4gICAgICAgICAgICBjb25zdCBpc0NvcnJlY3RQcm9jZXNzb3IgPSBTdHJpbmcocmJSZXNwb25zZS5pc0NvcnJlY3RQcm9jZXNzb3IpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbiAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudCA9IFN0cmluZyhyYlJlc3BvbnNlLmlzQ3VycmVudFZlcnNpb24pLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbiAgICAgICAgICAgIGNvbnN0IHJlYXNvbmluZyA9IHJiUmVzcG9uc2UucmVhc29uaW5nIHx8IFwiTi9BXCI7XG4gICAgXG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdldCBwYWdlQ29udGVudCBpZiB1cmxfZmV0Y2hlciB3YXMgdXNlZCBhbmQgcGFzc2VkIGl0IHRocm91Z2hcbiAgICAgICAgICAgIGxldCBwYWdlQ29udGVudDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gQ2hlY2sgY29tbW9uIHBsYWNlcyB3aGVyZSBmZXRjaGVkIEhUTUwgbWlnaHQgYmUgc3RvcmVkIGJ5IFJCL3VybF9mZXRjaGVyXG4gICAgICAgICAgICBpZiAodGFza1Jlc3VsdC5ydW5fZGF0YSAmJiB0YXNrUmVzdWx0LnJ1bl9kYXRhLnN1Ym1pdHRlZCAmJiBcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGFza1Jlc3VsdC5ydW5fZGF0YS5zdWJtaXR0ZWQudXJsX2NvbnRlbnQgPT09ICdzdHJpbmcnICYmIFxuICAgICAgICAgICAgICAgIHRhc2tSZXN1bHQucnVuX2RhdGEuc3VibWl0dGVkLnVybF9jb250ZW50LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJzxodG1sJykpIHsgLy8gQ2hlY2sgaWYgaXQgbG9va3MgbGlrZSBIVE1MXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhc3N1bWVzICd1cmxfY29udGVudCcgaW4gJ3N1Ym1pdHRlZCcgZGF0YSBpcyB0aGUgZmV0Y2hlZCBIVE1MIGlmIHVybF9mZXRjaGVyIHdhcyB1c2VkLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZGVwZW5kcyBoZWF2aWx5IG9uIFJCJ3MgaW50ZXJuYWwgc3RydWN0dXJlIGZvciBgcnVuX3dhaXRfZm9yX3Jlc3BvbnNlYC5cbiAgICAgICAgICAgICAgICBwYWdlQ29udGVudCA9IHRhc2tSZXN1bHQucnVuX2RhdGEuc3VibWl0dGVkLnVybF9jb250ZW50O1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhcIlJldHJpZXZlZCBwYWdlQ29udGVudCBmcm9tIHJ1bl9kYXRhLnN1Ym1pdHRlZC51cmxfY29udGVudCBmb3IgdmVyaWZ5IHRhc2tcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByYlJlc3BvbnNlLmZldGNoZWRfcGFnZV9odG1sID09PSAnc3RyaW5nJykgeyAvLyBJZiBMTE0gZXhwbGljaXRseSBwYXNzZXMgaXQgYmFja1xuICAgICAgICAgICAgICAgIHBhZ2VDb250ZW50ID0gcmJSZXNwb25zZS5mZXRjaGVkX3BhZ2VfaHRtbDtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coXCJSZXRyaWV2ZWQgcGFnZUNvbnRlbnQgZnJvbSByYlJlc3BvbnNlLmZldGNoZWRfcGFnZV9odG1sIGZvciB2ZXJpZnkgdGFza1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJiUmVzcG9uc2UucGFnZV9jb250ZW50ID09PSAnc3RyaW5nJykgeyAvLyBBbm90aGVyIHBvdGVudGlhbCBmYWxsYmFja1xuICAgICAgICAgICAgICAgICBwYWdlQ29udGVudCA9IHJiUmVzcG9uc2UucGFnZV9jb250ZW50O1xuICAgICAgICAgICAgICAgICBpZih0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coXCJSZXRyaWV2ZWQgcGFnZUNvbnRlbnQgZnJvbSByYlJlc3BvbnNlLnBhZ2VfY29udGVudCAoZmFsbGJhY2spIGZvciB2ZXJpZnkgdGFza1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1vcmUgcm9idXN0OiBpZiB5b3VyIFJCIHRhc2sncyBpbnB1dF9wcm9jZXNzb3IgKHVybF9mZXRjaGVyKSBzdG9yZXMgaXRzIG91dHB1dCBpbiBhIGtub3duIHdheSB3aXRoaW4gYHRhc2tSZXN1bHQucnVuX2RhdGEuaW5wdXRfcHJvY2Vzc29yX291dHB1dHNgLCBhY2Nlc3MgaXQgdGhlcmUuXG4gICAgICAgICAgICAvLyBlLmcuLCBpZiAodGFza1Jlc3VsdC5ydW5fZGF0YT8uaW5wdXRfcHJvY2Vzc29yX291dHB1dHM/LnVybF9jb250ZW50Py50ZXh0X2NvbnRlbnQpIHsgcGFnZUNvbnRlbnQgPSB0YXNrUmVzdWx0LnJ1bl9kYXRhLmlucHV0X3Byb2Nlc3Nvcl9vdXRwdXRzLnVybF9jb250ZW50LnRleHRfY29udGVudDsgfVxuXG4gICAgXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUkIgVmVyaWZ5IGZvciAke3VybFRvVmVyaWZ5fTogTGlzdD0ke2lzTGlzdH0sIEN1cnJlbnQ9JHtpc0N1cnJlbnR9LCBDb250ZW50IGF2YWlsYWJsZTogJHshIXBhZ2VDb250ZW50fSwgQ29udGVudCBzbmlwcGV0OiAke3BhZ2VDb250ZW50ID8gcGFnZUNvbnRlbnQuc3Vic3RyaW5nKDAsMTAwKSArIFwiLi4uXCIgOiBcIk4vQVwifWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNMaXN0LCBpc0N1cnJlbnQ6IChpc0xpc3QgJiYgaXNDdXJyZW50KSwgaXNDb3JyZWN0UHJvY2Vzc29yLCByZWFzb25pbmcsIHBhZ2VDb250ZW50IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFJCIFZlcmlmeSB0YXNrIGZvciAke3VybFRvVmVyaWZ5fSBmYWlsZWQgb3IgcmV0dXJuZWQgdW5leHBlY3RlZCByZXNwb25zZSBmb3JtYXQuIFRhc2tSZXN1bHQ6YCwgdGFza1Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIFZlcmlmaWNhdGlvbiBmYWlsZWQgb3IgdGFzayBvdXRwdXQgd2FzIG5vdCBhcyBleHBlY3RlZFxuICAgIH1cblxuICAgIFxuICAgIHByaXZhdGUgYXN5bmMgZXh0cmFjdEVudGl0aWVzRnJvbVBhZ2VDb250ZW50KHBhZ2VDb250ZW50OiBzdHJpbmcsIHJiVG9rZW46IHN0cmluZyk6IFByb21pc2U8eyB0aGlyZFBhcnR5U3VicHJvY2Vzc29yczogYW55W107IG93bkVudGl0aWVzOiBhbnlbXSB9IHwgbnVsbD4ge1xuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkV4dHJhY3RFbnRpdGllc1Rhc2tJZCkge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIlJCIEV4dHJhY3QgRW50aXRpZXMgVGFzayBJRCBtaXNzaW5nLiBDYW5ub3QgZXh0cmFjdCBmcm9tIGNvbnRlbnQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYWdlQ29udGVudC50cmltKCkpIHtcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coXCJQYWdlIGNvbnRlbnQgaXMgZW1wdHksIHNraXBwaW5nIGVudGl0eSBleHRyYWN0aW9uLlwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRoaXJkUGFydHlTdWJwcm9jZXNzb3JzOiBbXSwgb3duRW50aXRpZXM6IFtdIH07IC8vIFJldHVybiBlbXB0eSBpZiBubyBjb250ZW50XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgaW5wdXQgZmllbGQgbmFtZSBmb3IgdGhlIFJCIHRhc2sgbXVzdCBtYXRjaCB0aGUgdGFzayBkZWZpbml0aW9uLlxuICAgICAgICAvLyBlLmcuLCBpZiB0aGUgdGFzayBleHBlY3RzIHsgXCJ0ZXh0X3RvX2FuYWx5emVcIjogXCIuLi5cIiB9LCB1c2UgdGhhdCBoZXJlLlxuICAgICAgICBjb25zdCB0YXNrSW5wdXQgPSB7IFt0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5FeHRyYWN0SW5wdXRGaWVsZF06IHBhZ2VDb250ZW50IH07XG5cbiAgICAgICAgLy8gaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgRXh0cmFjdGluZyBlbnRpdGllcyB3aXRoIFJCIFRhc2sgJHt0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5FeHRyYWN0RW50aXRpZXNUYXNrSWR9LiBJbnB1dCBzbmlwcGV0OmAsIHBhZ2VDb250ZW50LnN1YnN0cmluZygwLCAyMDApICsgXCIuLi5cIik7XG5cbiAgICAgICAgY29uc3QgdGFza1Jlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbFJpZ2h0QnJhaW5UYXNrKHRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkV4dHJhY3RFbnRpdGllc1Rhc2tJZCwgdGFza0lucHV0LCByYlRva2VuKTtcblxuICAgICAgICAvLyBpZiAodGhpcy5zZXR0aW5ncy52ZXJib3NlRGVidWcgJiYgdGFza1Jlc3VsdCkge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coYFJCIEV4dHJhY3QgRW50aXRpZXMgVGFzayBGdWxsIFJlc3VsdDpgLCBKU09OLnN0cmluZ2lmeSh0YXNrUmVzdWx0LCBudWxsLCAyKSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZiAodGFza1Jlc3VsdCAmJiB0eXBlb2YgdGFza1Jlc3VsdC5yZXNwb25zZSA9PT0gJ29iamVjdCcgJiYgdGFza1Jlc3VsdC5yZXNwb25zZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcmJSZXNwb25zZSA9IHRhc2tSZXN1bHQucmVzcG9uc2U7XG4gICAgICAgICAgICAvLyBBY2Nlc3MgdGhlIGFycmF5cyB1c2luZyB0aGUgY29uZmlndXJlZCBmaWVsZCBuYW1lcyBmb3IgdGhpcmQtcGFydHkgYW5kIG93biBlbnRpdGllc1xuICAgICAgICAgICAgY29uc3QgdGhpcmRQYXJ0eVN1YnByb2Nlc3NvcnMgPSByYlJlc3BvbnNlW3RoaXMuc2V0dGluZ3MucmlnaHRicmFpbkV4dHJhY3RPdXRwdXRUaGlyZFBhcnR5RmllbGRdIHx8IFtdO1xuICAgICAgICAgICAgY29uc3Qgb3duRW50aXRpZXMgPSByYlJlc3BvbnNlW3RoaXMuc2V0dGluZ3MucmlnaHRicmFpbkV4dHJhY3RPdXRwdXRPd25FbnRpdGllc0ZpZWxkXSB8fCBbXTtcblxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZXkgYXJlIGFycmF5c1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0aGlyZFBhcnR5U3VicHJvY2Vzc29yczogQXJyYXkuaXNBcnJheSh0aGlyZFBhcnR5U3VicHJvY2Vzc29ycykgPyB0aGlyZFBhcnR5U3VicHJvY2Vzc29ycyA6IFtdLFxuICAgICAgICAgICAgICAgIG93bkVudGl0aWVzOiBBcnJheS5pc0FycmF5KG93bkVudGl0aWVzKSA/IG93bkVudGl0aWVzIDogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLndhcm4oYFJCIEV4dHJhY3QgRW50aXRpZXMgdGFzayBmYWlsZWQgb3IgcmV0dXJuZWQgdW5leHBlY3RlZCByZXNwb25zZSBmb3JtYXQuIFRhc2tSZXN1bHQ6YCwgdGFza1Jlc3VsdCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyB1cGRhdGVEaXNjb3ZlcnlTdGF0dXMoZmlsZTogVEZpbGUsIHN0YXR1czogJ2NvbXBsZXRlJyB8ICdpbmNvbXBsZXRlJyB8ICdza2lwcGVkJykge1xuICAgICAgICBpZiAoIWZpbGUpIHJldHVybjtcbiAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQucHJvY2VzcyhmaWxlLCAoY29udGVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlczogYW55ID0ge1xuICAgICAgICAgICAgICAgICdkaXNjb3Zlcnktc3RhdHVzJzogc3RhdHVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZXNbJ2xhc3QtZGlzY292ZXJlZCddID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07IC8vIFlZWVktTU0tREQgZm9ybWF0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVGcm9udG1hdHRlcihjb250ZW50LCB1cGRhdGVzLCBmaWxlLmJhc2VuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBidWlsZEFsaWFzTWFwKCk6IFByb21pc2U8TWFwPHN0cmluZywgeyBwYXRoOiBzdHJpbmcsIGNhbm9uaWNhbE5hbWU6IHN0cmluZyB9Pj4ge1xuICAgICAgICBjb25zdCBhbGlhc01hcCA9IG5ldyBNYXA8c3RyaW5nLCB7IHBhdGg6IHN0cmluZywgY2Fub25pY2FsTmFtZTogc3RyaW5nIH0+KCk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NvcnNGb2xkZXIgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5zZXR0aW5ncy5wcm9jZXNzb3JzRm9sZGVyUGF0aCkgYXMgVEZvbGRlcjtcbiAgICAgICAgaWYgKCFwcm9jZXNzb3JzRm9sZGVyPy5jaGlsZHJlbikgcmV0dXJuIGFsaWFzTWFwO1xuXG4gICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBwcm9jZXNzb3JzRm9sZGVyLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlICYmIGZpbGUuZXh0ZW5zaW9uID09PSAnbWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9udG1hdHRlciA9IGNhY2hlPy5mcm9udG1hdHRlciB8fCB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5vbmljYWxOYW1lID0gZnJvbnRtYXR0ZXIuYWxpYXNlcz8uWzBdIHx8IGZpbGUuYmFzZW5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxpYXNlcyA9IChmcm9udG1hdHRlci5hbGlhc2VzIHx8IFtdKS5tYXAoKGE6IHN0cmluZykgPT4gU3RyaW5nKGEpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIGFsaWFzZXMucHVzaChmaWxlLmJhc2VuYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgbmV3IFNldChhbGlhc2VzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzTWFwLnNldChhbGlhcywgeyBwYXRoOiBmaWxlLnBhdGgsIGNhbm9uaWNhbE5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsaWFzTWFwO1xuICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICogVXBkYXRlcyBhbiBleGlzdGluZyBSaWdodEJyYWluIHRhc2sgYnkgY3JlYXRpbmcgYSBuZXcgcmV2aXNpb24uXG4gICAgICogQHBhcmFtIHJiVG9rZW4gVGhlIFJpZ2h0QnJhaW4gYWNjZXNzIHRva2VuLlxuICAgICAqIEBwYXJhbSB0YXNrSWQgVGhlIElEIG9mIHRoZSB0YXNrIHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0gdGFza0RlZmluaXRpb24gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5ldyBjb25maWd1cmF0aW9uIGZvciB0aGUgdGFzayByZXZpc2lvbi5cbiAgICAgKiBAcGFyYW0gY3JlZHMgWW91ciBSaWdodEJyYWluIGNyZWRlbnRpYWxzLlxuICAgICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIHRhc2sgb2JqZWN0IG9yIG51bGwgaWYgYW4gZXJyb3Igb2NjdXJzLlxuICAgICAqL1xuXG4gICAgcHJpdmF0ZSBhc3luYyB1cGRhdGVSaWdodEJyYWluVGFzayhyYlRva2VuOiBzdHJpbmcsIHRhc2tJZDogc3RyaW5nLCBuZXdSZXZpc2lvblBheWxvYWQ6IGFueSwgdGFza05hbWU6IHN0cmluZywgY3JlZHM6IHsgYXBpVXJsOiBzdHJpbmcsIG9yZ0lkOiBzdHJpbmcsIHByb2plY3RJZDogc3RyaW5nIH0pOiBQcm9taXNlPGFueSB8IG51bGw+IHtcbiAgICAgICAgY29uc3QgdGFza1VybCA9IGAke2NyZWRzLmFwaVVybH0vb3JnLyR7Y3JlZHMub3JnSWR9L3Byb2plY3QvJHtjcmVkcy5wcm9qZWN0SWR9L3Rhc2svJHt0YXNrSWR9YDtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3JiVG9rZW59YCxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gLS0tIFNURVAgMTogQ3JlYXRlIHRoZSBuZXcgcmV2aXNpb24gLS0tXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVSZXZpc2lvblJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0YXNrVXJsLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobmV3UmV2aXNpb25QYXlsb2FkKSxcbiAgICAgICAgICAgICAgICB0aHJvdzogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY3JlYXRlUmV2aXNpb25SZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYEVycm9yIGNyZWF0aW5nIHRhc2sgcmV2aXNpb24gZm9yICcke3Rhc2tOYW1lfSc6ICR7Y3JlYXRlUmV2aXNpb25SZXNwb25zZS5zdGF0dXN9ICR7Y3JlYXRlUmV2aXNpb25SZXNwb25zZS50ZXh0LnN1YnN0cmluZygwLCAxMDApfWAsIDEwMDAwKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjcmVhdGluZyB0YXNrIHJldmlzaW9uIGZvciAnJHt0YXNrTmFtZX0nOmAsIGNyZWF0ZVJldmlzaW9uUmVzcG9uc2Uuc3RhdHVzLCBjcmVhdGVSZXZpc2lvblJlc3BvbnNlLnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAtLS0gU1RFUCAyOiBGaW5kIHRoZSBsYXRlc3QgcmV2aXNpb24gZnJvbSB0aGUgaW1tZWRpYXRlIHJlc3BvbnNlIC0tLVxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFRhc2tEYXRhID0gY3JlYXRlUmV2aXNpb25SZXNwb25zZS5qc29uO1xuICAgICAgICAgICAgLy8gRklYOiBVc2UgYHJldmlzaW9uc2AgaW5zdGVhZCBvZiBgdGFza19yZXZpc2lvbnNgXG4gICAgICAgICAgICBjb25zdCBsYXRlc3RSZXZpc2lvbiA9IHVwZGF0ZWRUYXNrRGF0YS5yZXZpc2lvbnM/LnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiBuZXcgRGF0ZShiLmNyZWF0ZWRfYXQpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEuY3JlYXRlZF9hdCkuZ2V0VGltZSgpKVswXTtcblxuICAgICAgICAgICAgaWYgKCFsYXRlc3RSZXZpc2lvbikge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYENvdWxkIG5vdCBmaW5kIHRoZSBuZXcgcmV2aXNpb24gZm9yICcke3Rhc2tOYW1lfScgaW4gdGhlIEFQSSByZXNwb25zZS5gLCA3MDAwKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IGZpbmQgJ3JldmlzaW9ucycgYXJyYXkgaW4gdGhlIHJlc3BvbnNlIGZyb20gY3JlYXRpbmcgYSByZXZpc2lvbjpcIiwgdXBkYXRlZFRhc2tEYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLS0tIFNURVAgMzogQWN0aXZhdGUgdGhlIG5ldyByZXZpc2lvbiAtLS1cbiAgICAgICAgICAgIGNvbnN0IGFjdGl2YXRpb25QYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIGFjdGl2ZV9yZXZpc2lvbnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tfcmV2aXNpb25faWQ6IGxhdGVzdFJldmlzaW9uLmlkLFxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IDFcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgYWN0aXZhdGVSZXZpc2lvblJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0YXNrVXJsLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYWN0aXZhdGlvblBheWxvYWQpLFxuICAgICAgICAgICAgICAgIHRocm93OiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChhY3RpdmF0ZVJldmlzaW9uUmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCB0YXNrOiAnJHt0YXNrTmFtZX0nYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3RpdmF0ZVJldmlzaW9uUmVzcG9uc2UuanNvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShgRmFpbGVkIHRvIGFjdGl2YXRlIG5ldyByZXZpc2lvbiBmb3IgJyR7dGFza05hbWV9JzogJHthY3RpdmF0ZVJldmlzaW9uUmVzcG9uc2Uuc3RhdHVzfWAsIDcwMDApO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGFjdGl2YXRpbmcgcmV2aXNpb24gZm9yICcke3Rhc2tOYW1lfSc6YCwgYWN0aXZhdGVSZXZpc2lvblJlc3BvbnNlLnN0YXR1cywgYWN0aXZhdGVSZXZpc2lvblJlc3BvbnNlLnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBOZXR3b3JrIGVycm9yIHVwZGF0aW5nIHRhc2sgJyR7dGFza05hbWV9JzpgLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHJ1bkRlZHVwbGljYXRpb25Gb3JGb2xkZXIoZm9sZGVyOiBURm9sZGVyKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYFByZXBhcmluZyB0byBkZWR1cGxpY2F0ZSBwYWdlcyBpbiAke2ZvbGRlci5wYXRofS4uLmApO1xuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MucmlnaHRicmFpbkRlZHVwbGljYXRlU3VicHJvY2Vzc29yc1Rhc2tJZCkge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIkRlZHVwbGljYXRpb24gVGFzayBJRCBub3Qgc2V0LiBDYW5ub3QgcHJvY2VlZC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmJUb2tlbiA9IGF3YWl0IHRoaXMuZ2V0UmlnaHRCcmFpbkFjY2Vzc1Rva2VuKCk7XG4gICAgICAgIGlmICghcmJUb2tlbikge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIkNvdWxkIG5vdCBnZXQgUmlnaHRCcmFpbiB0b2tlbiBmb3IgZGVkdXBsaWNhdGlvbi5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaWxlcyA9IGZvbGRlci5jaGlsZHJlbi5maWx0ZXIoZiA9PiBmIGluc3RhbmNlb2YgVEZpbGUgJiYgZi5leHRlbnNpb24gPT09ICdtZCcpIGFzIFRGaWxlW107XG4gICAgICAgIGlmIChmaWxlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiTm90IGVub3VnaCBNYXJrZG93biBmaWxlcyBpbiB0aGUgZm9sZGVyIHRvIHBlcmZvcm0gZGVkdXBsaWNhdGlvbi5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdWJwcm9jZXNzb3JQYWdlc0luZm86IFN1YnByb2Nlc3NvclBhZ2VJbmZvW10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlQ2FjaGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICAgICAgICAgIGNvbnN0IGZyb250bWF0dGVyID0gZmlsZUNhY2hlPy5mcm9udG1hdHRlcjtcbiAgICAgICAgICAgIGNvbnN0IGFsaWFzZXMgPSAoZnJvbnRtYXR0ZXI/LmFsaWFzZXMgJiYgQXJyYXkuaXNBcnJheShmcm9udG1hdHRlci5hbGlhc2VzKSkgPyBmcm9udG1hdHRlci5hbGlhc2VzLm1hcChTdHJpbmcpIDogW107XG4gICAgICAgICAgICBpZiAoZnJvbnRtYXR0ZXI/LmNvbXBhbnlfbmFtZSkgYWxpYXNlcy5wdXNoKFN0cmluZyhmcm9udG1hdHRlci5jb21wYW55X25hbWUpKTsgLy8gSW5jbHVkZSBjb21wYW55X25hbWUgaWYgcHJlc2VudFxuICAgICAgICAgICAgYWxpYXNlcy5wdXNoKGZpbGUuYmFzZW5hbWUpOyAvLyBJbmNsdWRlIGJhc2VuYW1lIGFzIGFuIGFsaWFzXG5cbiAgICAgICAgICAgIHN1YnByb2Nlc3NvclBhZ2VzSW5mby5wdXNoKHtcbiAgICAgICAgICAgICAgICBmaWxlX3BhdGg6IGZpbGUucGF0aCxcbiAgICAgICAgICAgICAgICBwYWdlX25hbWU6IGZpbGUuYmFzZW5hbWUsIC8vIE9yIGEgbW9yZSBjYW5vbmljYWwgbmFtZSBmcm9tIGZyb250bWF0dGVyIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGFsaWFzZXM6IEFycmF5LmZyb20obmV3IFNldChhbGlhc2VzLmZpbHRlcihhID0+IGEpKSkgLy8gVW5pcXVlLCBub24tZW1wdHkgYWxpYXNlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VicHJvY2Vzc29yUGFnZXNJbmZvLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJOb3QgZW5vdWdoIHByb2Nlc3NhYmxlIHBhZ2VzIHdpdGggYWxpYXNlcyBmb3VuZCBmb3IgZGVkdXBsaWNhdGlvbi5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRhc2tJbnB1dFBheWxvYWQgPSB7XG4gICAgICAgICAgICBzdWJwcm9jZXNzb3JfcGFnZXM6IHN1YnByb2Nlc3NvclBhZ2VzSW5mbyxcbiAgICAgICAgICAgIC8vIE9wdGlvbmFsOiBBZGQgYSB0aHJlc2hvbGQgb3Igb3RoZXIgcGFyYW1ldGVycyBpZiB5b3VyIFJCIHRhc2sgc3VwcG9ydHMgdGhlbVxuICAgICAgICAgICAgLy8gXCJzaW1pbGFyaXR5X3RocmVzaG9sZFwiOiAwLjggXG4gICAgICAgIH07XG5cbiAgICAgICAgbmV3IE5vdGljZShgU2VuZGluZyAke3N1YnByb2Nlc3NvclBhZ2VzSW5mby5sZW5ndGh9IHBhZ2VzIHRvIFJpZ2h0QnJhaW4gZm9yIGRlZHVwbGljYXRpb24gYW5hbHlzaXMuLi4gVGhpcyBtYXkgdGFrZSBhIHdoaWxlLmApO1xuICAgICAgICAvLyBpZih0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS5sb2coXCJEZWR1cGxpY2F0aW9uIHBheWxvYWQ6XCIsIEpTT04uc3RyaW5naWZ5KHRhc2tJbnB1dFBheWxvYWQpKTtcblxuICAgICAgICBjb25zdCB0YXNrUmVzdWx0ID0gYXdhaXQgdGhpcy5jYWxsUmlnaHRCcmFpblRhc2sodGhpcy5zZXR0aW5ncy5yaWdodGJyYWluRGVkdXBsaWNhdGVTdWJwcm9jZXNzb3JzVGFza0lkLCB0YXNrSW5wdXRQYXlsb2FkLCByYlRva2VuKTtcblxuICAgICAgICAvLyBpZih0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZyAmJiB0YXNrUmVzdWx0KSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcIkRlZHVwbGljYXRpb24gVGFzayBGdWxsIFJlc3VsdDpcIiwgSlNPTi5zdHJpbmdpZnkodGFza1Jlc3VsdCwgbnVsbCwgMikpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYgKHRhc2tSZXN1bHQgJiYgdGFza1Jlc3VsdC5yZXNwb25zZSAmJiBBcnJheS5pc0FycmF5KHRhc2tSZXN1bHQucmVzcG9uc2UuZGVkdXBsaWNhdGlvbl9yZXN1bHRzKSkge1xuICAgICAgICAgICAgY29uc3QgZGVkdXBsaWNhdGlvblJlc3VsdHM6IERlZHVwbGljYXRpb25SZXN1bHRJdGVtW10gPSB0YXNrUmVzdWx0LnJlc3BvbnNlLmRlZHVwbGljYXRpb25fcmVzdWx0cztcbiAgICAgICAgICAgIGlmIChkZWR1cGxpY2F0aW9uUmVzdWx0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiTm8gZHVwbGljYXRlcyBmb3VuZCBieSBSaWdodEJyYWluIHRhc2suXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYERlZHVwbGljYXRpb24gYW5hbHlzaXMgY29tcGxldGUuIEZvdW5kICR7ZGVkdXBsaWNhdGlvblJlc3VsdHMubGVuZ3RofSBwb3RlbnRpYWwgZHVwbGljYXRlIHNldHMuIFByb2Nlc3NpbmcgbWVyZ2VzLi4uYCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NEZWR1cGxpY2F0aW9uUmVzdWx0cyhkZWR1cGxpY2F0aW9uUmVzdWx0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiRGVkdXBsaWNhdGlvbiB0YXNrIGZhaWxlZCBvciByZXR1cm5lZCBhbiB1bmV4cGVjdGVkIHJlc3BvbnNlLiBDaGVjayBjb25zb2xlLlwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEZWR1cGxpY2F0aW9uIHRhc2sgZXJyb3IuIFJlc3BvbnNlOlwiLCB0YXNrUmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgYXN5bmMgcHJvY2Vzc0RlZHVwbGljYXRpb25SZXN1bHRzKHJlc3VsdHM6IERlZHVwbGljYXRpb25SZXN1bHRJdGVtW10pIHtcbiAgICAgICAgbGV0IG1lcmdlQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdFNldCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdFNldC5zdXJ2aXZvcl9maWxlX3BhdGggfHwgcmVzdWx0U2V0LmR1cGxpY2F0ZV9maWxlX3BhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS53YXJuKFwiU2tpcHBpbmcgaW52YWxpZCBkZWR1cGxpY2F0aW9uIHJlc3VsdCBzZXQ6XCIsIHJlc3VsdFNldCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBjb25zdCBzdXJ2aXZvckZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocmVzdWx0U2V0LnN1cnZpdm9yX2ZpbGVfcGF0aCkgYXMgVEZpbGU7XG4gICAgICAgICAgICBpZiAoIXN1cnZpdm9yRmlsZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmJvc2VEZWJ1ZykgY29uc29sZS53YXJuKGBTdXJ2aXZvciBmaWxlIG5vdCBmb3VuZDogJHtyZXN1bHRTZXQuc3Vydml2b3JfZmlsZV9wYXRofWApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdXJ2aXZvckNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKHN1cnZpdm9yRmlsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIC0tLSBTdGVwIDE6IEdhdGhlciBhbGwgZGF0YSBmcm9tIHN1cnZpdm9yIGFuZCBkdXBsaWNhdGVzLCB3aGlsZSBhcmNoaXZpbmcgZHVwbGljYXRlcyAtLS1cbiAgICBcbiAgICAgICAgICAgIGNvbnN0IHN1cnZpdm9yQ2FjaGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShzdXJ2aXZvckZpbGUpO1xuICAgICAgICAgICAgY29uc3QgYWxsQWxpYXNlcyA9IG5ldyBTZXQ8c3RyaW5nPigoc3Vydml2b3JDYWNoZT8uZnJvbnRtYXR0ZXI/LmFsaWFzZXMgfHwgW10pLm1hcChTdHJpbmcpKTtcbiAgICAgICAgICAgIGFsbEFsaWFzZXMuYWRkKHN1cnZpdm9yRmlsZS5iYXNlbmFtZSk7XG4gICAgICAgICAgICBjb25zdCBhbGxSb3dzID0gbmV3IFNldDxzdHJpbmc+KHRoaXMuZXh0cmFjdENsaWVudFRhYmxlUm93cyhvcmlnaW5hbFN1cnZpdm9yQ29udGVudCkpO1xuICAgIFxuICAgICAgICAgICAgLy8gPC0tIE5FVzogRW5zdXJlIHRoZSBhcmNoaXZlIGZvbGRlciBleGlzdHMuXG4gICAgICAgICAgICBjb25zdCBhcmNoaXZlRm9sZGVyUGF0aCA9IGAke3RoaXMuc2V0dGluZ3MucHJvY2Vzc29yc0ZvbGRlclBhdGh9L19BcmNoaXZlYDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRm9sZGVyRXhpc3RzKGFyY2hpdmVGb2xkZXJQYXRoKTtcbiAgICBcbiAgICAgICAgICAgIGZvciAoY29uc3QgZHVwRmlsZVBhdGggb2YgcmVzdWx0U2V0LmR1cGxpY2F0ZV9maWxlX3BhdGhzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGR1cEZpbGVQYXRoID09PSBzdXJ2aXZvckZpbGUucGF0aCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgZHVwRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChkdXBGaWxlUGF0aCkgYXMgVEZpbGU7XG4gICAgICAgICAgICAgICAgaWYgKGR1cEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHVwQ29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZHVwRmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cENhY2hlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZHVwRmlsZSk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIChkdXBDYWNoZT8uZnJvbnRtYXR0ZXI/LmFsaWFzZXMgfHwgW10pLm1hcChTdHJpbmcpLmZvckVhY2goYWxpYXMgPT4gYWxsQWxpYXNlcy5hZGQoYWxpYXMpKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsQWxpYXNlcy5hZGQoZHVwRmlsZS5iYXNlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXh0cmFjdENsaWVudFRhYmxlUm93cyhkdXBDb250ZW50KS5mb3JFYWNoKHJvdyA9PiBhbGxSb3dzLmFkZChyb3cpKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA8LS0gTkVXOiBNb3ZlIHRoZSBkdXBsaWNhdGUgZmlsZSB0byBhbiBhcmNoaXZlIGZvbGRlciBpbnN0ZWFkIG9mIGRlbGV0aW5nIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UGF0aCA9IGAke2FyY2hpdmVGb2xkZXJQYXRofS8ke2R1cEZpbGUubmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQucmVuYW1lKGR1cEZpbGUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbW92ZSBkdXBsaWNhdGUgZmlsZSAke2R1cEZpbGVQYXRofSB0byBhcmNoaXZlOmAsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gLS0tIFN0ZXAgMjogUmVidWlsZCB0aGUgc3Vydml2b3IgZmlsZSBmcm9tIHNjcmF0Y2ggd2l0aCBtZXJnZWQgZGF0YSAtLS1cbiAgICBcbiAgICAgICAgICAgIGNvbnN0IGZtUmVnZXggPSAvXi0tLVxccypcXG4oW1xcc1xcU10qPylcXG4tLS1cXHMqXFxuLztcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gb3JpZ2luYWxTdXJ2aXZvckNvbnRlbnQubWF0Y2goZm1SZWdleCk7XG4gICAgICAgICAgICBsZXQgc3Vydml2b3JCb2R5ID0gbWF0Y2ggPyBvcmlnaW5hbFN1cnZpdm9yQ29udGVudC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKSA6IG9yaWdpbmFsU3Vydml2b3JDb250ZW50O1xuICAgIFxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUYWdzID0gbmV3IFNldDxzdHJpbmc+KChzdXJ2aXZvckNhY2hlPy5mcm9udG1hdHRlcj8udGFncyB8fCBbXSkubWFwKFN0cmluZykpO1xuICAgICAgICAgICAgLy8gPC0tIE5FVzogQWRkIGEgJ21lcmdlZC1wcm9jZXNzb3InIHRhZyBmb3IgZWFzeSBzZWFyY2hpbmcuXG4gICAgICAgICAgICBleGlzdGluZ1RhZ3MuYWRkKFwibWVyZ2VkLXByb2Nlc3NvclwiKTsgXG4gICAgXG4gICAgICAgICAgICBsZXQgbmV3Rm1TdHJpbmcgPSBcIi0tLVxcblwiO1xuICAgICAgICAgICAgbmV3Rm1TdHJpbmcgKz0gYGFsaWFzZXM6IFske0FycmF5LmZyb20oYWxsQWxpYXNlcykubWFwKGEgPT4gYFwiJHthLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKX1cImApLmpvaW4oJywgJyl9XVxcbmA7XG4gICAgICAgICAgICBuZXdGbVN0cmluZyArPSBgdGFnczogWyR7QXJyYXkuZnJvbShleGlzdGluZ1RhZ3MpLm1hcCh0ID0+IGBcIiR7dH1cImApLmpvaW4oJywgJyl9XVxcbmA7XG4gICAgICAgICAgICBuZXdGbVN0cmluZyArPSBcIi0tLVxcblwiO1xuICAgIFxuICAgICAgICAgICAgbGV0IGNsaWVudFRhYmxlTWQgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKGFsbFJvd3Muc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjbGllbnRUYWJsZU1kICs9IGB8IFByaW1hcnkgUHJvY2Vzc29yIHwgUHJvY2Vzc2luZyBGdW5jdGlvbiB8IExvY2F0aW9uIHwgU291cmNlIFVSTCB8XFxuYDtcbiAgICAgICAgICAgICAgICBjbGllbnRUYWJsZU1kICs9IGB8LS0tfC0tLXwtLS18LS0tfFxcbmA7XG4gICAgICAgICAgICAgICAgYWxsUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFRhYmxlTWQgKz0gYHwke3Jvd318XFxuYDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsQm9keSA9IHRoaXMuZW5zdXJlSGVhZGluZ0FuZFNlY3Rpb24oc3Vydml2b3JCb2R5LCBcIlVzZWQgQnlcIiwgY2xpZW50VGFibGVNZCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICBsZXQgZmluYWxDb250ZW50ID0gbmV3Rm1TdHJpbmcgKyBmaW5hbEJvZHk7XG4gICAgXG4gICAgICAgICAgICAvLyA8LS0gTkVXOiBDcmVhdGUgdGhlIGRldGFpbGVkIG1lcmdlIHJlY29yZCBmb3IgdGhlIHN1cnZpdm9yJ3MgYW5hbHlzaXMgbG9nLlxuICAgICAgICAgICAgY29uc3QgbG9nRGF0ZSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IHN1cnZpdm9yTG9nUGF0aCA9IGAke3RoaXMuc2V0dGluZ3MuYW5hbHlzaXNMb2dzRm9sZGVyUGF0aH0vJHt0aGlzLnNhbml0aXplTmFtZUZvckZpbGVQYXRoQW5kQWxpYXMoc3Vydml2b3JGaWxlLmJhc2VuYW1lKS5maWxlUGF0aE5hbWV9IFN1YnByb2Nlc3NvciBMb2dzLm1kYDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IG1lcmdlTG9nQ29udGVudCA9IGBcbiAgICAtLS1cbiAgICAjIyMgRGVkdXBsaWNhdGlvbiBNZXJnZSBFdmVudFxuICAgICoqRGF0ZToqKiAke2xvZ0RhdGV9XG4gICAgKipTdXJ2aXZvcjoqKiBbWyR7c3Vydml2b3JGaWxlLnBhdGh9fCR7c3Vydml2b3JGaWxlLmJhc2VuYW1lfV1dXG4gICAgKipSaWdodEJyYWluIFJlYXNvbmluZzoqKiAke3Jlc3VsdFNldC5yZWFzb25pbmcgfHwgXCJObyByZWFzb25pbmcgcHJvdmlkZWQuXCJ9XG4gICAgXG4gICAgKipBcmNoaXZlZCBGaWxlcyAoJHtyZXN1bHRTZXQuZHVwbGljYXRlX2ZpbGVfcGF0aHMubGVuZ3RofSk6KipcbiAgICBgO1xuICAgICAgICAgICAgZm9yIChjb25zdCBkdXBGaWxlUGF0aCBvZiByZXN1bHRTZXQuZHVwbGljYXRlX2ZpbGVfcGF0aHMpIHtcbiAgICAgICAgICAgICAgICAgY29uc3QgYXJjaGl2ZWRQYXRoID0gYCR7YXJjaGl2ZUZvbGRlclBhdGh9LyR7ZHVwRmlsZVBhdGguc3BsaXQoJy8nKS5wb3AoKX1gO1xuICAgICAgICAgICAgICAgICBtZXJnZUxvZ0NvbnRlbnQgKz0gYC0gW1ske2FyY2hpdmVkUGF0aH1dXVxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlUmVzdWx0c1RvT2JzaWRpYW5Ob3RlKHN1cnZpdm9yTG9nUGF0aCwgbWVyZ2VMb2dDb250ZW50LCAnZW5zdXJlX2V4aXN0c19hbmRfYXBwZW5kJywgc3Vydml2b3JGaWxlLmJhc2VuYW1lKTtcbiAgICBcbiAgICAgICAgICAgIC8vIDwtLSBORVc6IENyZWF0ZSBhbmQgYXBwZW5kIHRoZSBjb2xsYXBzaWJsZSBzdW1tYXJ5IGJsb2NrIHRvIHRoZSBzdXJ2aXZvciBmaWxlIGl0c2VsZi5cbiAgICAgICAgICAgIGxldCBtZXJnZVN1bW1hcnlCbG9jayA9IGBcbiAgICA8ZGV0YWlscz5cbiAgICA8c3VtbWFyeT5NZXJnZSBIaXN0b3J5PC9zdW1tYXJ5PlxuICAgIFxuICAgIFRoaXMgbm90ZSB3YXMgdGhlIHJlc3VsdCBvZiBhbiBhdXRvbWF0ZWQgZGVkdXBsaWNhdGlvbiBldmVudCBvbiAke25ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCl9LlxuICAgIC0gKipSaWdodEJyYWluIFJlYXNvbmluZzoqKiAke3Jlc3VsdFNldC5yZWFzb25pbmcgfHwgXCJOL0FcIn1cbiAgICAtIEZvciBhIGZ1bGwgYXVkaXQsIHNlZSB0aGUgW1ske3N1cnZpdm9yTG9nUGF0aH18QW5hbHlzaXMgTG9nXV0uXG4gICAgXG4gICAgPC9kZXRhaWxzPlxuICAgIGA7XG4gICAgICAgICAgICBmaW5hbENvbnRlbnQgKz0gYFxcblxcbiR7bWVyZ2VTdW1tYXJ5QmxvY2t9YDtcbiAgICBcbiAgICAgICAgICAgIC8vIC0tLSBTdGVwIDM6IFdyaXRlIHRoZSBmaW5hbCwgZW5oYW5jZWQgY29udGVudCBiYWNrIHRvIHRoZSBzdXJ2aXZvciBmaWxlIC0tLVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KHN1cnZpdm9yRmlsZSwgZmluYWxDb250ZW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbWVyZ2VDb3VudCsrO1xuICAgICAgICAgICAgbmV3IE5vdGljZShgTWVyZ2VkICR7cmVzdWx0U2V0LmR1cGxpY2F0ZV9maWxlX3BhdGhzLmxlbmd0aH0gZHVwbGljYXRlKHMpIGludG8gJHtzdXJ2aXZvckZpbGUuYmFzZW5hbWV9LmApO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmIChtZXJnZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgbmV3IE5vdGljZShgRGVkdXBsaWNhdGlvbiBmaW5pc2hlZC4gJHttZXJnZUNvdW50fSBtZXJnZSBvcGVyYXRpb25zIHBlcmZvcm1lZC5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJEZWR1cGxpY2F0aW9uIHByb2Nlc3MgZmluaXNoZWQsIGJ1dCBubyBhY3Rpb25hYmxlIG1lcmdlcyB3ZXJlIG1hZGUuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgcHJvY2Vzc01hbnVhbE1lcmdlKHN1cnZpdm9yRmlsZTogVEZpbGUsIGR1cGxpY2F0ZUZpbGVzOiBURmlsZVtdKSB7XG4gICAgICAgIGlmICghc3Vydml2b3JGaWxlIHx8IGR1cGxpY2F0ZUZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIk1lcmdlIGNhbmNlbGxlZDogTm8gc3Vydml2b3Igb3IgZHVwbGljYXRlcyBzZWxlY3RlZC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBuZXcgTm90aWNlKGBNZXJnaW5nICR7ZHVwbGljYXRlRmlsZXMubGVuZ3RofSBmaWxlKHMpIGludG8gJHtzdXJ2aXZvckZpbGUuYmFzZW5hbWV9Li4uYCwgNjAwMCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3Vydml2b3JDb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChzdXJ2aXZvckZpbGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyAtLS0gU3RlcCAxOiBHYXRoZXIgYWxsIGRhdGEgZnJvbSBzdXJ2aXZvciBhbmQgZHVwbGljYXRlcyAtLS1cbiAgICAgICAgICAgIGNvbnN0IHN1cnZpdm9yQ2FjaGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShzdXJ2aXZvckZpbGUpO1xuICAgICAgICAgICAgY29uc3QgYWxsQWxpYXNlcyA9IG5ldyBTZXQ8c3RyaW5nPigoc3Vydml2b3JDYWNoZT8uZnJvbnRtYXR0ZXI/LmFsaWFzZXMgfHwgW10pLm1hcChTdHJpbmcpKTtcbiAgICAgICAgICAgIGFsbEFsaWFzZXMuYWRkKHN1cnZpdm9yRmlsZS5iYXNlbmFtZSk7IC8vIEFkZCBzdXJ2aXZvcidzIG93biBuYW1lXG4gICAgICAgICAgICBjb25zdCBhbGxSb3dzID0gbmV3IFNldDxzdHJpbmc+KHRoaXMuZXh0cmFjdENsaWVudFRhYmxlUm93cyhvcmlnaW5hbFN1cnZpdm9yQ29udGVudCkpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGR1cEZpbGUgb2YgZHVwbGljYXRlRmlsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdXBDb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChkdXBGaWxlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkdXBDYWNoZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGR1cEZpbGUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEFkZCBkdXBsaWNhdGUncyBhbGlhc2VzIGFuZCBiYXNlbmFtZSB0byB0aGUgc2V0XG4gICAgICAgICAgICAgICAgKGR1cENhY2hlPy5mcm9udG1hdHRlcj8uYWxpYXNlcyB8fCBbXSkubWFwKFN0cmluZykuZm9yRWFjaChhbGlhcyA9PiBhbGxBbGlhc2VzLmFkZChhbGlhcykpO1xuICAgICAgICAgICAgICAgIGFsbEFsaWFzZXMuYWRkKGR1cEZpbGUuYmFzZW5hbWUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEFkZCBkdXBsaWNhdGUncyBcIlVzZWQgQnlcIiB0YWJsZSByb3dzIHRvIHRoZSBzZXRcbiAgICAgICAgICAgICAgICB0aGlzLmV4dHJhY3RDbGllbnRUYWJsZVJvd3MoZHVwQ29udGVudCkuZm9yRWFjaChyb3cgPT4gYWxsUm93cy5hZGQocm93KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIC0tLSBTdGVwIDI6IFJlYnVpbGQgdGhlIHN1cnZpdm9yIGZpbGUgd2l0aCBtZXJnZWQgZGF0YSAtLS1cbiAgICAgICAgICAgIGNvbnN0IGZtUmVnZXggPSAvXi0tLVxccypcXG4oW1xcc1xcU10qPylcXG4tLS1cXHMqXFxuLztcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gb3JpZ2luYWxTdXJ2aXZvckNvbnRlbnQubWF0Y2goZm1SZWdleCk7XG4gICAgICAgICAgICBsZXQgc3Vydml2b3JCb2R5ID0gbWF0Y2ggPyBvcmlnaW5hbFN1cnZpdm9yQ29udGVudC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKSA6IG9yaWdpbmFsU3Vydml2b3JDb250ZW50O1xuXG4gICAgICAgICAgICAvLyBSZWJ1aWxkIGZyb250bWF0dGVyXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1RhZ3MgPSBuZXcgU2V0PHN0cmluZz4oKHN1cnZpdm9yQ2FjaGU/LmZyb250bWF0dGVyPy50YWdzIHx8IFtdKS5tYXAoU3RyaW5nKSk7XG4gICAgICAgICAgICBsZXQgbmV3Rm1TdHJpbmcgPSBcIi0tLVxcblwiO1xuICAgICAgICAgICAgbmV3Rm1TdHJpbmcgKz0gYGFsaWFzZXM6IFske0FycmF5LmZyb20oYWxsQWxpYXNlcykubWFwKGEgPT4gYFwiJHthLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKX1cImApLmpvaW4oJywgJyl9XVxcbmA7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdUYWdzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgbmV3Rm1TdHJpbmcgKz0gYHRhZ3M6IFske0FycmF5LmZyb20oZXhpc3RpbmdUYWdzKS5tYXAodCA9PiBgXCIke3R9XCJgKS5qb2luKCcsICcpfV1cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3Rm1TdHJpbmcgKz0gXCItLS1cXG5cIjtcblxuICAgICAgICAgICAgLy8gUmVidWlsZCBcIlVzZWQgQnlcIiB0YWJsZVxuICAgICAgICAgICAgbGV0IGNsaWVudFRhYmxlTWQgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKGFsbFJvd3Muc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjbGllbnRUYWJsZU1kICs9IGB8IFByaW1hcnkgUHJvY2Vzc29yIHwgUHJvY2Vzc2luZyBGdW5jdGlvbiB8IExvY2F0aW9uIHwgU291cmNlIFVSTCB8XFxuYDtcbiAgICAgICAgICAgICAgICBjbGllbnRUYWJsZU1kICs9IGB8LS0tfC0tLXwtLS18LS0tfFxcbmA7XG4gICAgICAgICAgICAgICAgYWxsUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFRhYmxlTWQgKz0gYHwke3Jvd318XFxuYDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgXCJVc2VkIEJ5XCIgc2VjdGlvbiB3aXRoaW4gdGhlIHN1cnZpdm9yJ3MgYm9keVxuICAgICAgICAgICAgY29uc3QgZmluYWxCb2R5ID0gdGhpcy5lbnN1cmVIZWFkaW5nQW5kU2VjdGlvbihzdXJ2aXZvckJvZHksIFwiVXNlZCBCeVwiLCBjbGllbnRUYWJsZU1kLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsQ29udGVudCA9IG5ld0ZtU3RyaW5nICsgZmluYWxCb2R5O1xuXG4gICAgICAgICAgICAvLyAtLS0gU3RlcCAzOiBXcml0ZSB0byBzdXJ2aXZvciBhbmQgZGVsZXRlIGR1cGxpY2F0ZXMgLS0tXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoc3Vydml2b3JGaWxlLCBmaW5hbENvbnRlbnQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGR1cEZpbGUgb2YgZHVwbGljYXRlRmlsZXMpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5kZWxldGUoZHVwRmlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFN1Y2Nlc3NmdWxseSBtZXJnZWQgJHtkdXBsaWNhdGVGaWxlcy5sZW5ndGh9IGZpbGUocykgaW50byAke3N1cnZpdm9yRmlsZS5iYXNlbmFtZX0uYCk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcgbWFudWFsIG1lcmdlOlwiLCBlcnJvcik7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBtZXJnZS4gQ2hlY2sgdGhlIGRldmVsb3BlciBjb25zb2xlLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZXh0cmFjdENsaWVudFRhYmxlUm93cyhjb250ZW50OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IHJvd3M6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGxldCBpblVzZWRCeVNlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgbGV0IHRhYmxlSGFzU3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgaGVhZGluZyB0byBzdGFydCB0aGUgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKGxpbmUubWF0Y2goL14jIytcXHMqVXNlZCBCeVxccyokL2kpKSB7XG4gICAgICAgICAgICAgICAgaW5Vc2VkQnlTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0YWJsZUhhc1N0YXJ0ZWQgPSBmYWxzZTsgLy8gUmVzZXQgaW4gY2FzZSBvZiBtdWx0aXBsZSBcIlVzZWQgQnlcIiBzZWN0aW9uc1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbmNlIHdlIGFyZSBpbiB0aGUgcmlnaHQgc2VjdGlvbiwgbG9vayBmb3IgdGhlIHRhYmxlXG4gICAgICAgICAgICBpZiAoaW5Vc2VkQnlTZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZExpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBTdG9wIGlmIHdlIGhpdCBhbm90aGVyIGhlYWRpbmcgb2YgdGhlIHNhbWUgb3IgaGlnaGVyIGxldmVsXG4gICAgICAgICAgICAgICAgaWYgKHRyaW1tZWRMaW5lLnN0YXJ0c1dpdGgoJyMjJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Vc2VkQnlTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0YWJsZSBzZXBhcmF0b3IgdG8gYmVnaW4gY2FwdHVyaW5nIHJvd3NcbiAgICAgICAgICAgICAgICBpZiAodHJpbW1lZExpbmUubWF0Y2goL15cXHwtLS1cXHwvKSkge1xuICAgICAgICAgICAgICAgICAgICB0YWJsZUhhc1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdGFibGUgaGFzIHN0YXJ0ZWQsIGNhcHR1cmUgdmFsaWQgcm93IGNvbnRlbnRcbiAgICAgICAgICAgICAgICBpZiAodGFibGVIYXNTdGFydGVkICYmIHRyaW1tZWRMaW5lLnN0YXJ0c1dpdGgoJ3wnKSAmJiB0cmltbWVkTGluZS5lbmRzV2l0aCgnfCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgY29udGVudCBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBwaXBlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdHJpbW1lZExpbmUubWF0Y2goL15cXHwoLiopXFx8JC8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgaXQncyBhIGNvbnRlbnQgcm93LCBub3QgYW5vdGhlciBzZXBhcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hbMV0ubWF0Y2goL14tLS1cXHwvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2gobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YWJsZUhhc1N0YXJ0ZWQgJiYgdHJpbW1lZExpbmUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0YWJsZSBoYWQgc3RhcnRlZCBhbmQgd2UgZmluZCBhIG5vbi1lbXB0eSwgbm9uLXRhYmxlIHJvdywgYXNzdW1lIHRoZSB0YWJsZSBoYXMgZW5kZWQuXG4gICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfVxuXG5cbiAgICBhc3luYyBkaXNjb3ZlclJlY3Vyc2l2ZWx5KGluaXRpYWxQcm9jZXNzb3JOYW1lOiBzdHJpbmcsIGluaXRpYWxQcm9jZXNzb3JGaWxlPzogVEZpbGUsIG1heERlcHRoOiBudW1iZXIgPSAzKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYFN0YXJ0aW5nIHNtYXJ0IHJlY3Vyc2l2ZSBkaXNjb3ZlcnkgZm9yOiAke2luaXRpYWxQcm9jZXNzb3JOYW1lfS4gTWF4IGRlcHRoOiAke21heERlcHRofWAsIDEwMDAwKTtcblxuICAgICAgICBjb25zdCBhbGlhc01hcCA9IGF3YWl0IHRoaXMuYnVpbGRBbGlhc01hcCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NlZEluQ3VycmVudFJlY3Vyc2l2ZVNlYXJjaCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgICBjb25zdCBxdWV1ZTogQXJyYXk8eyBwcm9jZXNzb3JOYW1lOiBzdHJpbmcsIGRlcHRoOiBudW1iZXIgfT4gPSBbeyBwcm9jZXNzb3JOYW1lOiBpbml0aWFsUHJvY2Vzc29yTmFtZSwgZGVwdGg6IDAgfV07XG4gICAgICAgIGxldCBkaXNjb3ZlcmVkQ291bnQgPSAwO1xuICAgICAgICBsZXQgc2tpcHBlZENvdW50ID0gMDtcbiAgICBcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50KSBjb250aW51ZTtcbiAgICBcbiAgICAgICAgICAgIGxldCB7IHByb2Nlc3Nvck5hbWUsIGRlcHRoIH0gPSBjdXJyZW50O1xuICAgIFxuICAgICAgICAgICAgLy8gLS0tIFN0YXRlLUF3YXJlIFByb2Nlc3NpbmcgQ2hlY2sgLS0tXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0VudGl0eSA9IGFsaWFzTWFwLmdldChwcm9jZXNzb3JOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRQcm9jZXNzb3JGaWxlID0gZXhpc3RpbmdFbnRpdHkgPyB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZXhpc3RpbmdFbnRpdHkucGF0aCkgYXMgVEZpbGUgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByb2Nlc3NvckZpbGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGN1cnJlbnRQcm9jZXNzb3JGaWxlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGU/LmZyb250bWF0dGVyPy5bJ2Rpc2NvdmVyeS1zdGF0dXMnXSA9PT0gJ2NvbXBsZXRlJyAmJiBjYWNoZT8uZnJvbnRtYXR0ZXI/LlsnbGFzdC1kaXNjb3ZlcmVkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdFJ1biA9IG5ldyBEYXRlKGNhY2hlLmZyb250bWF0dGVyWydsYXN0LWRpc2NvdmVyZWQnXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cGlyeURhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBleHBpcnlEYXRlLnNldERhdGUoZXhwaXJ5RGF0ZS5nZXREYXRlKCkgLSB0aGlzLnNldHRpbmdzLmRpc2NvdmVyeUNhY2hlRGF5cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0UnVuID4gZXhwaXJ5RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVyYm9zZURlYnVnKSBjb25zb2xlLmxvZyhgU2tpcHBpbmcgcmVjZW50bHkgcHJvY2Vzc2VkOiAke3Byb2Nlc3Nvck5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBuZXcgTm90aWNlKGBSZWN1cnNpdmUgKGRlcHRoICR7ZGVwdGh9KTogUHJvY2Vzc2luZyAke3Byb2Nlc3Nvck5hbWV9Li4uYCk7XG4gICAgICAgICAgICBjb25zdCB7IGZpbGVQYXRoTmFtZTogc2FuaXRpemVkTmFtZUZvclRyYWNraW5nIH0gPSB0aGlzLnNhbml0aXplTmFtZUZvckZpbGVQYXRoQW5kQWxpYXMocHJvY2Vzc29yTmFtZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzZWRJbkN1cnJlbnRSZWN1cnNpdmVTZWFyY2guaGFzKHNhbml0aXplZE5hbWVGb3JUcmFja2luZykpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWRJbkN1cnJlbnRSZWN1cnNpdmVTZWFyY2guYWRkKHNhbml0aXplZE5hbWVGb3JUcmFja2luZyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGlzVG9wTGV2ZWwgPSBkZXB0aCA9PT0gMDtcbiAgICAgICAgICAgIGlmICghY3VycmVudFByb2Nlc3NvckZpbGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvY2Vzc29yRmlsZSA9IGF3YWl0IHRoaXMuZW5zdXJlUHJvY2Vzc29yRmlsZShwcm9jZXNzb3JOYW1lLCB0cnVlLCBpc1RvcExldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3VycmVudFByb2Nlc3NvckZpbGUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBkaXNjb3ZlcmVkQ291bnQrKztcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaERhdGEgPSBhd2FpdCB0aGlzLmZldGNoUHJvY2Vzc29yU2VhcmNoRGF0YVdpdGhEaXNjb3ZlcnkocHJvY2Vzc29yTmFtZSk7XG4gICAgXG4gICAgICAgICAgICBpZiAoc2VhcmNoRGF0YT8uY29sbGVjdGVkUmVsYXRpb25zaGlwcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdFN1Yk5hbWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KHNlYXJjaERhdGEuY29sbGVjdGVkUmVsYXRpb25zaGlwc1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHJlbCA9PiByZWwuUHJpbWFyeVByb2Nlc3NvciA9PT0gcHJvY2Vzc29yTmFtZSAmJiByZWwuUmVsYXRpb25zaGlwVHlwZSA9PT0gJ3VzZXNfc3VicHJvY2Vzc29yJylcbiAgICAgICAgICAgICAgICAgICAgLm1hcChyZWwgPT4gcmVsLlN1YnByb2Nlc3Nvck5hbWUudHJpbSgpKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKG5hbWUgPT4gbmFtZSkpKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlRGVjaXNpb25zTG9nOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIDwgbWF4RGVwdGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViTmFtZSBvZiBkaXJlY3RTdWJOYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FuaXRpemVkU3ViTmFtZUZvclRyYWNraW5nID0gdGhpcy5zYW5pdGl6ZU5hbWVGb3JGaWxlUGF0aEFuZEFsaWFzKHN1Yk5hbWUpLmZpbGVQYXRoTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NlZEluQ3VycmVudFJlY3Vyc2l2ZVNlYXJjaC5oYXMoc2FuaXRpemVkU3ViTmFtZUZvclRyYWNraW5nKSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTWFwcGluZyA9IGFsaWFzTWFwLmdldChzdWJOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVUb1F1ZXVlID0gc3ViTmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nTWFwcGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVUb1F1ZXVlID0gZXhpc3RpbmdNYXBwaW5nLmNhbm9uaWNhbE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk5hbWUgIT09IG5hbWVUb1F1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY2lzaW9uID0gYE1hcHBlZCBkaXNjb3ZlcmVkIG5hbWUgXCIke3N1Yk5hbWV9XCIgdG8gZXhpc3RpbmcgcHJvY2Vzc29yIFwiJHtuYW1lVG9RdWV1ZX1cIi5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZURlY2lzaW9uc0xvZy5wdXNoKGRlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0J3MgYSBuZXcgZW50aXR5LCBhZGQgaXQgdG8gb3VyIG1hcCBmb3IgdGhpcyBydW4gdG8gY2F0Y2ggZHVwbGljYXRlcyB3aXRoaW4gdGhlIHNhbWUgcnVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmaWxlUGF0aE5hbWUsIG9yaWdpbmFsTmFtZUFzQWxpYXMgfSA9IHRoaXMuc2FuaXRpemVOYW1lRm9yRmlsZVBhdGhBbmRBbGlhcyhzdWJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQYXRoID0gYCR7dGhpcy5zZXR0aW5ncy5wcm9jZXNzb3JzRm9sZGVyUGF0aH0vJHtmaWxlUGF0aE5hbWV9Lm1kYDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlhc01hcC5zZXQoc3ViTmFtZS50b0xvd2VyQ2FzZSgpLCB7IHBhdGg6IG5ld1BhdGgsIGNhbm9uaWNhbE5hbWU6IG9yaWdpbmFsTmFtZUFzQWxpYXMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcXVldWUuc29tZShxID0+IHEucHJvY2Vzc29yTmFtZSA9PT0gbmFtZVRvUXVldWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaCh7IHByb2Nlc3Nvck5hbWU6IG5hbWVUb1F1ZXVlLCBkZXB0aDogZGVwdGggKyAxIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdFN1YnByb2Nlc3NvckluZm8ocHJvY2Vzc29yTmFtZSwgY3VycmVudFByb2Nlc3NvckZpbGUsIHNlYXJjaERhdGEsIGlzVG9wTGV2ZWwsIG1lcmdlRGVjaXNpb25zTG9nKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZURpc2NvdmVyeVN0YXR1cyhjdXJyZW50UHJvY2Vzc29yRmlsZSwgJ2NvbXBsZXRlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlRGlzY292ZXJ5U3RhdHVzKGN1cnJlbnRQcm9jZXNzb3JGaWxlLCAnaW5jb21wbGV0ZScpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIG5ldyBOb3RpY2UoYFJlY3Vyc2l2ZSBkaXNjb3ZlcnkgY29tcGxldGUuIFByb2Nlc3NlZCAke2Rpc2NvdmVyZWRDb3VudH0gZW50aXRpZXMsIHNraXBwZWQgJHtza2lwcGVkQ291bnR9IHJlY2VudCBvbmVzLmAsIDEwMDAwKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWRJbkN1cnJlbnRSZWN1cnNpdmVTZWFyY2guY2xlYXIoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9wZW5GaWxlU2VsZWN0b3JNZXJnZU1vZGFsKCkge1xuICAgICAgICBjb25zdCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKS5maWx0ZXIoZmlsZSA9PiBmaWxlLnBhdGguc3RhcnRzV2l0aCh0aGlzLnNldHRpbmdzLnByb2Nlc3NvcnNGb2xkZXJQYXRoICsgXCIvXCIpKTtcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJUaGVyZSBhcmUgbm90IGVub3VnaCBwcm9jZXNzb3IgZmlsZXMgdG8gcGVyZm9ybSBhIG1lcmdlLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ldyBGaWxlU2VsZWN0b3JNZXJnZU1vZGFsKHRoaXMuYXBwLCBmaWxlcywgKHNlbGVjdGVkRmlsZXMpID0+IHtcbiAgICAgICAgICAgIC8vIEFmdGVyIHRoZSB1c2VyIHNlbGVjdHMgZmlsZXMsIHdlIG9wZW4gdGhlIHNlY29uZCBtb2RhbCB0byBjaG9vc2UgdGhlIHN1cnZpdm9yLlxuICAgICAgICAgICAgbmV3IEZvcmNlTWVyZ2VNb2RhbCh0aGlzLmFwcCwgc2VsZWN0ZWRGaWxlcywgKHN1cnZpdm9yLCBkdXBsaWNhdGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTWFudWFsTWVyZ2Uoc3Vydml2b3IsIGR1cGxpY2F0ZXMpO1xuICAgICAgICAgICAgfSkub3BlbigpO1xuICAgICAgICB9KS5vcGVuKCk7XG4gICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHByZS1kZWZpbmVkIGNvbmZpZ3VyYXRpb24gdG8gdGhlIGdyYXBoLmpzb24gZmlsZS5cbiAgICAgKi9cbiAgICBhc3luYyBhcHBseVJlY29tbWVuZGVkR3JhcGhTZXR0aW5ncygpIHtcbiAgICAgICAgLy8gRGVmaW5lIG91ciBpZGVhbCBncmFwaCBzZXR0aW5nc1xuICAgICAgICBjb25zdCBncmFwaFNldHRpbmdzID0ge1xuICAgICAgICAgICAgXCJjb2xsYXBzZS1maWx0ZXJcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2VhcmNoXCI6IGBwYXRoOlwiJHt0aGlzLnNldHRpbmdzLnByb2Nlc3NvcnNGb2xkZXJQYXRofVwiIC1wYXRoOlwiJHt0aGlzLnNldHRpbmdzLnByb2Nlc3NvcnNGb2xkZXJQYXRofS9fQXJjaGl2ZVwiYCwgXG4gICAgICAgICAgICBcInNob3dUYWdzXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJzaG93QXR0YWNobWVudHNcIjogZmFsc2UsXG4gICAgICAgICAgICBcImhpZGVVbnJlc29sdmVkXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dPcnBoYW5zXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJjb2xsYXBzZS1jb2xvci1ncm91cHNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiY29sb3JHcm91cHNcIjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcInF1ZXJ5XCI6IFwidGFnOiNwcm9jZXNzb3JcIixcbiAgICAgICAgICAgICAgICBcImNvbG9yXCI6IHsgXCJhXCI6IDEsIFwicmdiXCI6IDE0MDI1NzI4IH0gLy8gUmVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJxdWVyeVwiOiBcInRhZzojc3VicHJvY2Vzc29yXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvclwiOiB7IFwiYVwiOiAxLCBcInJnYlwiOiA2MDg0MTgyIH0gLy8gR3JlZW5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcInF1ZXJ5XCI6IFwidGFnOiNtZXJnZWQtcHJvY2Vzc29yXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvclwiOiB7IFwiYVwiOiAxLCBcInJnYlwiOiA2MDY5OTYyIH0gLy8gQmx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImNvbGxhcHNlLWRpc3BsYXlcIjogZmFsc2UsXG4gICAgICAgICAgICBcInNob3dBcnJvd1wiOiB0cnVlLCAvLyBTaG93IGxpbmsgZGlyZWN0aW9uXG4gICAgICAgICAgICBcInRleHRGYWRlTXVsdGlwbGllclwiOiAtMi4zLFxuICAgICAgICAgICAgXCJub2RlU2l6ZU11bHRpcGxpZXJcIjogMS4yLFxuICAgICAgICAgICAgXCJsaW5lU2l6ZU11bHRpcGxpZXJcIjogMSxcbiAgICAgICAgICAgIFwiY29sbGFwc2UtZm9yY2VzXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJjZW50ZXJTdHJlbmd0aFwiOiAwLjUsXG4gICAgICAgICAgICBcInJlcGVsU3RyZW5ndGhcIjogMTIsXG4gICAgICAgICAgICBcImxpbmtTdHJlbmd0aFwiOiAxLFxuICAgICAgICAgICAgXCJsaW5rRGlzdGFuY2VcIjogMjUwLFxuICAgICAgICAgICAgXCJzY2FsZVwiOiAwLjUsXG4gICAgICAgICAgICBcImNsb3NlXCI6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgY29uZmlnUGF0aCA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpciArICcvZ3JhcGguanNvbic7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLndyaXRlKGNvbmZpZ1BhdGgsIEpTT04uc3RyaW5naWZ5KGdyYXBoU2V0dGluZ3MsIG51bGwsIDIpKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJSZWNvbW1lbmRlZCBncmFwaCBzZXR0aW5ncyBoYXZlIGJlZW4gYXBwbGllZC4gUGxlYXNlIHJlb3BlbiB0aGUgZ3JhcGggdmlldyB0byBzZWUgdGhlIGNoYW5nZXMuXCIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byB3cml0ZSBncmFwaCBzZXR0aW5nczpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIkVycm9yOiBDb3VsZCBub3QgYXBwbHkgZ3JhcGggc2V0dGluZ3MuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cblxuLy8gLS0tLS0gTU9EQUwgQ0xBU1NFUyAtLS0tLVxuY2xhc3MgTWFudWFsSW5wdXRNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgICBwcm9jZXNzb3JOYW1lOiBzdHJpbmcgPSAnJztcbiAgICBsaXN0VXJsOiBzdHJpbmcgPSAnJztcbiAgICBpc1ByaW1hcnlQcm9jZXNzb3I6IGJvb2xlYW4gPSB0cnVlOyAvLyA8LS0gTmV3IHN0YXRlIHZhcmlhYmxlLCBkZWZhdWx0cyB0byB0cnVlXG4gICAgb25TdWJtaXQ6IChwcm9jZXNzb3JOYW1lOiBzdHJpbmcsIGxpc3RVcmw6IHN0cmluZywgaXNQcmltYXJ5OiBib29sZWFuKSA9PiBQcm9taXNlPHZvaWQ+OyAvLyA8LS0gVXBkYXRlZCBzaWduYXR1cmVcbiAgICBpbml0aWFsUHJvY2Vzc29yTmFtZT86IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBvblN1Ym1pdDogKHByb2Nlc3Nvck5hbWU6IHN0cmluZywgbGlzdFVybDogc3RyaW5nLCBpc1ByaW1hcnk6IGJvb2xlYW4pID0+IFByb21pc2U8dm9pZD4sIGluaXRpYWxQcm9jZXNzb3JOYW1lPzogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKGFwcCk7XG4gICAgICAgIHRoaXMub25TdWJtaXQgPSBvblN1Ym1pdDtcbiAgICAgICAgdGhpcy5pbml0aWFsUHJvY2Vzc29yTmFtZSA9IGluaXRpYWxQcm9jZXNzb3JOYW1lO1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsUHJvY2Vzc29yTmFtZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzb3JOYW1lID0gdGhpcy5pbml0aWFsUHJvY2Vzc29yTmFtZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdNYW51YWxseSBBZGQgU3VicHJvY2Vzc29yIExpc3QgVVJMJyB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUHJvY2Vzc29yIE5hbWUnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0VudGVyIHRoZSBuYW1lIG9mIHRoZSBwcmltYXJ5IHByb2Nlc3NvciAoZS5nLiwgT3BlbkFJKS4nKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignRW50ZXIgcHJvY2Vzc29yIG5hbWUnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wcm9jZXNzb3JOYW1lKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4gdGhpcy5wcm9jZXNzb3JOYW1lID0gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5pbnB1dEVsLnNldEF0dHIoXCJyZXF1aXJlZFwiLCBcInRydWVcIik7IFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluaXRpYWxQcm9jZXNzb3JOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQuc2V0RGlzYWJsZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1N1YnByb2Nlc3NvciBMaXN0IFVSTCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnRW50ZXIgdGhlIGRpcmVjdCBVUkwgdG8gdGhlIHN1YnByb2Nlc3NvciBsaXN0IG9yIERQQSBwYWdlLicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignaHR0cHM6Ly9leGFtcGxlLmNvbS9zdWJwcm9jZXNzb3JzJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMubGlzdFVybClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHRoaXMubGlzdFVybCA9IHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuaW5wdXRFbC5zZXRBdHRyKFwicmVxdWlyZWRcIiwgXCJ0cnVlXCIpKTtcblxuICAgICAgICAvLyBOZXcgXCJJcyBQcmltYXJ5XCIgVG9nZ2xlIFNldHRpbmdcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0lzIGEgcHJpbWFyeSBwcm9jZXNzb3I/JylcbiAgICAgICAgICAgIC5zZXREZXNjKCdFbmFibGUgdGhpcyBpZiB5b3UgYXJlIGluaXRpYXRpbmcgYSBzZWFyY2ggb24gdGhpcyBwcm9jZXNzb3IuIERpc2FibGUgaWYgeW91IGFyZSBhZGRpbmcgYSBzdWJwcm9jZXNzb3Igb2YgYW5vdGhlciBlbnRpdHkuJylcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLmlzUHJpbWFyeVByb2Nlc3NvcilcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4gdGhpcy5pc1ByaW1hcnlQcm9jZXNzb3IgPSB2YWx1ZSkpO1xuXG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT5cbiAgICAgICAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dCgnUHJvY2VzcyBVUkwnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0Q3RhKClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uIHZhbGlkYXRpb24gY2hlY2tzIC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblN1Ym1pdCh0aGlzLnByb2Nlc3Nvck5hbWUsIHRoaXMubGlzdFVybCwgdGhpcy5pc1ByaW1hcnlQcm9jZXNzb3IpOyAvLyA8LS0gUGFzcyB0aGUgbmV3IGZsYWdcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY29udGVudEVsLmVtcHR5KCk7XG4gICAgfVxufVxuXG5jbGFzcyBTZWFyY2hNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgICBwcm9jZXNzb3JOYW1lOiBzdHJpbmcgPSAnJztcbiAgICBzZXR0aW5nczogUHJvY2Vzc29yUHJvY2Vzc29yU2V0dGluZ3M7IC8vIFRvIGluZm9ybSB1c2VyIGFib3V0IHNlYXJjaCBtZXRob2RcbiAgICBvblN1Ym1pdDogKHByb2Nlc3Nvck5hbWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBzZXR0aW5nczogUHJvY2Vzc29yUHJvY2Vzc29yU2V0dGluZ3MsIG9uU3VibWl0OiAocHJvY2Vzc29yTmFtZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+KSB7XG4gICAgICAgIHN1cGVyKGFwcCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5vblN1Ym1pdCA9IG9uU3VibWl0O1xuICAgIH1cblxuICAgIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdEaXNjb3ZlciBTdWJwcm9jZXNzb3JzJyB9KTtcblxuICAgICAgICBsZXQgc2VhcmNoTWV0aG9kTm90ZSA9IFwiU2VhcmNoIHdpbGwgYmUgcGVyZm9ybWVkIHVzaW5nIGF2YWlsYWJsZSBjb25maWd1cmVkIG1ldGhvZHMuXCI7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNlcnBBcGlLZXkpIHtcbiAgICAgICAgICAgIHNlYXJjaE1ldGhvZE5vdGUgPSBcIlNlYXJjaCB3aWxsIHByaW1hcmlseSB1c2UgU2VycEFQSS5cIjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5PcmdJZCAmJiB0aGlzLnNldHRpbmdzLnJpZ2h0YnJhaW5Qcm9qZWN0SWQgJiYgdGhpcy5zZXR0aW5ncy5yaWdodGJyYWluRHVja0R1Y2tHb1NlYXJjaFRhc2tJZCkge1xuICAgICAgICAgICAgc2VhcmNoTWV0aG9kTm90ZSA9IFwiU2VycEFQSSBrZXkgbm90IGZvdW5kLiBTZWFyY2ggd2lsbCB1c2UgRHVja0R1Y2tHbyB2aWEgUmlnaHRCcmFpbi5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlYXJjaE1ldGhvZE5vdGUgPSBcIk5laXRoZXIgU2VycEFQSSBub3IgUmlnaHRCcmFpbiBEdWNrRHVja0dvIHNlYXJjaCBpcyBmdWxseSBjb25maWd1cmVkLiBEaXNjb3ZlcnkgbWlnaHQgYmUgbGltaXRlZC5cIjtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IHNlYXJjaE1ldGhvZE5vdGUgfSk7XG5cblxuICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUHJvY2Vzc29yIE5hbWUnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0VudGVyIHRoZSBuYW1lIG9mIHRoZSBwcm9jZXNzb3IgdG8gc2VhcmNoIGZvciAoZS5nLiwgU3RyaXBlKS4nKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PlxuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHByb2Nlc3NvciBuYW1lJylcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucHJvY2Vzc29yTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHRoaXMucHJvY2Vzc29yTmFtZSA9IHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuaW5wdXRFbC5zZXRBdHRyKFwicmVxdWlyZWRcIiwgXCJ0cnVlXCIpKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PlxuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdTdGFydCBEaXNjb3ZlcnknKVxuICAgICAgICAgICAgICAgICAgICAuc2V0Q3RhKClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3Nvck5hbWUudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIlByb2Nlc3NvciBOYW1lIGlzIHJlcXVpcmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU3VibWl0KHRoaXMucHJvY2Vzc29yTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBvbkNsb3NlKCkge1xuICAgICAgICB0aGlzLmNvbnRlbnRFbC5lbXB0eSgpO1xuICAgIH1cbn1cblxuY2xhc3MgTWFudWFsVGV4dEVudHJ5TW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gICAgcHJvY2Vzc29yTmFtZTogc3RyaW5nID0gJyc7XG4gICAgcGFzdGVkVGV4dDogc3RyaW5nID0gJyc7XG4gICAgaXNQcmltYXJ5UHJvY2Vzc29yOiBib29sZWFuID0gdHJ1ZTsgLy8gPC0tIE5ldyBzdGF0ZSB2YXJpYWJsZSwgZGVmYXVsdHMgdG8gdHJ1ZVxuICAgIG9uU3VibWl0OiAocHJvY2Vzc29yTmFtZTogc3RyaW5nLCBwYXN0ZWRUZXh0OiBzdHJpbmcsIGlzUHJpbWFyeTogYm9vbGVhbikgPT4gUHJvbWlzZTx2b2lkPjsgLy8gPC0tIFVwZGF0ZWQgc2lnbmF0dXJlXG4gICAgaW5pdGlhbFByb2Nlc3Nvck5hbWU/OiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgb25TdWJtaXQ6IChwcm9jZXNzb3JOYW1lOiBzdHJpbmcsIHBhc3RlZFRleHQ6IHN0cmluZywgaXNQcmltYXJ5OiBib29sZWFuKSA9PiBQcm9taXNlPHZvaWQ+LCBpbml0aWFsUHJvY2Vzc29yTmFtZT86IHN0cmluZykge1xuICAgICAgICBzdXBlcihhcHApO1xuICAgICAgICB0aGlzLm9uU3VibWl0ID0gb25TdWJtaXQ7XG4gICAgICAgIHRoaXMuaW5pdGlhbFByb2Nlc3Nvck5hbWUgPSBpbml0aWFsUHJvY2Vzc29yTmFtZTtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFByb2Nlc3Nvck5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc29yTmFtZSA9IHRoaXMuaW5pdGlhbFByb2Nlc3Nvck5hbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnSW5wdXQgU3VicHJvY2Vzc29yIExpc3QgZnJvbSBUZXh0JyB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUHJvY2Vzc29yIE5hbWUnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0VudGVyIHRoZSBuYW1lIG9mIHRoZSBwcmltYXJ5IHByb2Nlc3NvciB0aGlzIHRleHQgYmVsb25ncyB0by4nKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcignRW50ZXIgcHJvY2Vzc29yIG5hbWUnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wcm9jZXNzb3JOYW1lKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4gdGhpcy5wcm9jZXNzb3JOYW1lID0gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5pbnB1dEVsLnNldEF0dHIoXCJyZXF1aXJlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFByb2Nlc3Nvck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5zZXREaXNhYmxlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgXG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0lzIGEgcHJpbWFyeSBwcm9jZXNzb3I/JylcbiAgICAgICAgICAgIC5zZXREZXNjKCdFbmFibGUgdGhpcyBpZiB5b3UgYXJlIGluaXRpYXRpbmcgYSBzZWFyY2ggb24gdGhpcyBwcm9jZXNzb3IuIERpc2FibGUgaWYgeW91IGFyZSBhZGRpbmcgYSBzdWJwcm9jZXNzb3Igb2YgYW5vdGhlciBlbnRpdHkuJylcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLmlzUHJpbWFyeVByb2Nlc3NvcilcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4gdGhpcy5pc1ByaW1hcnlQcm9jZXNzb3IgPSB2YWx1ZSkpO1xuXG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogJ1Bhc3RlIHRoZSBzdWJwcm9jZXNzb3IgbGlzdCB0ZXh0IGJlbG93OicgfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0ZXh0QXJlYSA9IG5ldyBUZXh0QXJlYUNvbXBvbmVudChjb250ZW50RWwpXG4gICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ1Bhc3RlIHRleHQgaGVyZS4uLicpXG4gICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wYXN0ZWRUZXh0KVxuICAgICAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHRoaXMucGFzdGVkVGV4dCA9IHZhbHVlKTtcbiAgICAgICAgdGV4dEFyZWEuaW5wdXRFbC5yb3dzID0gMTA7XG4gICAgICAgIHRleHRBcmVhLmlucHV0RWwuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHRleHRBcmVhLmlucHV0RWwuc2V0QXR0cihcInJlcXVpcmVkXCIsIFwidHJ1ZVwiKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PlxuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdQcm9jZXNzIFRleHQnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0Q3RhKClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uIHZhbGlkYXRpb24gY2hlY2tzIC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblN1Ym1pdCh0aGlzLnByb2Nlc3Nvck5hbWUsIHRoaXMucGFzdGVkVGV4dCwgdGhpcy5pc1ByaW1hcnlQcm9jZXNzb3IpOyAvLyA8LS0gUGFzcyB0aGUgbmV3IGZsYWdcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY29udGVudEVsLmVtcHR5KCk7XG4gICAgfVxufVxuXG5jbGFzcyBGb3JjZU1lcmdlTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gICAgZmlsZXM6IFRGaWxlW107XG4gICAgb25TdWJtaXQ6IChzdXJ2aXZvcjogVEZpbGUsIGR1cGxpY2F0ZXM6IFRGaWxlW10pID0+IHZvaWQ7XG4gICAgcHJpdmF0ZSBzdXJ2aXZvcjogVEZpbGUgfCBudWxsID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBmaWxlczogVEZpbGVbXSwgb25TdWJtaXQ6IChzdXJ2aXZvcjogVEZpbGUsIGR1cGxpY2F0ZXM6IFRGaWxlW10pID0+IHZvaWQpIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICAgICAgLy8gRW5zdXJlIGZpbGVzIGFyZSBzb3J0ZWQgYWxwaGFiZXRpY2FsbHkgZm9yIHRoZSB1c2VyXG4gICAgICAgIHRoaXMuZmlsZXMgPSBmaWxlcy5zb3J0KChhLCBiKSA9PiBhLmJhc2VuYW1lLmxvY2FsZUNvbXBhcmUoYi5iYXNlbmFtZSkpO1xuICAgICAgICB0aGlzLm9uU3VibWl0ID0gb25TdWJtaXQ7XG4gICAgfVxuXG4gICAgb25PcGVuKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0ZvcmNlIE1lcmdlIFByb2Nlc3NvcnMnIH0pO1xuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6ICdTZWxlY3QgdGhlIGZpbGUgdG8ga2VlcCAodGhlIFwic3Vydml2b3JcIikuIEFsbCBvdGhlciBzZWxlY3RlZCBmaWxlcyB3aWxsIGJlIG1lcmdlZCBpbnRvIGl0IGFuZCB0aGVuIGRlbGV0ZWQuJyB9KTtcbiAgICBcbiAgICAgICAgbGV0IG1lcmdlQnV0dG9uOiBCdXR0b25Db21wb25lbnQ7XG4gICAgXG4gICAgICAgIGNvbnN0IHJhZGlvR3JvdXAgPSBjb250ZW50RWwuY3JlYXRlRGl2KCk7XG4gICAgXG4gICAgICAgIHRoaXMuZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyhyYWRpb0dyb3VwKVxuICAgICAgICAgICAgICAgIC5zZXROYW1lKGZpbGUuYmFzZW5hbWUpXG4gICAgICAgICAgICAgICAgLnNldERlc2MoZmlsZS5wYXRoKTtcbiAgICBcbiAgICAgICAgICAgIC8vIFRoaXMgY3JlYXRlcyBhIFJBRElPIEJVVFRPTiBmb3Igc2luZ2xlIHNlbGVjdGlvblxuICAgICAgICAgICAgY29uc3QgcmFkaW8gPSBjcmVhdGVFbCgnaW5wdXQnLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3JhZGlvJyxcbiAgICAgICAgICAgICAgICBjbHM6ICdmb3JjZS1tZXJnZS1yYWRpbydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmFkaW8ubmFtZSA9IFwic3Vydml2b3Itc2VsZWN0aW9uXCI7XG4gICAgICAgICAgICByYWRpby52YWx1ZSA9IGZpbGUucGF0aDtcbiAgICAgICAgICAgIHJhZGlvLm9uY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vydml2b3IgPSBmaWxlO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29ycmVjdGx5IGVuYWJsZXMgdGhlIG1lcmdlIGJ1dHRvblxuICAgICAgICAgICAgICAgIG1lcmdlQnV0dG9uLnNldERpc2FibGVkKGZhbHNlKS5zZXRDdGEodHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgc2V0dGluZy5jb250cm9sRWwuYXBwZW5kQ2hpbGQocmFkaW8pO1xuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGVudEVsKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidG4gPT4gYnRuXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0NhbmNlbCcpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4gdGhpcy5jbG9zZSgpKSlcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnRuID0+IHtcbiAgICAgICAgICAgICAgICBtZXJnZUJ1dHRvbiA9IGJ0bjtcbiAgICAgICAgICAgICAgICBidG4uc2V0QnV0dG9uVGV4dCgnTWVyZ2UnKVxuICAgICAgICAgICAgICAgICAgICAuc2V0RGlzYWJsZWQodHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3Vydml2b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkdXBsaWNhdGVzID0gdGhpcy5maWxlcy5maWx0ZXIoZiA9PiBmLnBhdGggIT09IHRoaXMuc3Vydml2b3IhLnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU3VibWl0KHRoaXMuc3Vydml2b3IsIGR1cGxpY2F0ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY29udGVudEVsLmVtcHR5KCk7XG4gICAgfVxufVxuXG5jbGFzcyBDb25maXJtYXRpb25Nb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcHJpdmF0ZSBvbkNvbmZpcm06ICgpID0+IHZvaWQpIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICB9XG5cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnT3ZlcndyaXRlIEdyYXBoIFNldHRpbmdzPycgfSk7XG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogJ1RoaXMgd2lsbCByZXBsYWNlIHlvdXIgY3VycmVudCBnbG9iYWwgZ3JhcGggdmlldyBzZXR0aW5ncyB3aXRoIHRoZSByZWNvbW1lbmRlZCBjb25maWd1cmF0aW9uIGZvciB0aGlzIHBsdWdpbi4gWW91ciBleGlzdGluZyBzZXR0aW5ncyB3aWxsIGJlIGxvc3QuJyB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ0biA9PiBidG5cbiAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCgnQ2FuY2VsJylcbiAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnRuID0+IGJ0blxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdZZXMsIE92ZXJ3cml0ZScpXG4gICAgICAgICAgICAgICAgLnNldEN0YSgpIC8vIE1ha2VzIHRoZSBidXR0b24gc3RhbmQgb3V0XG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ29uZmlybSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY29udGVudEVsLmVtcHR5KCk7XG4gICAgfVxufVxuXG5jbGFzcyBGaWxlU2VsZWN0b3JNZXJnZU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICAgIGZpbGVzOiBURmlsZVtdO1xuICAgIG9uU3VibWl0OiAoc2VsZWN0ZWRGaWxlczogVEZpbGVbXSkgPT4gdm9pZDtcbiAgICBwcml2YXRlIHNlbGVjdGVkRmlsZVBhdGhzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBmaWxlczogVEZpbGVbXSwgb25TdWJtaXQ6IChzZWxlY3RlZEZpbGVzOiBURmlsZVtdKSA9PiB2b2lkKSB7XG4gICAgICAgIHN1cGVyKGFwcCk7XG4gICAgICAgIHRoaXMuZmlsZXMgPSBmaWxlcy5zb3J0KChhLCBiKSA9PiBhLmJhc2VuYW1lLmxvY2FsZUNvbXBhcmUoYi5iYXNlbmFtZSkpO1xuICAgICAgICB0aGlzLm9uU3VibWl0ID0gb25TdWJtaXQ7XG4gICAgfVxuXG4gICAgb25PcGVuKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGVudEVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1NlbGVjdCBGaWxlcyB0byBNZXJnZScgfSk7XG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogJ0Nob29zZSB0d28gb3IgbW9yZSBwcm9jZXNzb3IgZmlsZXMgZnJvbSB0aGUgbGlzdCBiZWxvdy4nIH0pO1xuICAgIFxuICAgICAgICBsZXQgbmV4dEJ1dHRvbjogQnV0dG9uQ29tcG9uZW50O1xuICAgIFxuICAgICAgICBjb25zdCBjaGVja2JveEdyb3VwID0gY29udGVudEVsLmNyZWF0ZURpdigpO1xuICAgICAgICBjaGVja2JveEdyb3VwLmFkZENsYXNzKCdwcm9jZXNzb3ItZmlsZS1zZWxlY3Rvci1saXN0Jyk7XG4gICAgXG4gICAgICAgIHRoaXMuZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyhjaGVja2JveEdyb3VwKVxuICAgICAgICAgICAgICAgIC5zZXROYW1lKGZpbGUuYmFzZW5hbWUpXG4gICAgICAgICAgICAgICAgLnNldERlc2MoZmlsZS5wYXRoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVGhpcyBjcmVhdGVzIGEgQ0hFQ0tCT1ggZm9yIG11bHRpcGxlIHNlbGVjdGlvbnNcbiAgICAgICAgICAgIHNldHRpbmcuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLm9uQ2hhbmdlKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRmlsZVBhdGhzLmFkZChmaWxlLnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEZpbGVQYXRocy5kZWxldGUoZmlsZS5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNvcnJlY3RseSBlbmFibGVzIHRoZSBidXR0b24gd2hlbiAyIG9yIG1vcmUgYXJlIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIG5leHRCdXR0b24uc2V0RGlzYWJsZWQodGhpcy5zZWxlY3RlZEZpbGVQYXRocy5zaXplIDwgMik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnRuID0+IGJ0blxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KCdDYW5jZWwnKVxuICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHRoaXMuY2xvc2UoKSkpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ0biA9PiB7XG4gICAgICAgICAgICAgICAgbmV4dEJ1dHRvbiA9IGJ0bjtcbiAgICAgICAgICAgICAgICBidG4uc2V0QnV0dG9uVGV4dCgnTmV4dDogU2VsZWN0IFN1cnZpdm9yJylcbiAgICAgICAgICAgICAgICAgICAgLnNldEN0YSgpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZCh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZEZpbGVzID0gdGhpcy5maWxlcy5maWx0ZXIoZiA9PiB0aGlzLnNlbGVjdGVkRmlsZVBhdGhzLmhhcyhmLnBhdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TdWJtaXQoc2VsZWN0ZWRGaWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBQYXN0ZUVudk1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICAgIHBhc3RlZFRleHQ6IHN0cmluZyA9ICcnO1xuICAgIHBsdWdpbjogUHJvY2Vzc29yUHJvY2Vzc29yUGx1Z2luO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogUHJvY2Vzc29yUHJvY2Vzc29yUGx1Z2luKSB7XG4gICAgICAgIHN1cGVyKGFwcCk7XG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIH1cblxuICAgIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdDb21wbGV0ZSBQbHVnaW4gU2V0dXAnIH0pO1xuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6ICdQYXN0ZSB0aGUgZW50aXJlIGJsb2NrIG9mIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHlvdXIgUmlnaHRCcmFpbiBkYXNoYm9hcmQgYmVsb3cuIFRoaXMgd2lsbCBzYXZlIHlvdXIgY3JlZGVudGlhbHMgYW5kIHRoZW4gYXV0b21hdGljYWxseSBjcmVhdGUgdGhlIG5lY2Vzc2FyeSBBSSB0YXNrcyBpbiB5b3VyIHByb2plY3QuJyB9KTtcblxuICAgICAgICBjb25zdCB0ZXh0QXJlYSA9IG5ldyBUZXh0QXJlYUNvbXBvbmVudChjb250ZW50RWwpXG4gICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ1JCX09SR19JRD1cIi4uLlwiXFxuUkJfUFJPSkVDVF9JRD1cIi4uLlwiJylcbiAgICAgICAgICAgIC5vbkNoYW5nZSh2YWx1ZSA9PiB0aGlzLnBhc3RlZFRleHQgPSB2YWx1ZSk7XG4gICAgICAgIHRleHRBcmVhLmlucHV0RWwucm93cyA9IDEyO1xuICAgICAgICB0ZXh0QXJlYS5pbnB1dEVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICB0ZXh0QXJlYS5pbnB1dEVsLnN0eWxlLmZvbnRGYW1pbHkgPSAnbW9ub3NwYWNlJztcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PlxuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdCZWdpbiBTZXR1cCcpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXN0ZWRUZXh0LnRyaW0oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbm93IHRyaWdnZXJzIHRoZSBlbnRpcmUgc2V0dXAgZmxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnVuRnVsbFNldHVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiVGV4dCBhcmVhIGlzIGVtcHR5LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY29udGVudEVsLmVtcHR5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBwYXN0ZWQgdGV4dCwgc2F2ZXMgY3JlZGVudGlhbHMsIHRoZW4gcHJvY2VlZHMgdG8gc2V0IHVwIHRhc2tzLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkZ1bGxTZXR1cCgpIHtcbiAgICAgICAgLy8gLS0tIFBhcnQgMTogUGFyc2UgYW5kIFNhdmUgQ3JlZGVudGlhbHMgLS0tXG4gICAgICAgIGNvbnN0IGxpbmVzID0gdGhpcy5wYXN0ZWRUZXh0LnRyaW0oKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzVG9VcGRhdGU6IFBhcnRpYWw8UHJvY2Vzc29yUHJvY2Vzc29yU2V0dGluZ3M+ID0ge307XG4gICAgICAgIFxuICAgICAgICBjb25zdCBrZXlNYXA6IHsgW2tleTogc3RyaW5nXToga2V5b2YgUHJvY2Vzc29yUHJvY2Vzc29yU2V0dGluZ3MgfSA9IHtcbiAgICAgICAgICAgICdSQl9PUkdfSUQnOiAncmlnaHRicmFpbk9yZ0lkJyxcbiAgICAgICAgICAgICdSQl9QUk9KRUNUX0lEJzogJ3JpZ2h0YnJhaW5Qcm9qZWN0SWQnLFxuICAgICAgICAgICAgJ1JCX0NMSUVOVF9JRCc6ICdyaWdodGJyYWluQ2xpZW50SWQnLFxuICAgICAgICAgICAgJ1JCX0NMSUVOVF9TRUNSRVQnOiAncmlnaHRicmFpbkNsaWVudFNlY3JldCcsXG4gICAgICAgICAgICAnUkJfQVBJX1VSTCc6ICdyaWdodGJyYWluQXBpVXJsJyxcbiAgICAgICAgICAgICdSQl9PQVVUSDJfVVJMJzogJ3JpZ2h0YnJhaW5PYXV0aDJVcmwnXG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMikgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBwYXJ0c1swXS50cmltKCk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBwYXJ0cy5zbGljZSgxKS5qb2luKCc9JykudHJpbSgpLnJlcGxhY2UoL1tcIiddL2csICcnKTtcbiAgICBcbiAgICAgICAgICAgIGlmIChrZXkgaW4ga2V5TWFwICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ0tleSA9IGtleU1hcFtrZXldO1xuICAgICAgICAgICAgICAgIChzZXR0aW5nc1RvVXBkYXRlIGFzIGFueSlbc2V0dGluZ0tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICBpZiAoIXNldHRpbmdzVG9VcGRhdGUucmlnaHRicmFpbk9yZ0lkIHx8ICFzZXR0aW5nc1RvVXBkYXRlLnJpZ2h0YnJhaW5Qcm9qZWN0SWQgfHwgIXNldHRpbmdzVG9VcGRhdGUucmlnaHRicmFpbkNsaWVudElkIHx8ICFzZXR0aW5nc1RvVXBkYXRlLnJpZ2h0YnJhaW5DbGllbnRTZWNyZXQgfHwgIXNldHRpbmdzVG9VcGRhdGUucmlnaHRicmFpbkFwaVVybCB8fCAhc2V0dGluZ3NUb1VwZGF0ZS5yaWdodGJyYWluT2F1dGgyVXJsKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiU2V0dXAgZmFpbGVkLiBQYXN0ZWQgdGV4dCBpcyBtaXNzaW5nIG9uZSBvciBtb3JlIHJlcXVpcmVkIHZhbHVlcy5cIiwgNzAwMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih0aGlzLnBsdWdpbi5zZXR0aW5ncywgc2V0dGluZ3NUb1VwZGF0ZSk7XG4gICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICBuZXcgTm90aWNlKGBDcmVkZW50aWFscyBzYXZlZC5gKTtcbiAgICBcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIC0tLSBGSVggSVMgSEVSRTogLS0tXG4gICAgICAgIC8vIEp1c3QgY2FsbCB0aGUgc2V0dXAgZnVuY3Rpb24gYW5kIGxldCBpdCBydW4uIEl0IGhhbmRsZXMgaXRzIG93biBzdWNjZXNzL2ZhaWwgbm90aWNlcy5cbiAgICAgICAgLy8gV2Ugbm8gbG9uZ2VyIGNoZWNrIGZvciBhIHJldHVybiB2YWx1ZSBoZXJlLlxuICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zZXR1cFJpZ2h0QnJhaW5UYXNrcyh7XG4gICAgICAgICAgICBhcGlVcmw6IHNldHRpbmdzVG9VcGRhdGUucmlnaHRicmFpbkFwaVVybCxcbiAgICAgICAgICAgIG9hdXRoVXJsOiBzZXR0aW5nc1RvVXBkYXRlLnJpZ2h0YnJhaW5PYXV0aDJVcmwsXG4gICAgICAgICAgICBjbGllbnRJZDogc2V0dGluZ3NUb1VwZGF0ZS5yaWdodGJyYWluQ2xpZW50SWQsXG4gICAgICAgICAgICBjbGllbnRTZWNyZXQ6IHNldHRpbmdzVG9VcGRhdGUucmlnaHRicmFpbkNsaWVudFNlY3JldCxcbiAgICAgICAgICAgIG9yZ0lkOiBzZXR0aW5nc1RvVXBkYXRlLnJpZ2h0YnJhaW5PcmdJZCxcbiAgICAgICAgICAgIHByb2plY3RJZDogc2V0dGluZ3NUb1VwZGF0ZS5yaWdodGJyYWluUHJvamVjdElkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLmFwcGx5UmVjb21tZW5kZWRHcmFwaFNldHRpbmdzKCk7XG4gICAgfVxufVxuXG5cbi8vIC0tLS0tIFNFVFRJTkdTIFRBQiBDTEFTUyAtLS0tLVxuY2xhc3MgUHJvY2Vzc29yUHJvY2Vzc29yU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICAgIHBsdWdpbjogUHJvY2Vzc29yUHJvY2Vzc29yUGx1Z2luO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogUHJvY2Vzc29yUHJvY2Vzc29yUGx1Z2luKSB7XG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgfVxuXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnUHJvY2Vzc29yIFByb2Nlc3NvciBTZXR0aW5ncycgfSk7XG5cbiAgICAgICAgLy8gLS0tIEFQSSBLZXlzICYgQ3JlZGVudGlhbHMgLS0tXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ0FQSSBLZXlzICYgQ3JlZGVudGlhbHMnIH0pO1xuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdTZXJwQVBJIEtleScpXG4gICAgICAgICAgICAuc2V0RGVzYygnWW91ciBTZXJwQVBJIEtleSBmb3IgR29vZ2xlIHNlYXJjaCBmdW5jdGlvbmFsaXR5LicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHlvdXIgU2VycEFQSSBrZXknKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZXJwQXBpS2V5KVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VycEFwaUtleSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICAvLyAtLS0gUmlnaHRCcmFpbiBDb25maWd1cmF0aW9uIC0tLVxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdSaWdodEJyYWluIFRhc2sgQ29uZmlndXJhdGlvbicgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnQXV0b21hdGljYWxseSBTeW5jaHJvbml6ZSBUYXNrcyBvbiBMb2FkJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdJZiBlbmFibGVkLCB0aGUgcGx1Z2luIHdpbGwgY2hlY2sgZm9yIGFuZCBhcHBseSB1cGRhdGVzIGZyb20gaXRzIGxvY2FsIHRhc2sgZGVmaW5pdGlvbnMgb24gc3RhcnR1cC4gRGlzYWJsZSB0aGlzIGlmIHlvdSBwcmVmZXIgdG8gbWFuYWdlIGFuZCBjdXN0b21pemUgeW91ciB0YXNrcyBkaXJlY3RseSBpbiB0aGUgUmlnaHRCcmFpbiBkYXNoYm9hcmQgd2l0aG91dCB0aGVtIGJlaW5nIG92ZXJ3cml0dGVuLicpXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYXV0b1N5bmNocm9uaXplVGFza3MpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRvU3luY2hyb25pemVUYXNrcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1JCIEV4dHJhY3QgRW50aXRpZXM6IElucHV0IEZpZWxkIE5hbWUnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1RoZSBwYXJhbWV0ZXIgbmFtZSB5b3VyIFJCIEV4dHJhY3QgRW50aXRpZXMgdGFzayBleHBlY3RzIGZvciB0aGUgaW5wdXQgdGV4dCAoZS5nLiwgXCJwYWdlX3RleHRcIiwgXCJkb2N1bWVudF9jb250ZW50XCIpLicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucmlnaHRicmFpbkV4dHJhY3RJbnB1dEZpZWxkKVxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignZS5nLiwgcGFnZV90ZXh0JylcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJpZ2h0YnJhaW5FeHRyYWN0SW5wdXRGaWVsZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdSQiBFeHRyYWN0IEVudGl0aWVzOiBPdXRwdXQgRmllbGQgKFRoaXJkLVBhcnR5KScpXG4gICAgICAgICAgICAuc2V0RGVzYygnVGhlIGZpZWxkIG5hbWUgaW4geW91ciBSQiBFeHRyYWN0IEVudGl0aWVzIHRhc2tcXCdzIEpTT04gb3V0cHV0IGZvciB0aGUgbGlzdCBvZiB0aGlyZC1wYXJ0eSBzdWJwcm9jZXNzb3JzIChlLmcuLCBcInRoaXJkX3BhcnR5X3N1YnByb2Nlc3NvcnNcIikuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yaWdodGJyYWluRXh0cmFjdE91dHB1dFRoaXJkUGFydHlGaWVsZClcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ2UuZy4sIHRoaXJkX3BhcnR5X3N1YnByb2Nlc3NvcnMnKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmlnaHRicmFpbkV4dHJhY3RPdXRwdXRUaGlyZFBhcnR5RmllbGQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1JCIEV4dHJhY3QgRW50aXRpZXM6IE91dHB1dCBGaWVsZCAoT3duIEVudGl0aWVzKScpXG4gICAgICAgICAgICAuc2V0RGVzYygnVGhlIGZpZWxkIG5hbWUgaW4geW91ciBSQiBFeHRyYWN0IEVudGl0aWVzIHRhc2tcXCdzIEpTT04gb3V0cHV0IGZvciB0aGUgbGlzdCBvZiBvd24vYWZmaWxpYXRlZCBlbnRpdGllcyAoZS5nLiwgXCJvd25fZW50aXRpZXNcIikuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yaWdodGJyYWluRXh0cmFjdE91dHB1dE93bkVudGl0aWVzRmllbGQpXG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdlLmcuLCBvd25fZW50aXRpZXMnKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmlnaHRicmFpbkV4dHJhY3RPdXRwdXRPd25FbnRpdGllc0ZpZWxkID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuXG4gICAgICAgIC8vIC0tLSBHZW5lcmFsIFNldHRpbmdzIC0tLVxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdHZW5lcmFsIFNldHRpbmdzJyB9KTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnQ3JlYXRlIFBhZ2VzIGZvciBPd24gRW50aXRpZXMnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0lmIGVuYWJsZWQsIHNlcGFyYXRlIE1hcmtkb3duIHBhZ2VzIHdpbGwgYWxzbyBiZSBjcmVhdGVkIGZvciBcIm93biBlbnRpdGllc1wiIGlkZW50aWZpZWQgZHVyaW5nIHByb2Nlc3NpbmcsIG5vdCBqdXN0IHRoaXJkLXBhcnR5IHN1YnByb2Nlc3NvcnMuJylcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5jcmVhdGVQYWdlc0Zvck93bkVudGl0aWVzKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY3JlYXRlUGFnZXNGb3JPd25FbnRpdGllcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdWZXJib3NlIERlYnVnIExvZ2dpbmcnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0VuYWJsZSBkZXRhaWxlZCBsb2dnaW5nIHRvIHRoZSBkZXZlbG9wZXIgY29uc29sZSBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLicpXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudmVyYm9zZURlYnVnKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudmVyYm9zZURlYnVnID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgXG4gICAgICAgIC8vIG1heFJlc3VsdHNQZXJQcm9jZXNzb3IgaXMgbm90IHR5cGljYWxseSB1c2VyLWNvbmZpZ3VyYWJsZSBpZiBpdCdzIGZpeGVkIGZvciBcInN0b3Agb24gZmlyc3QgdHJ1ZS90cnVlXCIgbG9naWNcbiAgICAgICAgLy8gSWYgaXQgd2VyZSwgaXQgd291bGQgYmUgYW4gYWRkVGV4dCBvciBhZGRTbGlkZXJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnTWF4IFJlc3VsdHMgUGVyIFByb2Nlc3NvciAoRGlzY292ZXJ5KScpXG4gICAgICAgICAgICAuc2V0RGVzYygnTWF4aW11bSBzZWFyY2ggcmVzdWx0cyB0byBwcm9jZXNzIGZvciBlYWNoIHByb2Nlc3NvciBkdXJpbmcgaW5pdGlhbCBkaXNjb3ZlcnkuIEN1cnJlbnRseSwgdGhlIGxvZ2ljIHN0b3BzIG9uIHRoZSBmaXJzdCB2ZXJpZmllZCBsaXN0LCBlZmZlY3RpdmVseSBtYWtpbmcgdGhpcyAxLicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubWF4UmVzdWx0c1BlclByb2Nlc3Nvci50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZCh0cnVlKSAvLyBTaW5jZSB0aGUgbG9naWMgaXMgaGFyZGNvZGVkIHRvIHN0b3Agb24gZmlyc3QgdmVyaWZpZWRcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2V0dGluZyBpcyBtb3N0bHkgaW5mb3JtYXRpb25hbCBkdWUgdG8gY3VycmVudCBsb2dpY1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBudW0gPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmICghaXNOYU4obnVtKSAmJiBudW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5tYXhSZXN1bHRzUGVyUHJvY2Vzc29yID0gbnVtO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnTWFwcGluZyBEZXB0aCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnU2V0IHRoZSBtYXhpbXVtIGRlcHRoIGZvciB0aGUgTWFwIFN1YnByb2Nlc3NvciBSZWxhdGlvbnNoaXBzIGZ1bmN0aW9uIChlLmcuLCAyLTUpLiBIaWdoZXIgbnVtYmVycyB3aWxsIHRha2UgbXVjaCBsb25nZXIgYW5kIHVzZSBtb3JlIEFQSSBjYWxscy4nKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdlLmcuLCAzJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubWF4UmVjdXJzaXZlRGVwdGgudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihudW0pICYmIG51bSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm1heFJlY3Vyc2l2ZURlcHRoID0gbnVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAgICAgICAgIC5zZXROYW1lKCdEaXNjb3ZlcnkgQ2FjaGUgRHVyYXRpb24gKERheXMpJylcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2MoJ0hvdyBtYW55IGRheXMgdG8gY29uc2lkZXIgYSBwcm9jZXNzb3JcXCdzIGRhdGEgXCJmcmVzaFwiLiBBIHByb2Nlc3NvciB3aXRoIGEgXCJjb21wbGV0ZVwiIHN0YXR1cyBkaXNjb3ZlcmVkIHdpdGhpbiB0aGlzIHBlcmlvZCB3aWxsIGJlIHNraXBwZWQgZHVyaW5nIHJlY3Vyc2l2ZSBydW5zLicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdlLmcuLCAzMCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZGlzY292ZXJ5Q2FjaGVEYXlzLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4obnVtKSAmJiBudW0gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kaXNjb3ZlcnlDYWNoZURheXMgPSBudW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdQcm9jZXNzb3JzIEZvbGRlciBQYXRoJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgcHJvY2Vzc29yIGFuZCBzdWJwcm9jZXNzb3Igbm90ZXMgd2lsbCBiZSBzdG9yZWQgKGUuZy4sIFwiVGhpcmQgUGFydGllcy9Qcm9jZXNzb3JzXCIpLicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ2UuZy4sIFByb2Nlc3NvcnMnKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9jZXNzb3JzRm9sZGVyUGF0aClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2Nlc3NvcnNGb2xkZXJQYXRoID0gdmFsdWUgfHwgREVGQVVMVF9TRVRUSU5HUy5wcm9jZXNzb3JzRm9sZGVyUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0FuYWx5c2lzIExvZ3MgRm9sZGVyIFBhdGgnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSBhbmFseXNpcyBsb2cgbm90ZXMgZm9yIGVhY2ggcHJvY2Vzc29yIHdpbGwgYmUgc3RvcmVkIChlLmcuLCBcIkNvbXBsaWFuY2UvTG9nc1wiKS4nKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdlLmcuLCBBbmFseXNpcyBMb2dzJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYW5hbHlzaXNMb2dzRm9sZGVyUGF0aClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmFuYWx5c2lzTG9nc0ZvbGRlclBhdGggPSB2YWx1ZSB8fCBERUZBVUxUX1NFVFRJTkdTLmFuYWx5c2lzTG9nc0ZvbGRlclBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdSaWdodEJyYWluIE1vZGVsIENvbmZpZ3VyYXRpb24nIH0pO1xuXG4gICAgICAgIC8vIC0tLSBUSElTIElTIFRIRSBDT1JSRUNURUQgQkxPQ0sgLS0tXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldERlc2MoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGNvcnJlY3QgZGFzaGJvYXJkIFVSTCBmcm9tIHRoZSBzYXZlZCBBUEkgVVJMLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFwaVVybCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnJpZ2h0YnJhaW5BcGlVcmwgfHwgJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgZGFzaGJvYXJkVXJsID0gKGFwaVVybC5pbmNsdWRlcygnc3RhZycpIHx8IGFwaVVybC5pbmNsdWRlcygnbGVmdGJyYWluJykpXG4gICAgICAgICAgICAgICAgICAgID8gJ2h0dHBzOi8vc3RhZy5sZWZ0YnJhaW4ubWUnXG4gICAgICAgICAgICAgICAgICAgIDogJ2h0dHBzOi8vYXBwLnJpZ2h0YnJhaW4uYWknO1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgYnVpbGQgdGhlIGRlc2NyaXB0aW9uIGluc2lkZSBhIERvY3VtZW50RnJhZ21lbnQgdG8gaW5jbHVkZSBhIGxpbmsuXG4gICAgICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZFRleHQoJ1lvdSBjYW4gY29uZmlndXJlIGJhc2ljIFJpZ2h0QnJhaW4gc2V0dGluZ3MgaGVyZSwgb3IgbG9nIGluIHRvIHRoZSAnKTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5jcmVhdGVFbCgnYScsIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ1JpZ2h0YnJhaW4gRGFzaGJvYXJkJyxcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogZGFzaGJvYXJkVXJsLFxuICAgICAgICAgICAgICAgICAgICBhdHRyOiB7ICd0YXJnZXQnOiAnX2JsYW5rJywgJ3JlbCc6ICdub29wZW5lciBub3JlZmVycmVyJyB9IC8vIEFkZGVkIHJlbCBmb3Igc2VjdXJpdHlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRUZXh0KCcgZm9yIG1vcmUgZmluZS10dW5lZCBjb250cm9sLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgICAgIH0pKCkpOyAgICAgICAgXG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIlJlZnJlc2ggTW9kZWwgTGlzdFwiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJGZXRjaCB0aGUgbGF0ZXN0IGF2YWlsYWJsZSBMTE0gbW9kZWxzIGZyb20geW91ciBSaWdodEJyYWluIHByb2plY3QuIFRoZSBsaXN0IGlzIGF1dG9tYXRpY2FsbHkgY2FjaGVkIGZvciAyNCBob3Vycy5cIilcbiAgICAgICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KFwiUmVmcmVzaCBOb3dcIilcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnVwZGF0ZUxsbU1vZGVsTGlzdCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgYSByZWRyYXcgb2YgdGhlIHNldHRpbmdzIHRhYiB0byB1cGRhdGUgdGhlIGRyb3Bkb3duc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTsgXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIGNvbnN0IHRhc2tEZWZzRm9yVUkgPSBbXG4gICAgICAgICAgICB7IG5hbWU6IFwiVmVyaWZ5IFN1YnByb2Nlc3NvciBMaXN0IFVSTFwiLCBzZXR0aW5nS2V5OiBcInZlcmlmeVVybE1vZGVsSWRcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcIkV4dHJhY3QgRW50aXRpZXMgRnJvbSBQYWdlIENvbnRlbnRcIiwgc2V0dGluZ0tleTogXCJleHRyYWN0RW50aXRpZXNNb2RlbElkXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJEZWR1cGxpY2F0ZSBTdWJwcm9jZXNzb3JzXCIsIHNldHRpbmdLZXk6IFwiZGVkdXBsaWNhdGVTdWJwcm9jZXNzb3JzTW9kZWxJZFwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiRERHIFNFUlAgUGFyc2VyXCIsIHNldHRpbmdLZXk6IFwiZHVja0R1Y2tHb1NlYXJjaE1vZGVsSWRcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcIkZpbmQgRFBBIFVSTFwiLCBzZXR0aW5nS2V5OiBcImZpbmREcGFNb2RlbElkXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJGaW5kIFRvUyBVUkxcIiwgc2V0dGluZ0tleTogXCJmaW5kVG9zTW9kZWxJZFwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiRmluZCBTZWN1cml0eSBQYWdlIFVSTFwiLCBzZXR0aW5nS2V5OiBcImZpbmRTZWN1cml0eU1vZGVsSWRcIiB9XG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgYXZhaWxhYmxlTW9kZWxzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MubGxtTW9kZWxMaXN0O1xuICAgICAgICBjb25zdCBkZWZhdWx0TW9kZWwgPSBhdmFpbGFibGVNb2RlbHMuZmluZChtID0+IG0uYWxpYXMudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZ2VtaW5pIDEuNSBmbGFzaCcpKTtcblxuICAgICAgICB0YXNrRGVmc0ZvclVJLmZvckVhY2godGFzayA9PiB7XG4gICAgICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgICAgICAuc2V0TmFtZSh0YXNrLm5hbWUpXG4gICAgICAgICAgICAgICAgLnNldERlc2MoYFNlbGVjdCB0aGUgTExNIHRvIHVzZSBmb3IgdGhlIFwiJHt0YXNrLm5hbWV9XCIgdGFzay5gKVxuICAgICAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdmFpbGFibGVNb2RlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5hZGRPcHRpb24oJycsICdObyBtb2RlbHMgbG9hZGVkLiBSZWZyZXNoIGxpc3Qgb3IgY2hlY2sgY3JlZGVudGlhbHMuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5zZXREaXNhYmxlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZU1vZGVscy5mb3JFYWNoKG1vZGVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duLmFkZE9wdGlvbihtb2RlbC5pZCwgbW9kZWwuYWxpYXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdmFsdWUgdG8gdGhlIHNhdmVkIHNldHRpbmcsIG9yIHRoZSBkZWZhdWx0IG1vZGVsLCBvciB0aGUgZmlyc3QgbW9kZWxcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudE1vZGVsSWQgPSAodGhpcy5wbHVnaW4uc2V0dGluZ3MgYXMgYW55KVt0YXNrLnNldHRpbmdLZXldO1xuICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5zZXRWYWx1ZShjdXJyZW50TW9kZWxJZCB8fCAoZGVmYXVsdE1vZGVsID8gZGVmYXVsdE1vZGVsLmlkIDogYXZhaWxhYmxlTW9kZWxzWzBdLmlkKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24ub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5wbHVnaW4uc2V0dGluZ3MgYXMgYW55KVt0YXNrLnNldHRpbmdLZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYCR7dGFzay5uYW1lfSB3aWxsIG5vdyB1c2UgJHtkcm9wZG93bi5zZWxlY3RFbC5vcHRpb25zW2Ryb3Bkb3duLnNlbGVjdEVsLnNlbGVjdGVkSW5kZXhdLnRleHR9LmApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUF1TDtBQUd2TCxJQUFNLDRCQUE0QjtBQUFBLEVBQzlCO0FBQUEsRUFBZ0I7QUFBQSxFQUFpQjtBQUFBLEVBQ2pDO0FBQUEsRUFBZTtBQUFBLEVBQWM7QUFBQSxFQUFvQjtBQUFBLEVBQ2pEO0FBQUEsRUFBcUI7QUFBQSxFQUNyQjtBQUFBLEVBQWU7QUFBQSxFQUFlO0FBQUEsRUFDOUI7QUFBQSxFQUFvQjtBQUN4QjtBQThDQSxJQUFNLG1CQUErQztBQUFBLEVBQ2pELFlBQVk7QUFBQSxFQUNaLG9CQUFvQjtBQUFBLEVBQ3BCLHdCQUF3QjtBQUFBLEVBQ3hCLGlCQUFpQjtBQUFBLEVBQ2pCLHFCQUFxQjtBQUFBLEVBQ3JCLGtCQUFrQjtBQUFBLEVBQ2xCLHFCQUFxQjtBQUFBLEVBQ3JCLDJCQUEyQjtBQUFBLEVBQzNCLGlDQUFpQztBQUFBLEVBQ2pDLDZCQUE2QjtBQUFBLEVBQzdCLHdDQUF3QztBQUFBLEVBQ3hDLHlDQUF5QztBQUFBLEVBQ3pDLDBDQUEwQztBQUFBLEVBQzFDLGtDQUFrQztBQUFBLEVBQ2xDLDJCQUEyQjtBQUFBLEVBQzNCLGNBQWM7QUFBQSxFQUNkLHdCQUF3QjtBQUFBLEVBQ3hCLG1CQUFtQjtBQUFBLEVBQ25CLG9CQUFvQjtBQUFBLEVBQ3BCLHNCQUFzQjtBQUFBLEVBQ3RCLHdCQUF3QjtBQUFBLEVBQ3hCLHlCQUF5QjtBQUFBLEVBQ3pCLHlCQUF5QjtBQUFBLEVBQ3pCLDhCQUE4QjtBQUFBLEVBQzlCLHNCQUFz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
